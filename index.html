<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Dungeon Quest</title>
<style>
  * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: monospace;
  background: linear-gradient(135deg, #0a0f15 0%, #151a20 50%, #0a0f15 100%);
  color: #e8eaed;
  padding: 10px;
  font-size: 14px;
  line-height: 1.4;
  max-width: 100%;
  overflow-x: hidden;
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  gap: 10px;
  transition: all 0.3s ease;
}

#map {
  white-space: pre;
  font-family: monospace;
  font-size: 16px;
  line-height: 1.2;
  background: linear-gradient(145deg, #1a2332, #0f1419);
  border: 1px solid #2a3441;
  box-shadow: 
    inset 0 1px 3px rgba(255, 255, 255, 0.05),
    inset 0 -1px 3px rgba(0, 0, 0, 0.4),
    0 4px 12px rgba(0, 0, 0, 0.5);
  padding: 10px;
  border-radius: 8px;
  overflow-x: auto;
  max-width: 100%;
  transition: box-shadow 0.3s ease;
}

#map:hover {
  box-shadow: 
    inset 0 1px 3px rgba(255, 255, 255, 0.08),
    inset 0 -1px 3px rgba(0, 0, 0, 0.5),
    0 6px 16px rgba(0, 5, 15, 0.6);
}

#content-row {
  display: flex;
  gap: 10px;
  width: 100%;
}

#log {
  flex: 1;
  height: 150px;
  overflow-y: auto;
  background: linear-gradient(145deg, #1a2332, #0f1419);
  border: 1px solid #2a3441;
  box-shadow: 
    inset 0 2px 4px rgba(0, 0, 0, 0.4),
    inset 0 -1px 2px rgba(255, 255, 255, 0.05),
    0 2px 8px rgba(0, 5, 15, 0.4);
  padding: 8px;
  border-radius: 8px;
  transition: all 0.3s ease;
}

#stats {
  flex: 1;
  background: linear-gradient(145deg, #1a2332, #0f1419);
  border: 1px solid #2a3441;
  box-shadow: 
    inset 0 2px 4px rgba(0, 0, 0, 0.4),
    inset 0 -1px 2px rgba(255, 255, 255, 0.05),
    0 2px 8px rgba(0, 5, 15, 0.4);
  padding: 5px;
  border-radius: 8px;
  height: 150px;
  overflow-y: auto;
  transition: all 0.3s ease;
}

.stat-row {
  display: flex;
  justify-content: space-between;
}

.stat-item {
  background: linear-gradient(145deg, #243242, #1a2530);
  border: 1px solid #344250;
  box-shadow: 
    inset 0 1px 2px rgba(255, 255, 255, 0.08),
    inset 0 -1px 2px rgba(0, 0, 0, 0.4),
    0 2px 4px rgba(0, 5, 15, 0.3);
  padding: 5px 8px;
  border-radius: 6px;
  flex: 1;
  text-align: center;
  margin: 0 2px;
  transition: all 0.3s ease;
  color: #e8eaed;
  font-weight: 500;
}

#controls {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  width: 100%;
}

#nav {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: 5px;
  width: 50%;
  max-width: 200px;
}

.nav-btn {
  font-size: 1em;
  width: 100%;
  aspect-ratio: 1/1;
  background: linear-gradient(145deg, #243242, #1a2530);
  border: 1px solid #344250;
  box-shadow: 
    inset 0 1px 2px rgba(255, 255, 255, 0.08),
    inset 0 -1px 2px rgba(0, 0, 0, 0.4),
    0 3px 6px rgba(0, 5, 15, 0.4);
  color: #e8eaed;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  border-radius: 8px;
  transition: all 0.2s ease;
  font-weight: 600;
  cursor: pointer;
}

.nav-cell {
  visibility: hidden;
}

#actions {
  display: flex;
  flex-direction: column;
  gap: 5px;
  width: 50%;
}

.act-btn {
  font-size: 0.85em;
  padding: 6px 4px;
  background: linear-gradient(145deg, #243242, #1a2530);
  border: 1px solid #344250;
  box-shadow: 
    inset 0 1px 2px rgba(255, 255, 255, 0.08),
    inset 0 -1px 2px rgba(0, 0, 0, 0.4),
    0 3px 6px rgba(0, 5, 15, 0.4);
  color: #e8eaed;
  text-align: center;
  border-radius: 6px;
  flex: 1;
  transition: all 0.2s ease;
  font-weight: 500;
  cursor: pointer;
}

.nav-btn:hover {
  background: linear-gradient(145deg, #2a3a4a, #1f2d3a);
  box-shadow: 
    inset 0 1px 2px rgba(255, 255, 255, 0.12),
    inset 0 -1px 2px rgba(0, 0, 0, 0.5),
    0 5px 10px rgba(0, 10, 25, 0.5);
  transform: translateY(-2px);
  color: #f0f2f5;
}

.nav-btn:active {
  transform: translateY(0px);
  box-shadow: 
    inset 0 2px 4px rgba(0, 0, 0, 0.4),
    inset 0 -1px 1px rgba(255, 255, 255, 0.05),
    0 1px 3px rgba(0, 0, 0, 0.2);
}

.act-btn:hover {
  background: linear-gradient(145deg, #2a3a4a, #1f2d3a);
  box-shadow: 
    inset 0 1px 2px rgba(255, 255, 255, 0.12),
    inset 0 -1px 2px rgba(0, 0, 0, 0.5),
    0 5px 10px rgba(0, 10, 25, 0.5);
  transform: translateY(-1px);
  color: #f0f2f5;
}

.act-btn:active {
  transform: translateY(0px);
  box-shadow: 
    inset 0 2px 4px rgba(0, 0, 0, 0.4),
    inset 0 -1px 1px rgba(255, 255, 255, 0.05),
    0 1px 3px rgba(0, 0, 0, 0.2);
}

.stat-item:hover {
  background: linear-gradient(145deg, #2a3a4a, #1f2d3a);
  box-shadow: 
    inset 0 1px 2px rgba(255, 255, 255, 0.12),
    inset 0 -1px 2px rgba(0, 0, 0, 0.5),
    0 4px 8px rgba(0, 10, 25, 0.4);
  transform: translateY(-1px);
}

/* Color coding for map elements */
.monster-lvl1 { color: #ff9999; }
.monster-lvl2 { color: #ff6666; }
.monster-lvl3 { color: #ff3333; }
.monster-lvl4 { color: #ff0000; }
.monster-lvl5 { color: #cc0000; }
.monster-lvl6 { color: #990000; }
.monster-lvl7 { color: #660000; }
.monster-lvl8 { color: #aa0000; }
.monster-lvl9 { color: #440000; }
.monster-lvl10 { color: #220000; }
.chest { color: #ffff00; }
.town-npc { color: #55ffff; }
.resource { color: #55ff55; }

/* Modal styles */
.overlay, .modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
}

.overlay {
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(4px);
  z-index: 10;
  transition: opacity 0.3s ease;
}

.modal {
  background: linear-gradient(145deg, #1a2332, #0f1419);
  border: 1px solid #2a3441;
  box-shadow: 
    inset 0 1px 3px rgba(255, 255, 255, 0.08),
    inset 0 -1px 3px rgba(0, 0, 0, 0.4),
    0 20px 40px rgba(0, 5, 15, 0.7);
  width: 90%;
  max-width: 400px;
  max-height: 80vh;
  overflow: auto;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 15px;
  border-radius: 12px;
  z-index: 11;
  transition: all 0.3s ease;
}

/* Quest Modal Styles */
#quest-modal {
  display: none;
}

.quest-options {
  display: flex;
  justify-content: space-between;
  margin-top: 15px;
  gap: 10px;
}

.quest-options button {
  padding: 8px 15px;
  border-radius: 6px;
  border: none;
  flex: 1;
  transition: all 0.2s ease;
  font-weight: 600;
  cursor: pointer;
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
}

.quest-options button:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 10px rgba(0, 0, 0, 0.4);
}

.quest-options button:active {
  transform: translateY(0px);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

.quest-accept {
  background: linear-gradient(145deg, #4CAF50, #45a049);
  color: white;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.quest-accept:hover {
  background: linear-gradient(145deg, #5cbf60, #4CAF50);
}

.quest-decline {
  background: linear-gradient(145deg, #f44336, #da190b);
  color: white;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.quest-decline:hover {
  background: linear-gradient(145deg, #f66356, #f44336);
}

.quest-details {
  margin: 10px 0;
  line-height: 1.6;
}

@media (min-width: 500px) {
  #nav {
    width: 180px;
  }
  
  #actions {
    width: calc(100% - 190px);
  }
  
  .act-btn {
    padding: 10px;
  }
}
</style>
</head>
<body>

<div id="map"></div>
<div id="content-row">
  <div id="log"></div>
  <div id="stats"></div>
</div>

<div id="controls">
  <!-- Nav: plus shape -->
  <div id="nav">
    <div class="nav-cell"></div>
    <button class="nav-btn" data-dir="up">↑</button>
    <div class="nav-cell"></div>

    <button class="nav-btn" data-dir="left">←</button>
    <div class="nav-cell"></div>
    <button class="nav-btn" data-dir="right">→</button>

    <div class="nav-cell"></div>
    <button class="nav-btn" data-dir="down">↓</button>
    <div class="nav-cell"></div>
  </div>

  <!-- Actions -->
  <div id="actions">
    <button id="btn-inv" class="act-btn">Inventory</button>
    <button id="btn-craft" class="act-btn">Crafting</button>
    <button id="btn-shop" class="act-btn">Market</button>
    <button id="btn-quests" class="act-btn">Quests</button>
    <button id="btn-reborn" class="act-btn">Reborn</button>
  </div>
</div>

<div id="overlay" class="overlay"></div>
<div id="modal" class="modal"></div>
<div id="quest-modal" class="modal"></div>

<script>
(() => {
  // Helper function to round to 1 decimal place
  const round1 = num => Math.round(num * 10) / 10;
  
  // Data definitions - expanded monster templates with exponential scaling
  const monsterTpl={
    Goblin: {base:{hp:8,atk:3,def:1,boost:'atk'}, levels:[
      {name:'Goblin',mult:1,reward:0.1},
      {name:'Hobgoblin',mult:2,reward:0.2},
      {name:'Goblin Warrior',mult:4,reward:0.4},
      {name:'Goblin Elite',mult:8,reward:0.8},
      {name:'Goblin Captain',mult:16,reward:1.6},
      {name:'Goblin King',mult:32,reward:3.2},
      {name:'Goblin Warlord',mult:64,reward:6.4},
      {name:'Goblin Overlord',mult:128,reward:12.8},
      {name:'Goblin Emperor',mult:256,reward:25.6},
      {name:'Ancient Goblin',mult:512,reward:51.2}
    ]},
    Skeleton: {base:{hp:12,atk:4,def:2,boost:'def'}, levels:[
      {name:'Skeleton',mult:1,reward:0.1},
      {name:'Skeleton Warrior',mult:2,reward:0.2},
      {name:'Skeleton Soldier',mult:4,reward:0.4},
      {name:'Skeleton Knight',mult:8,reward:0.8},
      {name:'Skeleton Elite',mult:16,reward:1.6},
      {name:'Skeleton Duke',mult:32,reward:3.2},
      {name:'Skeleton King',mult:64,reward:6.4},
      {name:'Skeleton Lord',mult:128,reward:12.8},
      {name:'Skeleton Emperor',mult:256,reward:25.6},
      {name:'Bone Archlich',mult:512,reward:51.2}
    ]},
    Wolf: {base:{hp:15,atk:5,def:3,boost:'maxHp'}, levels:[
      {name:'Wolf',mult:1,reward:0.1},
      {name:'Wild Wolf',mult:2,reward:0.2},
      {name:'Dark Wolf',mult:4,reward:0.4},
      {name:'Dire Wolf',mult:8,reward:0.8},
      {name:'Shadow Wolf',mult:16,reward:1.6},
      {name:'Alpha Wolf',mult:32,reward:3.2},
      {name:'Werewolf',mult:64,reward:6.4},
      {name:'Fenrir Wolf',mult:128,reward:12.8},
      {name:'Demon Wolf',mult:256,reward:25.6},
      {name:'Primordial Wolf',mult:512,reward:51.2}
    ]},
    Orc: {base:{hp:10,atk:6,def:2,boost:'atk'}, levels:[
      {name:'Orc',mult:1,reward:0.1},
      {name:'Orc Scout',mult:2,reward:0.2},
      {name:'Orc Fighter',mult:4,reward:0.4},
      {name:'Orc Berserker',mult:8,reward:0.8},
      {name:'Orc Champion',mult:16,reward:1.6},
      {name:'Orc Warlord',mult:32,reward:3.2},
      {name:'Orc Chieftain',mult:64,reward:6.4},
      {name:'Orc General',mult:128,reward:12.8},
      {name:'Orc Emperor',mult:256,reward:25.6},
      {name:'Orc Destroyer',mult:512,reward:51.2}
    ]},
    Ogre: {base:{hp:12,atk:4,def:4,boost:'maxHp'}, levels:[
      {name:'Ogre',mult:1,reward:0.1},
      {name:'Ogre Brute',mult:2,reward:0.2},
      {name:'Ogre Warrior',mult:4,reward:0.4},
      {name:'Ogre Berserker',mult:8,reward:0.8},
      {name:'Ogre Champion',mult:16,reward:1.6},
      {name:'Ogre Warlord',mult:32,reward:3.2},
      {name:'Ogre King',mult:64,reward:6.4},
      {name:'Ogre Titan',mult:128,reward:12.8},
      {name:'Ogre Colossus',mult:256,reward:25.6},
      {name:'Ancient Ogre',mult:512,reward:51.2}
    ]},
    Gnoll: {base:{hp:9,atk:5,def:3,boost:'def'}, levels:[
      {name:'Gnoll',mult:1,reward:0.1},
      {name:'Gnoll Hunter',mult:2,reward:0.2},
      {name:'Gnoll Warrior',mult:4,reward:0.4},
      {name:'Gnoll Shaman',mult:8,reward:0.8},
      {name:'Gnoll Chieftain',mult:16,reward:1.6},
      {name:'Gnoll Warlord',mult:32,reward:3.2},
      {name:'Gnoll King',mult:64,reward:6.4},
      {name:'Gnoll Packmaster',mult:128,reward:12.8},
      {name:'Gnoll Emperor',mult:256,reward:25.6},
      {name:'Gnoll Demigod',mult:512,reward:51.2}
    ]},
    Wyvern: {base:{hp:10,atk:6,def:5,boost:'atk'}, levels:[
      {name:'Wyvern',mult:1,reward:0.1},
      {name:'Young Wyvern',mult:2,reward:0.2},
      {name:'Adult Wyvern',mult:4,reward:0.4},
      {name:'Elder Wyvern',mult:8,reward:0.8},
      {name:'Wyvern Lord',mult:16,reward:1.6},
      {name:'Wyvern King',mult:32,reward:3.2},
      {name:'Dragon Wyvern',mult:64,reward:6.4},
      {name:'Ancient Wyvern',mult:128,reward:12.8},
      {name:'Primordial Wyvern',mult:256,reward:25.6},
      {name:'Wyvern God',mult:512,reward:51.2}
    ]},
    Leviathan: {base:{hp:12,atk:8,def:6,boost:'atk'}, levels:[
      {name:'Leviathan',mult:1,reward:0.1},
      {name:'Young Leviathan',mult:2,reward:0.2},
      {name:'Adult Leviathan',mult:4,reward:0.4},
      {name:'Elder Leviathan',mult:8,reward:0.8},
      {name:'Leviathan Lord',mult:16,reward:1.6},
      {name:'Leviathan King',mult:32,reward:3.2},
      {name:'Dragon Leviathan',mult:64,reward:6.4},
      {name:'Ancient Leviathan',mult:128,reward:12.8},
      {name:'Primordial Leviathan',mult:256,reward:25.6},
      {name:'Leviathan God',mult:512,reward:51.2},
      {name:'Leviathan Titan',mult:1024,reward:102.4},
      {name:'Leviathan Emperor',mult:2048,reward:204.8},
      {name:'Leviathan Overlord',mult:4096,reward:409.6},
      {name:'Leviathan Destroyer',mult:8192,reward:819.2},
      {name:'Leviathan',mult:16384,reward:1638.4}
    ]},
    DeathStar: {base:{hp:15,atk:7,def:8,boost:'def'}, levels:[
      {name:'Death Star',mult:1,reward:0.1},
      {name:'Young Death Star',mult:2,reward:0.2},
      {name:'Adult Death Star',mult:4,reward:0.4},
      {name:'Elder Death Star',mult:8,reward:0.8},
      {name:'Death Star Lord',mult:16,reward:1.6},
      {name:'Death Star King',mult:32,reward:3.2},
      {name:'Dragon Death Star',mult:64,reward:6.4},
      {name:'Ancient Death Star',mult:128,reward:12.8},
      {name:'Primordial Death Star',mult:256,reward:25.6},
      {name:'Death Star God',mult:512,reward:51.2},
      {name:'Death Star Titan',mult:1024,reward:102.4},
      {name:'Death Star Emperor',mult:2048,reward:204.8},
      {name:'Death Star Overlord',mult:4096,reward:409.6},
      {name:'Death Star Destroyer',mult:8192,reward:819.2},
      {name:'Death Star',mult:16384,reward:1638.4}
    ]},
    Susano: {base:{hp:18,atk:9,def:7,boost:'maxHp'}, levels:[
      {name:'Susano',mult:1,reward:0.1},
      {name:'Young Susano',mult:2,reward:0.2},
      {name:'Adult Susano',mult:4,reward:0.4},
      {name:'Elder Susano',mult:8,reward:0.8},
      {name:'Susano Lord',mult:16,reward:1.6},
      {name:'Susano King',mult:32,reward:3.2},
      {name:'Dragon Susano',mult:64,reward:6.4},
      {name:'Ancient Susano',mult:128,reward:12.8},
      {name:'Primordial Susano',mult:256,reward:25.6},
      {name:'Susano God',mult:512,reward:51.2},
      {name:'Susano Titan',mult:1024,reward:102.4},
      {name:'Susano Emperor',mult:2048,reward:204.8},
      {name:'Susano Overlord',mult:4096,reward:409.6},
      {name:'Susano Destroyer',mult:8192,reward:819.2},
      {name:'Susano',mult:16384,reward:1638.4}
    ]}
  };

  const shops={ 
    'Potion Seller':[
      {name:'Health Potion',price:5,apply:()=>{p.hp=Math.min(p.maxHp,round1(p.hp+10))}},
      {name:'Strength Potion',price:10,apply:()=>{p.tempAtk={value:roll(10,20),steps:roll(30,90)}}},
      {name:'Rage Potion',price:50,apply:()=>{
        p.tempAtk={value:Math.floor(p.atk * 2),steps:30};
        p.hp = Math.max(1, round1(p.hp * 0.75));
        log("Rage consumes your health!");
      }},
      {name:'Warrior\'s Elixir',price:30,apply:()=>{p.tempAtk={value:15,steps:50}}},
      {name:'Guardian Tonic',price:20,apply:()=>{p.tempDef={value:20,steps:60}}},
      {name:'Master Crafter\'s Brew',price:100,apply:()=>{p.tempCraft={value:50,steps:30}}},
      {name:'Orc\'s Rage',price:175,apply:()=>{
        p.tempOrcsRage={atkBoost:200,defDebuff:0.5,steps:40};
        log("Orc's Rage: +200 attack, -50% defense for 40 steps!");
      }},
      {name:'Angel\'s Touch',price:250,apply:()=>{
        p.tempAngelsTouch={maxHpBoost:200,defBoost:100,atkDebuff:0.75,steps:40};
        p.maxHp = round1(p.maxHp + 200);
        p.hp = round1(p.hp + 200);
        log("Angel's Touch: +200 max HP, +100 defense, -25% attack for 40 steps!");
      }},
      {name:'Dragon Fury',price:500,apply:()=>{
        p.tempDragonFury={atkBoost:800,defDebuff:0.3,maxHpDebuff:0.5,steps:10};
        p.maxHp = Math.max(1, round1(p.maxHp * 0.5));
        p.hp = Math.min(p.hp, p.maxHp);
        log("Dragon Fury: +800 attack, -70% defense, -50% max HP for 10 steps!");
      }},
      {name:'God\'s Gift',price:2500,apply:()=>{
        p.tempGodsGift={defBoost:7000,steps:5};
        log("God's Gift: +7000 defense for 5 steps!");
      }}
    ], 
    'Blacksmith':[
      {name:'Iron Sword',price:20,apply:()=>{equip('Iron Sword')}}
    ], 
    'Scroll Merchant':[
      {name:'Scroll of Healing',price:12,apply:()=>{p.hp=p.maxHp}},
      {name:'Luck Charm',price:50,apply:()=>{p.tempLuck={value:10,steps:10}}}
    ] 
  };

  const itemDefs={
    'Spear':{boost:{atk:2},maxD:100,level:1},
    'Shield':{boost:{def:3},maxD:100,level:1},
    'Greatsword':{boost:{atk:4},maxD:100,level:1},
    'PlateArmor':{boost:{maxHp:10},maxD:100,level:1},
    'Iron Sword':{boost:{atk:3},maxD:100,level:1},
    'Skeleton_King_Bone':{boost:{def:1},maxD:50,level:1},
    'Dire_Wolf_Pelt':{boost:{maxHp:5},maxD:50,level:1},
    // Level 10 special items
    'Ancient_Goblin_Crown':{boost:{atk:5,def:2},maxD:200,value:200,level:1},
    'Bone_Archlich_Staff':{boost:{atk:8},maxD:200,value:200,level:1},
    'Primordial_Wolf_Fang':{boost:{atk:6,maxHp:8},maxD:200,value:200,level:1},
    'Orc_Destroyer_Axe':{boost:{atk:10},maxD:200,value:200,level:1},
    'Ancient_Ogre_Club':{boost:{atk:7,maxHp:15},maxD:200,value:200,level:1},
    'Gnoll_Demigod_Spear':{boost:{atk:9,def:3},maxD:200,value:200,level:1},
    'Wyvern_God_Scale':{boost:{atk:12,def:5,maxHp:10},maxD:200,value:200,level:1},
    // Ultimate legendary weapon
    'Apex_Predator':{boost:{atk:525,def:715,maxHp:1025},maxD:100,value:1000,level:1},
    // New ultimate weapon
    'Broken_Stick':{boost:{atk:50000},maxD:5,value:0,level:1,unsellable:true},
    // Level 15 boss weapons - cannot be sold
    'Tidepiercer':{boost:{atk:500,def:200},maxD:100,value:0,level:1,unsellable:true},
    'Nova_Maul':{boost:{atk:300,maxHp:500,def:100},maxD:100,value:0,level:1,unsellable:true},
    'Stormfang_Katana':{boost:{atk:1000,def:500},maxD:100,value:0,level:1,unsellable:true},
    // New weapons with random durability
    'Shadowstrike_Blade':{boost:{atk:6,def:1},maxD:()=>roll(40,100),value:150,level:1},
    'Thundercaller_Hammer':{boost:{atk:8,maxHp:5},maxD:()=>roll(40,100),value:180,level:1},
    'Voidreaper_Scythe':{boost:{atk:10},maxD:()=>roll(40,100),value:200,level:1},
    'Dragonbane_Spear':{boost:{atk:5,def:4},maxD:()=>roll(40,100),value:160,level:1},
    'Soulrender_Axe':{boost:{atk:7,maxHp:3},maxD:()=>roll(40,100),value:170,level:1}
  };

  const recipes=[
    {name:'Health Potion',need:{Herb:1,Bottle:1}},
    {name:'Strength Potion',need:{Herb:2}},
    {name:'Scroll of Healing',need:{Paper:1,Herb:1}},
    {name:'Iron Ingot',need:{'Iron Ore':2,Coal:1}},
    {name:'Iron Sword',need:{'Iron Ingot':1,Wood:2}},
    {name:'Shadowstrike_Blade',need:{'Iron Ingot':2,'Skeleton_Bone':1,Wood:1}},
    {name:'Thundercaller_Hammer',need:{'Iron Ingot':3,Coal:2}},
    {name:'Voidreaper_Scythe',need:{'Iron Ingot':2,'Orc_Tusk':1,Wood:2}},
    {name:'Dragonbane_Spear',need:{'Iron Ingot':1,'Wolf_Pelt':1,Wood:3}},
    {name:'Soulrender_Axe',need:{'Iron Ingot':2,'Gnoll_Claw':1,Wood:1}},
    {name:'Apex_Predator',need:{'Ancient_Goblin_Crown':1,'Bone_Archlich_Staff':1,'Primordial_Wolf_Fang':1,'Orc_Destroyer_Axe':1,'Ancient_Ogre_Club':1,'Gnoll_Demigod_Spear':1,'Wyvern_God_Scale':1}},
    {name:'Broken_Stick',need:{'Apex_Predator':1,'Tidepiercer':1,'Nova_Maul':1,'Stormfang_Katana':1}}
  ];

  const npcProfs=['Hunter','Herbalist','Miner','Scout','Mercenary'];
  
  const fetchTpl={ 
    Hunter:{need:{Wolf_Pelt:3},reward:'Spear'}, 
    Herbalist:{need:{Herb:3},reward:'PlateArmor'}, 
    Miner:{need:{'Iron Ore':2},reward:'Greatsword'}, 
    Scout:{need:{Wood:3},reward:'Shield'},
    Mercenary:{need:{Goblin_Ear:2},reward:'Iron Sword'}
  };

  const townQuests={ 
    easy:[
      {name:'Help Herbalist',type:'fetch',desc:'Bring 2 Herbs',need:{Herb:2},reward:{gold:10}},
      {name:'Wolf Pelt',type:'fetch',desc:'Bring 1 Wolf Pelt',need:{Wolf_Pelt:1},reward:{gold:15}},
      {name:'Orc Tusks',type:'fetch',desc:'Bring 2 Orc Tusks',need:{Orc_Tusk:2},reward:{gold:20}},
      {name:'Gnoll Claws',type:'fetch',desc:'Bring 1 Gnoll Claw',need:{Gnoll_Claw:1},reward:{gold:18}}
    ], 
    med:[
      {name:'Slay Goblins',type:'kill',desc:'Defeat 3 Goblins',need:{Goblin:3},reward:{gold:15}},
      {name:'Skeleton Bones',type:'fetch',desc:'Bring 2 Skeleton Bones',need:{Skeleton_Bone:2},reward:{gold:20}},
      {name:'Orc Hunt',type:'kill',desc:'Defeat 2 Orcs',need:{Orc:2},reward:{gold:25}},
      {name:'Ogre Challenge',type:'kill',desc:'Defeat 1 Ogre',need:{Ogre:1},reward:{gold:30}}
    ], 
    hard:[
      {name:'Defeat Skeletons',type:'kill',desc:'Defeat 2 Skeleton Soldiers',need:{Skeleton_Soldier:2},reward:{gold:25}},
      {name:'Hob Goblin Challenge',type:'kill',desc:'Defeat 1 Hobgoblin',need:{Hobgoblin:1},reward:{gold:30}},
      {name:'Wyvern Hunt',type:'kill',desc:'Defeat 1 Wyvern',need:{Wyvern:1},reward:{gold:40}},
      {name:'Gnoll Pack',type:'kill',desc:'Defeat 3 Gnoll Hunters',need:{Gnoll_Hunter:3},reward:{gold:45}}
    ],
    elite:[
      {name:'Goblin King',type:'kill',desc:'Defeat the Goblin King',need:{Goblin_King:1},reward:{gold:50}},
      {name:'Skeleton Duke',type:'kill',desc:'Defeat a Skeleton Duke',need:{Skeleton_Duke:1},reward:{gold:60}},
      {name:'Orc Warlord',type:'kill',desc:'Defeat an Orc Warlord',need:{Orc_Warlord:1},reward:{gold:70}},
      {name:'Elder Wyvern',type:'kill',desc:'Defeat an Elder Wyvern',need:{Elder_Wyvern:1},reward:{gold:80}}
    ],
    legendary:[
      {name:'Ancient Goblin',type:'kill',desc:'Defeat the Ancient Goblin',need:{Ancient_Goblin:1},reward:{gold:500}},
      {name:'Bone Archlich',type:'kill',desc:'Defeat the Bone Archlich',need:{Bone_Archlich:1},reward:{gold:500}},
      {name:'Primordial Wolf',type:'kill',desc:'Defeat the Primordial Wolf',need:{Primordial_Wolf:1},reward:{gold:500}},
      {name:'Orc Destroyer',type:'kill',desc:'Defeat the Orc Destroyer',need:{Orc_Destroyer:1},reward:{gold:500}},
      {name:'Ancient Ogre',type:'kill',desc:'Defeat the Ancient Ogre',need:{Ancient_Ogre:1},reward:{gold:500}},
      {name:'Gnoll Demigod',type:'kill',desc:'Defeat the Gnoll Demigod',need:{Gnoll_Demigod:1},reward:{gold:500}},
      {name:'Wyvern God',type:'kill',desc:'Defeat the Wyvern God',need:{Wyvern_God:1},reward:{gold:500}},
      {name:'Leviathan Boss',type:'kill',desc:'Defeat the Level 15 Leviathan',need:{Leviathan:1},reward:{gold:10000}},
      {name:'DeathStar Boss',type:'kill',desc:'Defeat the Level 15 DeathStar',need:{DeathStar:1},reward:{gold:10000}},
      {name:'Susano Boss',type:'kill',desc:'Defeat the Level 15 Susano',need:{Susano:1},reward:{gold:10000}}
    ]
  };
  
  // State - changed to 512x512 map (32x32 areas of 16x16 tiles)
  const AREA=16,GRID_W=16,GRID_H=16,TOWN=16,SIZE=512,SAVE='dqSave';
  let p,world,quests=[];
  const d=s=>document.querySelector(s),dA=s=>document.querySelectorAll(s),
        SEl=d('#stats'),MEl=d('#map'),LEl=d('#log'),OV=d('#overlay'),MD=d('#modal'),
        QM=d('#quest-modal');
  
  function roll(a,b){return Math.floor(Math.random()*(b-a+1))+a;}
  
  function init(){
    const s=localStorage.getItem(SAVE);
    if(s) try{ 
      let o=JSON.parse(s); 
      p=o.player; 
      // Ensure all numeric values are properly typed and rounded
      p.atk = round1(p.atk);
      p.def = round1(p.def);
      p.luck = round1(p.luck);
      p.maxHp = round1(p.maxHp);
      p.hp = round1(p.hp);
      p.craft = round1(p.craft);
      // Fix gold to ensure it's always a number
      p.g = Number(p.g) || 0;
      // Initialize missing temporary effects
      p.tempDef = p.tempDef || null;
      p.tempCraft = p.tempCraft || null;
      // Track current area for refresh system
      p.currentArea = p.currentArea || {x: TOWN, y: TOWN};
      quests=o.quests||[];
    }catch{localStorage.removeItem(SAVE);return init();}
    else p={
      x:TOWN*AREA+8,
      y:TOWN*AREA+8,
      maxHp:20,
      hp:20,
      atk:round1(roll(1,7)),
      def:round1(roll(1,7)),
      luck:round1(roll(1,5)),
      g:0,
      inv:{},
      eq:[],
      craft:0,
      equipped:null,
      tempAtk:null,
      tempLuck:null,
      tempDef:null,
      tempCraft:null,
      steps:0,
      kills:{},
      preventFlee:0,
      currentArea: {x: TOWN, y: TOWN}
    };
    world=Array.from({length:32},(_,y)=>Array.from({length:32},(_,x)=>gen(x===TOWN&&y===TOWN, x, y)));
    save();
  }
  
  function save(){
    // Round all numeric values before saving
    const saveData = {
      player: {
        ...p,
        atk: round1(p.atk),
        def: round1(p.def),
        luck: round1(p.luck),
        maxHp: round1(p.maxHp),
        hp: round1(p.hp),
        craft: round1(p.craft),
        g: Number(p.g) || 0
      },
      quests: quests
    };
    localStorage.setItem(SAVE,JSON.stringify(saveData));
  }

  function generateRandomQuest(distFromTown) {
    // 60% kill quests, 40% gathering quests
    const isKillQuest = Math.random() < 0.6;
    
    // Calculate difficulty multiplier based on distance
    const difficultyMult = Math.max(1, Math.floor(distFromTown / 3));
    
    let quest;
    
    if (isKillQuest) {
      // Generate kill quest
      const monsterTypes = ['Goblin','Skeleton','Wolf','Orc','Ogre','Gnoll','Wyvern'];
      const monsterType = monsterTypes[roll(0, monsterTypes.length-1)];
      
      // Limit kill quests to levels 4-6 monsters only
      let questLevel = roll(3, 5); // Levels 4-6 (index 3-5)
      
      const monsterData = monsterTpl[monsterType];
      const levelData = monsterData.levels[questLevel];
      const targetMonster = levelData.name.replace(/\s+/g, '_');
      
      const questCount = Math.max(1, roll(1, 3) + Math.floor(difficultyMult / 2));
      
      quest = {
        type: 'kill',
        need: {[targetMonster]: questCount},
        progress: {[targetMonster]: 0},
        state: 0
      };
    } else {
      // Generate gathering quest
      const gatherItems = ['Herb', 'Wood', 'Iron_Ore', 'Coal', 'Stone', 'Wolf_Pelt', 'Skeleton_Bone', 'Orc_Tusk', 'Gnoll_Claw'];
      const targetItem = gatherItems[roll(0, gatherItems.length-1)];
      const gatherCount = Math.max(1, roll(1, 4) + Math.floor(difficultyMult / 2));
      
      quest = {
        type: 'gather',
        need: {[targetItem]: gatherCount},
        state: 0
      };
    }
    
    // Generate reward - 50% equipment, 50% gold (never both)
    const isEquipmentReward = Math.random() < 0.5;
    
    if (isEquipmentReward) {
      // Equipment reward based on distance/difficulty
      const equipmentPool = ['Spear', 'Shield', 'Greatsword', 'PlateArmor', 'Iron_Sword'];
      if (difficultyMult >= 3) {
        equipmentPool.push('Shadowstrike_Blade', 'Thundercaller_Hammer', 'Voidreaper_Scythe', 'Dragonbane_Spear', 'Soulrender_Axe');
      }
      if (difficultyMult >= 5) {
        equipmentPool.push('Ancient_Goblin_Crown', 'Bone_Archlich_Staff', 'Primordial_Wolf_Fang');
      }
      
      quest.reward = equipmentPool[roll(0, equipmentPool.length-1)];
    } else {
      // Gold reward scaled by distance
      const baseGold = isKillQuest ? 20 : 15;
      const scaledGold = Math.floor(baseGold * (1 + difficultyMult * 0.5));
      quest.rewardGold = scaledGold;
    }
    
    return quest;
  }

  // Function to update quest progress and auto-complete quests
  function updateQuestProgress(questType, itemKey) {
    if(!quests || quests.length === 0) return;
    
    // Create a copy to avoid issues with array modification during iteration
    const questsCopy = [...quests];
    
    questsCopy.forEach((quest, index) => {
      if(!quest || !quest.type || !quest.need || quest.state !== 1) return;
      
      // Update progress for kill quests
      if(quest.type === 'kill' && questType === 'kill' && quest.need[itemKey]) {
        if(!quest.progress) quest.progress = {};
        quest.progress[itemKey] = (quest.progress[itemKey] || 0) + 1;
        
        // Check if quest is complete
        let isComplete = true;
        for(let [monster, needed] of Object.entries(quest.need)) {
          if((quest.progress[monster] || 0) < needed) {
            isComplete = false;
            break;
          }
        }
        
        if(isComplete) {
          // Find the actual index in the current quests array
          const actualIndex = quests.findIndex(q => q === quest);
          if(actualIndex !== -1) {
            completeQuestFromList(quest, actualIndex);
          }
        }
      }
      
      // Check gather quest completion whenever inventory changes
      if(quest.type === 'gather' && questType === 'gather') {
        let isComplete = true;
        for(let [item, needed] of Object.entries(quest.need)) {
          if((p.inv[item] || 0) < needed) {
            isComplete = false;
            break;
          }
        }
        
        if(isComplete) {
          // Find the actual index in the current quests array
          const actualIndex = quests.findIndex(q => q === quest);
          if(actualIndex !== -1) {
            completeQuestFromList(quest, actualIndex);
          }
        }
      }
    });
  }

  // Function to complete a quest from the quest list and give rewards
  function completeQuestFromList(quest, questIndex) {
    if(!quest || !quest.type || questIndex < 0 || questIndex >= quests.length) return;
    
    // Remove consumed items for gather quests
    if(quest.type === 'gather' && quest.need) {
      for(let [item, needed] of Object.entries(quest.need)) {
        if(p.inv[item] >= needed) {
          p.inv[item] = (p.inv[item] || 0) - needed;
          if(p.inv[item] <= 0) delete p.inv[item];
        }
      }
    }
    
    // Give rewards - handle the correct reward structure
    if(quest.reward && quest.reward.gold) {
      p.g = Math.max(0, (p.g || 0) + quest.reward.gold);
      log(`Quest completed! Received ${quest.reward.gold} gold.`);
    }
    
    if(quest.reward && quest.reward.item) {
      // Add equipment to inventory or equip directly
      let itemDef = itemDefs[quest.reward.item];
      if(itemDef) {
        let durability = typeof itemDef.maxD === 'function' ? itemDef.maxD() : itemDef.maxD;
        p.eq.push({name: quest.reward.item, durability: durability});
        log(`Quest completed! Received ${quest.reward.item.replace(/_/g, ' ')}.`);
      } else {
        p.inv[quest.reward.item] = (p.inv[quest.reward.item] || 0) + 1;
        log(`Quest completed! Received ${quest.reward.item.replace(/_/g, ' ')}.`);
      }
    }
    
    // Remove quest from active list
    quests.splice(questIndex, 1);
    log(`Quest completed automatically!`);
    save();
  }
  
  function gen(isTown, areaX, areaY){
    let tiles=Array.from({length:AREA},()=>Array.from({length:AREA},()=>({type:'empty'})));
    if(isTown){
      ['Potion Seller','Blacksmith','Scroll Merchant','Equipment Combiner','Quest Giver EM','Quest Giver H','Quest Giver L']
        .forEach(pr=>place(tiles,pr,true,areaX,areaY));
    } else {
      for(let i=0;i<2;i++) place(tiles,npcProfs[roll(0,npcProfs.length-1)],false,areaX,areaY);
      for(let y=0;y<AREA;y++)for(let x=0;x<AREA;x++){
        if(tiles[y][x].type!=='empty')continue;
        let r=Math.random()*100;
        if(r<20) { // Reduced from 30 to 20 for less clutter
          // Monster spawn based on distance from town - fixed distance calculation
          const distFromTown = Math.sqrt(Math.pow(areaX-TOWN,2) + Math.pow(areaY-TOWN,2));
          
          // Check if we're at the edge of the map for level 15 boss spawning
          const isEdgeArea = (areaX <= 1 || areaX >= 30 || areaY <= 1 || areaY >= 30);
          
          let monsterTypes = ['Goblin','Skeleton','Wolf','Orc','Ogre','Gnoll','Wyvern'];
          let monsterType = monsterTypes[roll(0,monsterTypes.length-1)];
          
          // 20% chance to spawn level 15 bosses in outermost areas (edge of map)
          if(isEdgeArea && Math.random() < 0.2) {
            const bossTypes = ['Leviathan','DeathStar','Susano'];
            monsterType = bossTypes[roll(0,bossTypes.length-1)];
          }
          const monsterData = monsterTpl[monsterType];
          
          // Fixed level spawning - areas adjacent to town only spawn level 1-2
          let maxLevel = 0;
          
          // Special handling for level 15 bosses
          if(['Leviathan','DeathStar','Susano'].includes(monsterType)) {
            maxLevel = 14; // Level 15 (index 14)
          } else if(distFromTown <= 1.5) {
            // Adjacent areas: only level 1-2
            maxLevel = Math.random() < 0.7 ? 0 : 1;
          } else if(distFromTown <= 3) {
            // Nearby areas: level 1-4
            maxLevel = Math.min(3, Math.floor(distFromTown));
          } else if(distFromTown <= 6) {
            // Mid-distance: level 3-7
            maxLevel = Math.min(6, Math.floor(distFromTown) + 1);
          } else {
            // Far areas: level 6-10, with 10% higher chance for level 10 in outermost areas
            maxLevel = Math.min(9, Math.floor(distFromTown));
            // Boost level 10 spawns in outermost areas
            if(distFromTown >= 8 && Math.random() < 0.15) { // 15% instead of normal 5% for level 10
              maxLevel = 9; // Level 10 (index 9)
            }
          }
          
          let level = 0;
          for(let l=maxLevel;l>=0;l--){
            if(Math.random() < 1/Math.pow(1.5,l)){
              level = l;
              break;
            }
          }
          
          let levelData = monsterData.levels[level];
          if(!levelData) {
            // Fallback to level 0 if data is missing
            level = 0;
            levelData = monsterData.levels[0];
          }
          const monster = {
            ...structuredClone(monsterData.base),
            name: levelData.name,
            level: level+1,
            reward: levelData.reward,
            boost: monsterData.base.boost,
            type: monsterType
          };
          
          // Scale stats by level multiplier
          Object.keys(monsterData.base).forEach(stat => {
            if(stat !== 'boost') monster[stat] = Math.floor(monster[stat] * levelData.mult);
          });
          
          tiles[y][x]={type:'monster',data:monster};
        }
        else if(r<40) { // Reduced from 55 to 40 for less clutter
          const resources = ['Herb','Bottle','Wood','Iron Ore','Coal','Paper','Wolf_Pelt','Goblin_Ear','Skeleton_Bone','Orc_Tusk','Ogre_Hide','Gnoll_Claw','Wyvern_Scale'];
          tiles[y][x]={type:'resource',data:resources[roll(0,resources.length-1)]};
        }
        else if(r<50) tiles[y][x]={type:'trap'}; // Reduced from 65 to 50
        else if(r<55) tiles[y][x]={type:'chest'}; // Reduced from 70 to 55
      }
    }
    return {tiles};
  }
  
  function place(tiles,prof,town,areaX,areaY){
    for(let i=0;i<100;i++){
      let x=roll(0,AREA-1),y=roll(0,AREA-1);
      if(tiles[y][x].type==='empty'){
        let npc={type:'npc',data:{profession:prof}};
        if(town) {
          npc.data.abbr = prof === 'Quest Giver L' ? 'L' : prof[0]; // Special handler for Quest Giver L
          npc.data.isTown = true;
        } else {
          npc.data.abbr = 'N'; // Random NPCs show as 'N'
        }
        if(!town&&fetchTpl[prof]) {
          npc.data.quest={...fetchTpl[prof],state:0};
        } else if(!town) {
          // Create distance-based random quests for NPCs without fetch templates
          const distFromTown = Math.sqrt(Math.pow(areaX-TOWN,2) + Math.pow(areaY-TOWN,2));
          npc.data.quest = generateRandomQuest(distFromTown);
        }
        tiles[y][x]=npc;
        return;
      }
    }
  }
  
  function getT(x,y){
    let ax=Math.floor(x/AREA),ay=Math.floor(y/AREA),lx=x%AREA,ly=y%AREA;
    return world[ay][ax].tiles[ly][lx];
  }
  
  function setT(x,y,t){
    let ax=Math.floor(x/AREA),ay=Math.floor(y/AREA),lx=x%AREA,ly=y%AREA;
    world[ay][ax].tiles[ly][lx]=t;
  }
  
  function log(m){LEl.innerHTML+=m+'<br>';LEl.scrollTop=LEl.scrollHeight;save();}
  
  function updateUI(){
    // Handle temporary buffs
    if(p.tempAtk){
      p.tempAtk.steps--;
      if(p.tempAtk.steps <= 0){
        p.tempAtk = null;
        log("Strength potion wore off!");
      }
    }
    
    if(p.tempLuck){
      p.tempLuck.steps--;
      if(p.tempLuck.steps <= 0){
        p.tempLuck = null;
        log("Luck charm wore off!");
      }
    }
    
    if(p.tempDef){
      p.tempDef.steps--;
      if(p.tempDef.steps <= 0){
        p.tempDef = null;
        log("Defense potion wore off!");
      }
    }
    
    // Handle new potion effects
    if(p.tempOrcsRage){
      p.tempOrcsRage.steps--;
      if(p.tempOrcsRage.steps <= 0){
        p.tempOrcsRage = null;
        log("Orc's Rage wore off!");
      }
    }
    
    if(p.tempAngelsTouch){
      p.tempAngelsTouch.steps--;
      if(p.tempAngelsTouch.steps <= 0){
        p.maxHp = round1(p.maxHp - 200);
        p.hp = Math.min(p.hp, p.maxHp);
        p.tempAngelsTouch = null;
        log("Angel's Touch wore off! Lost temporary max HP.");
      }
    }
    
    if(p.tempDragonFury){
      p.tempDragonFury.steps--;
      if(p.tempDragonFury.steps <= 0){
        p.maxHp = round1(p.maxHp / 0.5); // Restore max HP
        p.tempDragonFury = null;
        log("Dragon Fury wore off! Max HP restored.");
      }
    }
    
    if(p.tempGodsGift){
      p.tempGodsGift.steps--;
      if(p.tempGodsGift.steps <= 0){
        p.tempGodsGift = null;
        log("God's Gift wore off!");
      }
    }
    
    p.steps++;
    
    // Calculate current stats with all temporary effects
    let currentAtk = round1(p.atk + (p.tempAtk ? p.tempAtk.value : 0));
    let currentDef = round1(p.def + (p.tempDef ? p.tempDef.value : 0));
    let currentLuck = round1(p.luck + (p.tempLuck ? p.tempLuck.value : 0));
    let currentCraft = round1(p.craft + (p.tempCraft ? p.tempCraft.value : 0));
    
    // Apply new potion effects
    if(p.tempOrcsRage) {
      currentAtk = round1(currentAtk + p.tempOrcsRage.atkBoost);
      currentDef = round1(currentDef * p.tempOrcsRage.defDebuff);
    }
    
    if(p.tempAngelsTouch) {
      currentDef = round1(currentDef + p.tempAngelsTouch.defBoost);
      currentAtk = round1(currentAtk * p.tempAngelsTouch.atkDebuff);
    }
    
    if(p.tempDragonFury) {
      currentAtk = round1(currentAtk + p.tempDragonFury.atkBoost);
      currentDef = round1(currentDef * p.tempDragonFury.defDebuff);
    }
    
    if(p.tempGodsGift) {
      currentDef = round1(currentDef + p.tempGodsGift.defBoost);
    }
    
    // Update stats display
    let statsHTML = `
      <div class="stat-bar"><span class="stat-name">HP:</span> ${round1(p.hp)}/${round1(p.maxHp)}</div>
      <div class="stat-bar"><span class="stat-name">ATK:</span> ${currentAtk}(${round1(p.atk)})</div>
      <div class="stat-bar"><span class="stat-name">DEF:</span> ${currentDef}(${round1(p.def)})</div>
      <div class="stat-bar"><span class="stat-name">LUCK:</span> ${currentLuck}(${round1(p.luck)})</div>
      <div class="stat-bar"><span class="stat-name">GOLD:</span> ${p.g}</div>
      <div class="stat-bar"><span class="stat-name">CRAFT:</span> ${currentCraft}(${round1(p.craft)})</div>
    `;
    
    if(p.equipped) {
      statsHTML += `<div class="stat-bar"><span class="stat-name">EQUIP:</span> ${p.equipped.name}(${p.equipped.durability})</div>`;
    }
    
    SEl.innerHTML = statsHTML;
    
    let gx=p.x,gy=p.y,ax=Math.floor(gx/AREA),ay=Math.floor(gy/AREA),lx=gx%AREA,ly=gy%AREA,
        sx=Math.max(0,Math.min(AREA-GRID_W,lx-Math.floor(GRID_W/2))),
        sy=Math.max(0,Math.min(AREA-GRID_H,ly-Math.floor(GRID_H/2))),
        o='';
    
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        let tx=sx+x,ty=sy+y,ch='.';
        if(tx===lx&&ty===ly) ch='P';
        else {
          let c=getT(tx+ax*AREA,ty+ay*AREA);
          if(c.type==='monster') {
            const levelClass = `monster-lvl${Math.min(10, c.data.level)}`;
            ch=`<span class="${levelClass}">M</span>`;
          }
          else if(c.type==='resource') ch=`<span class="resource">R</span>`;
          else if(c.type==='trap') ch='T';
          else if(c.type==='chest') ch='<span class="chest">C</span>';
          else if(c.type==='npc') {
            if(c.data.isTown) {
              ch=`<span class="town-npc">${c.data.abbr}</span>`;
            } else {
              ch=`<span class="town-npc">N</span>`;
            }
          }
        }
        o+=ch+' ';
      }
      o+='\n';
    }
    MEl.innerHTML=o;
  }
  
  function move(dir){
    // Prevent movement if player is dead
    if(p.hp <= 0) {
      log("You are dead! Use Reborn to start over.");
      return;
    }
    
    let nx=p.x,ny=p.y;
    if(dir==='up') ny--;
    else if(dir==='down') ny++;
    else if(dir==='left') nx--;
    else if(dir==='right') nx++;
    
    if(nx<0||nx>=SIZE||ny<0||ny>=SIZE) return;
    
    let t=getT(nx,ny);
    if(t.type==='monster') {
      if(p.preventFlee>0) {
        log("Cannot flee!");
        return;
      }
      fight(t.data,nx,ny);
    }
    else if(t.type==='resource') {
      p.inv[t.data]=(p.inv[t.data]||0)+1;
      log("Found "+t.data);
      setT(nx,ny,{type:'empty'});
      p.x=nx; p.y=ny;
      
      // Check quest progress for gather quests
      updateQuestProgress('gather', t.data);
      
      checkAreaChange();
      updateUI();
    }
    else if(t.type==='trap') {
      let dmg=roll(1,5);
      p.hp=Math.max(0,round1(p.hp-dmg));
      log("Trap! -"+dmg+" HP");
      setT(nx,ny,{type:'empty'});
      p.x=nx; p.y=ny;
      checkAreaChange();
      updateUI();
    }
    else if(t.type==='chest') {
      let g=roll(5,15);
      p.g = Math.max(0, (p.g || 0) + g);
      log("Chest! +"+g+" gold");
      setT(nx,ny,{type:'empty'});
      p.x=nx; p.y=ny;
      checkAreaChange();
      updateUI();
    }
    else if(t.type==='npc') {
      interact(t.data);
    }
    else {
      p.x=nx; p.y=ny;
      
      checkAreaChange();
      updateUI();
    }
  }
  
  function checkAreaChange() {
    // Check if player moved to a different area
    let newAreaX = Math.floor(p.x / AREA);
    let newAreaY = Math.floor(p.y / AREA);
    
    if(newAreaX !== p.currentArea.x || newAreaY !== p.currentArea.y) {
      // Player moved to a new area - refresh the old area
      world[p.currentArea.y][p.currentArea.x] = gen(p.currentArea.x === TOWN && p.currentArea.y === TOWN, p.currentArea.x, p.currentArea.y);
      p.currentArea = {x: newAreaX, y: newAreaY};
    }
  }
  
  function fight(m,x,y){
    // Calculate player stats with all effects and equipment
    let playerAtk = round1(p.atk + (p.tempAtk ? p.tempAtk.value : 0));
    let playerDef = round1(p.def + (p.tempDef ? p.tempDef.value : 0));
    let playerLuck = round1(p.luck + (p.tempLuck ? p.tempLuck.value : 0));
    
    // Apply new potion effects to combat stats
    if(p.tempOrcsRage) {
      playerAtk = round1(playerAtk + p.tempOrcsRage.atkBoost);
      playerDef = round1(playerDef * p.tempOrcsRage.defDebuff);
    }
    
    if(p.tempAngelsTouch) {
      playerDef = round1(playerDef + p.tempAngelsTouch.defBoost);
      playerAtk = round1(playerAtk * p.tempAngelsTouch.atkDebuff);
    }
    
    if(p.tempDragonFury) {
      playerAtk = round1(playerAtk + p.tempDragonFury.atkBoost);
      playerDef = round1(playerDef * p.tempDragonFury.defDebuff);
    }
    
    if(p.tempGodsGift) {
      playerDef = round1(playerDef + p.tempGodsGift.defBoost);
    }
    
    // Calculate attack with equipment (including custom boost from combined items)
    let equipAtk = 0, equipDef = 0, equipHp = 0;
    if(p.equipped) {
      let boostToUse = p.equipped.boost || (itemDefs[p.equipped.name] && itemDefs[p.equipped.name].boost);
      if(boostToUse) {
        equipAtk = boostToUse.atk || 0;
        equipDef = boostToUse.def || 0;
        equipHp = boostToUse.maxHp || 0;
      }
    }
    
    let totalPlayerAtk = playerAtk + equipAtk;
    let totalPlayerDef = playerDef + equipDef;
    
    log("Fighting "+m.name+" (HP:"+m.hp+", ATK:"+m.atk+", DEF:"+m.def+")");
    
    while(m.hp > 0 && p.hp > 0) {
      // Player attacks monster
      let playerDmg = roll(1, totalPlayerAtk); // Random damage from 1 to attack stat
      let defenseReduction = Math.floor(m.def / 2); // Defense reduces damage by 1 per 2 defense
      playerDmg = Math.max(1, playerDmg - defenseReduction);
      
      // Apply luck to damage
      if(Math.random() < playerLuck/100) {
        playerDmg = Math.floor(playerDmg * 1.5);
        log("Lucky hit!");
      }
      
      m.hp = Math.max(0, m.hp - playerDmg);
      log("You deal "+playerDmg+" damage to "+m.name);
      
      if(m.hp <= 0) break;
      
      // Monster attacks player
      let monsterDmg = roll(1, m.atk); // Random damage from 1 to attack stat
      let playerDefenseReduction = Math.floor(totalPlayerDef / 2); // Defense reduces damage by 1 per 2 defense
      monsterDmg = Math.max(1, monsterDmg - playerDefenseReduction);
      
      p.hp = Math.max(0, round1(p.hp - monsterDmg));
      log(m.name+" deals "+monsterDmg+" damage to you");
      
      // Reduce equipment durability
      if(p.equipped) {
        p.equipped.durability--;
        if(p.equipped.durability <= 0) {
          log(p.equipped.name+" broke!");
          unequipItem();
        }
      }
    }
    
    if(p.hp <= 0) {
      p.hp = 0;
      log("You died!");
      updateUI();
      return;
    }
    
    log("You defeated "+m.name+"!");
    log("Remaining HP: " + round1(p.hp) + "/" + round1(p.maxHp));
    
    // Level-based monster defeat rewards with tier-based doubling
    let hpGain = m.level; // +1 HP per monster level
    
    // Calculate stat gain based on tier system
    let atkDefGain;
    if(m.level <= 3) {
      // Level 1-3: 0.1, 0.2, 0.3
      atkDefGain = round1(m.level * 0.1);
    } else if(m.level <= 6) {
      // Level 4-6: 0.6, 0.7, 0.8 (base 0.6 + extra levels)
      atkDefGain = round1(0.6 + (m.level - 4) * 0.1);
    } else if(m.level <= 9) {
      // Level 7-9: 1.6, 1.7, 1.8 (base 1.6 + extra levels)
      atkDefGain = round1(1.6 + (m.level - 7) * 0.1);
    } else if(m.level == 10) {
      // Level 10: 3.6
      atkDefGain = 3.6;
    } else {
      // Levels above 10 follow the pattern (for future expansion)
      atkDefGain = round1(m.level * 0.1);
    }
    
    // Special rewards for level 15 bosses
    if(m.level === 15) {
      if(m.type === 'Leviathan') {
        p.atk = round1(p.atk + 10);
        p.luck = round1(p.luck + 0.2);
        log("Leviathan defeated! +10 ATK, +0.2 LUCK");
      } else if(m.type === 'DeathStar') {
        p.def = round1(p.def + 10);
        p.luck = round1(p.luck + 0.3);
        log("Death Star defeated! +10 DEF, +0.3 LUCK");
      } else if(m.type === 'Susano') {
        p.maxHp = round1(p.maxHp + 10);
        p.hp = round1(p.hp + 10);
        p.luck = round1(p.luck + 0.5);
        log("Susano defeated! +10 MAX HP, +0.5 LUCK");
      }
    } else {
      // Apply stat gains based on monster's boost specialty
      const monsterData = monsterTpl[m.type];
      const boostType = monsterData && monsterData.base ? monsterData.base.boost : null;
      
      if(boostType === 'atk') {
        // ATK specialty monsters give ATK bonus
        p.atk = round1(p.atk + atkDefGain);
        log("ATK +" + atkDefGain);
      } else if(boostType === 'def') {
        // DEF specialty monsters give DEF bonus
        p.def = round1(p.def + atkDefGain);
        log("DEF +" + atkDefGain);
      } else if(boostType === 'maxHp') {
        // HP specialty monsters give HP bonus
        p.maxHp = round1(p.maxHp + hpGain);
        p.hp = round1(p.hp + hpGain);
        log("MAX HP +" + hpGain + ", HP +" + hpGain);
      } else {
        // Fallback for monsters without defined boost type
        p.maxHp = round1(p.maxHp + hpGain);
        p.hp = round1(p.hp + hpGain);
        log("HP +" + hpGain);
      }
    }
    
    // Gold reward scales with monster level multiplier
    let baseGoldReward = roll(1, 5);
    let goldMultiplier = Math.pow(2, m.level - 1); // 2^(level-1) for exponential scaling
    let goldReward = Math.floor(baseGoldReward * goldMultiplier);
    p.g = Math.max(0, (p.g || 0) + goldReward);
    log("+" + goldReward + " gold");
    
    // Track kills for quests
    let monsterKey = m.name.replace(/\s+/g, '_');
    p.kills[monsterKey] = (p.kills[monsterKey] || 0) + 1;
    
    // Update quest progress for kill quests
    updateQuestProgress('kill', monsterKey);
    
    // Boss monsters (level 10) drop special items 50% of the time
    if(m.level === 10 && Math.random() < 0.5) {
      let specialItems = {
        'Ancient_Goblin': 'Ancient_Goblin_Crown',
        'Bone_Archlich': 'Bone_Archlich_Staff',
        'Primordial_Wolf': 'Primordial_Wolf_Fang',
        'Orc_Destroyer': 'Orc_Destroyer_Axe',
        'Ancient_Ogre': 'Ancient_Ogre_Club',
        'Gnoll_Demigod': 'Gnoll_Demigod_Spear',
        'Wyvern_God': 'Wyvern_God_Scale'
      };
      
      let itemKey = specialItems[monsterKey];
      if(itemKey) {
        let itemDef = itemDefs[itemKey];
        let durability = roll(1, itemDef.maxD);
        p.eq.push({name: itemKey, durability: durability, level: itemDef.level || 1});
        log("Found rare item: " + itemKey.replace(/_/g, ' ') + " (" + durability + " durability)");
      }
    }
    
    // Level 15 boss monsters drop legendary weapons 90% of the time
    if(m.level === 15 && Math.random() < 0.9) {
      let legendaryWeapons = {
        'Leviathan': 'Tidepiercer',
        'DeathStar': 'Nova_Maul',
        'Susano': 'Stormfang_Katana'
      };
      
      let weaponKey = legendaryWeapons[monsterKey];
      if(weaponKey) {
        let itemDef = itemDefs[weaponKey];
        let durability = itemDef.maxD;
        p.eq.push({name: weaponKey, durability: durability, level: itemDef.level || 1});
        log("Found legendary weapon: " + weaponKey.replace(/_/g, ' ') + " (" + durability + " durability)");
      }
    }
    
    // Random resource drop
    if(Math.random() < 0.3) {
      let resourceMap = {
        'Goblin': 'Goblin_Ear',
        'Skeleton': 'Skeleton_Bone',
        'Wolf': 'Wolf_Pelt',
        'Orc': 'Orc_Tusk',
        'Ogre': 'Ogre_Hide',
        'Gnoll': 'Gnoll_Claw',
        'Wyvern': 'Wyvern_Scale'
      };
      
      let resource = resourceMap[m.type] || 'Herb';
      p.inv[resource] = (p.inv[resource] || 0) + 1;
      log("Found " + resource.replace(/_/g, ' '));
    }
    
    // Update quest progress
    quests.forEach(q => {
      if(q.state === 1 && q.type === 'kill' && q.need[monsterKey]) {
        q.progress[monsterKey] = (q.progress[monsterKey] || 0) + 1;
        if(q.progress[monsterKey] >= q.need[monsterKey]) {
          log("Quest progress: " + q.name);
        }
      }
    });
    
    setT(x,y,{type:'empty'});
    p.x=x; p.y=y;
    checkAreaChange();
    updateUI();
  }
  
  function interact(n){
    if(n.profession==='Potion Seller'||n.profession==='Blacksmith'||n.profession==='Scroll Merchant'){
      openShop(n.profession);
    }
    else if(n.profession==='Equipment Combiner'){
      openCombiner();
    }
    else if(n.profession==='Quest Giver EM'||n.profession==='Quest Giver H'||n.profession==='Quest Giver L'){
      if(n.profession==='Quest Giver EM') openQuestGiver('easy','med');
      else if(n.profession==='Quest Giver H') openQuestGiver('hard','elite');
      else if(n.profession==='Quest Giver L') openQuestGiver('legendary');
    }
    else if(n.quest){
      if(n.quest.state===0) {
        showQuestPopup(n);
      }
      else if(n.quest.state===1){
        let canComplete = true;
        
        // Debug logging
        log(`DEBUG: Attempting to complete quest. Type: ${n.quest.type}`);
        log(`DEBUG: Quest needs: ${JSON.stringify(n.quest.need)}`);
        
        // Enhanced validation for quest completion
        if(n.quest.type === 'kill') {
          // Kill quest validation - check each monster requirement
          log(`DEBUG: Player kills: ${JSON.stringify(p.kills)}`);
          Object.entries(n.quest.need).forEach(([monster, needed]) => {
            let killed = p.kills[monster] || 0;
            log(`DEBUG: Need ${needed} ${monster}, have ${killed}`);
            if(killed < needed) {
              canComplete = false;
              log(`DEBUG: Cannot complete - insufficient kills for ${monster}`);
            }
          });
        } else {
          // Fetch quest validation - check each item requirement
          log(`DEBUG: Player inventory: ${JSON.stringify(p.inv)}`);
          Object.entries(n.quest.need).forEach(([item, needed]) => {
            let have = p.inv[item] || 0;
            log(`DEBUG: Need ${needed} ${item}, have ${have}`);
            if(have < needed) {
              canComplete = false;
              log(`DEBUG: Cannot complete - insufficient items for ${item}`);
            }
          });
        }
        
        // Double-check validation to prevent any bypasses
        if(canComplete) {
          // Re-validate one more time before completion
          if(n.quest.type === 'kill') {
            for(let [monster, needed] of Object.entries(n.quest.need)) {
              if((p.kills[monster] || 0) < needed) {
                log("Quest validation failed: insufficient kills for " + monster);
                canComplete = false;
                break;
              }
            }
          } else {
            for(let [item, needed] of Object.entries(n.quest.need)) {
              if((p.inv[item] || 0) < needed) {
                log("Quest validation failed: insufficient items for " + item);
                canComplete = false;
                break;
              }
            }
          }
        }
        
        if(canComplete){
          // Remove items for fetch quests only after final validation
          if(n.quest.type !== 'kill') {
            let validationFailed = false;
            for(let [item, needed] of Object.entries(n.quest.need)) {
              if((p.inv[item] || 0) >= needed) {
                p.inv[item] = (p.inv[item] || 0) - needed;
              } else {
                log("ERROR: Tried to remove " + item + " but player doesn't have enough!");
                validationFailed = true;
                break;
              }
            }
            
            if(validationFailed) {
              log("Quest completion aborted due to validation failure!");
              return; // Exit the entire function without completing quest
            }
          }
          
          // Give rewards - either gold OR item, not both
          if(n.quest.rewardGold) {
            const goldReward = Number(n.quest.rewardGold) || 0;
            p.g = Math.max(0, (p.g || 0) + goldReward);
            log("Quest complete! +" + goldReward + "g");
          }
          if(n.quest.reward) {
            equip(n.quest.reward);
            log("Quest complete! Received " + n.quest.reward);
          }
          
          n.quest.state=2;
        } else {
          if(n.quest.type === 'kill') {
            log("Cannot complete quest! Need to kill: " + Object.entries(n.quest.need).map(([monster, needed]) => 
              `${monster.replace(/_/g, ' ')} (${p.kills[monster] || 0}/${needed})`
            ).join(', '));
          } else {
            log("Cannot complete quest! Need: " + Object.entries(n.quest.need).map(([item, needed]) => 
              `${item.replace(/_/g, ' ')} (${p.inv[item] || 0}/${needed})`
            ).join(', '));
          }
        }
      }
      else log("Quest already complete");
    }
  }
  
  function openShop(prof){
    let arr=shops[prof];
    let shopIcons = {'Potion Seller': '🧪', 'Blacksmith': '⚒️', 'Scroll Merchant': '📜'};
    let shopColors = {'Potion Seller': '#4CAF50', 'Blacksmith': '#FF5722', 'Scroll Merchant': '#9C27B0'};
    
    let html=`<h2 style="color:${shopColors[prof]}; text-align:center; margin-bottom:15px;">${shopIcons[prof]} ${prof}</h2>`;
    html += `<div style="text-align:center; margin-bottom:20px; padding:8px; background:#333; border-radius:6px; color:#FFD700;">`;
    html += `<strong>Your Gold: ${p.g}</strong>`;
    html += `</div>`;
    
    html += '<div style="display:grid; gap:8px;">';
    arr.forEach(it=>{
      let canAfford = (p.g || 0) >= it.price;
      let btnStyle = `padding:12px; border-radius:6px; border:1px solid ${canAfford ? '#4CAF50' : '#f44336'}; background:${canAfford ? '#2E7D32' : '#333'}; color:${canAfford ? 'white' : '#999'}; cursor:${canAfford ? 'pointer' : 'not-allowed'}; display:flex; justify-content:space-between; align-items:center;`;
      
      html += `<button data-buy="${it.name}" style="${btnStyle}">`;
      html += `<div style="font-weight:bold;">${it.name.replace(/_/g, ' ')}</div>`;
      html += `<div style="color:#FFD700; font-weight:bold;">${it.price}g</div>`;
      html += `</button>`;
    });
    html += '</div>';
    
    openModal(html, btn => {
      if(btn.dataset.buy){
        let it=arr.find(x=>x.name===btn.dataset.buy);
        showPurchaseConfirmation(it, prof);
      }
      updateUI();
    });
  }
  
  function openQuestGiver(tier1, tier2) {
    let availableQuests = [];
    let questMap = [];
    
    // Add tier1 quests
    (townQuests[tier1] || []).forEach((quest, index) => {
      availableQuests.push(quest);
      questMap.push({tier: tier1, index: index});
    });
    
    // Add tier2 quests if provided
    if(tier2) {
      (townQuests[tier2] || []).forEach((quest, index) => {
        availableQuests.push(quest);
        questMap.push({tier: tier2, index: index});
      });
    }
    
    let tierColors = {'easy': '#4CAF50', 'med': '#FF9800', 'hard': '#f44336', 'elite': '#9C27B0', 'legendary': '#FFD700'};
    let tierNames = {'easy': 'Easy', 'med': 'Medium', 'hard': 'Hard', 'elite': 'Elite', 'legendary': 'Legendary'};
    
    let html = `<h2 style="color:#FFD700; text-align:center; margin-bottom:15px;">🎯 Quest Giver</h2>`;
    html += `<div style="text-align:center; margin-bottom:20px; padding:8px; background:#333; border-radius:6px; color:#ddd;">`;
    html += `Available Quests: ${tier2 ? `${tierNames[tier1]} & ${tierNames[tier2]}` : tierNames[tier1]} Tier`;
    html += `</div>`;
    
    html += '<div style="display:grid; gap:8px;">';
    availableQuests.forEach((quest, index) => {
      let tier = questMap[index].tier;
      let existing = quests.find(q => q.name === quest.name);
      let isAccepted = !!existing;
      
      let btnStyle = `padding:12px; border-radius:6px; border:1px solid ${isAccepted ? '#666' : tierColors[tier]}; background:${isAccepted ? '#333' : tierColors[tier]}; color:${isAccepted ? '#999' : 'white'}; cursor:${isAccepted ? 'not-allowed' : 'pointer'}; display:flex; justify-content:space-between; align-items:center;`;
      
      html += `<button data-q="${index}" style="${btnStyle}">`;
      html += `<div>`;
      html += `<div style="font-weight:bold; margin-bottom:4px;">${quest.name}${isAccepted ? ' [ACCEPTED]' : ''}</div>`;
      html += `<div style="font-size:12px; opacity:0.8;">${quest.desc}</div>`;
      html += `</div>`;
      html += `<div style="text-align:right;">`;
      html += `<div style="color:#FFD700; font-weight:bold;">${quest.reward.gold}g</div>`;
      html += `<div style="font-size:10px; opacity:0.6;">${tierNames[tier]}</div>`;
      html += `</div>`;
      html += `</button>`;
    });
    html += '</div>';
    
    openModal(html, btn => {
      if(btn.dataset.q) {
        let questIndex = parseInt(btn.dataset.q);
        if(questIndex >= 0 && questIndex < availableQuests.length) {
          let quest = availableQuests[questIndex];
          
          // Check if quest already accepted
          let existing = quests.find(q => q.name === quest.name);
          if(existing) {
            log("Quest already accepted");
            return;
          }
          
          // Show quest popup instead of directly accepting
          showTownQuestPopup(quest);
        }
      }
      updateUI();
    });
  }
  
  function openQuests() {
    let html = '<h2 style="color:#FFD700; text-align:center; margin-bottom:15px;">📋 Active Quests</h2>';
    if(quests.length === 0) {
      html += '<div style="text-align:center; color:#888; padding:20px;">No active quests</div>';
    } else {
      html += '<div style="display:grid; gap:12px;">';
      quests.forEach((quest, index) => {
        // Check if quest can be completed
        let canComplete = true;
        if(quest.type === 'kill') {
          Object.entries(quest.need).forEach(([monster, needed]) => {
            if((p.kills[monster] || 0) < needed) canComplete = false;
          });
        } else if(quest.type === 'fetch') {
          Object.entries(quest.need).forEach(([item, needed]) => {
            if((p.inv[item] || 0) < needed) canComplete = false;
          });
        }
        
        let questStyle = `padding:12px; background:${canComplete ? '#1B5E20' : '#333'}; border-radius:8px; border:1px solid ${canComplete ? '#4CAF50' : '#555'};`;
        html += `<div style="${questStyle}">`;
        html += `<div style="color:#FFD700; font-weight:bold; margin-bottom:8px;">${quest.name}</div>`;
        html += `<div style="color:#ddd; margin-bottom:8px; font-size:14px;">${quest.desc}</div>`;
        
        html += '<div style="margin-bottom:8px;">';
        if(quest.type === 'kill') {
          Object.entries(quest.need).forEach(([monster, needed]) => {
            let killed = p.kills[monster] || 0;
            let color = killed >= needed ? '#4CAF50' : '#FF9800';
            html += `<div style="color:${color}; font-size:13px;">• ${monster.replace(/_/g, ' ')}: ${killed}/${needed}</div>`;
          });
        } else if(quest.type === 'fetch') {
          Object.entries(quest.need).forEach(([item, needed]) => {
            let have = p.inv[item] || 0;
            let color = have >= needed ? '#4CAF50' : '#FF9800';
            html += `<div style="color:${color}; font-size:13px;">• ${item.replace(/_/g, ' ')}: ${have}/${needed}</div>`;
          });
        }
        html += '</div>';
        
        if(canComplete) {
          html += `<button data-turn="${index}" style="background:#4CAF50; color:white; border:none; padding:6px 12px; border-radius:4px; cursor:pointer;">Turn In Quest</button>`;
        } else {
          html += `<div style="color:#888; font-size:12px; font-style:italic;">Requirements not met</div>`;
        }
        html += '</div>';
      });
      html += '</div>';
    }
    
    openModal(html, btn => {
      if(btn.dataset.turn) {
        let index = parseInt(btn.dataset.turn);
        let quest = quests[index];
        
        // Validate quest completion before completing
        let canComplete = true;
        if(quest.type === 'kill') {
          Object.entries(quest.need).forEach(([monster, needed]) => {
            if((p.kills[monster] || 0) < needed) canComplete = false;
          });
        } else if(quest.type === 'fetch') {
          Object.entries(quest.need).forEach(([item, needed]) => {
            if((p.inv[item] || 0) < needed) canComplete = false;
          });
        }
        
        if(!canComplete) {
          log("Quest requirements not met!");
          return;
        }
        
        // Complete quest
        if(quest.type === 'fetch') {
          Object.entries(quest.need).forEach(([item, needed]) => {
            p.inv[item] = (p.inv[item] || 0) - needed;
          });
        }
        
        const goldReward = Number(quest.reward.gold) || 0;
        p.g = Math.max(0, (p.g || 0) + goldReward);
        log("Quest completed: " + quest.name + " (+" + goldReward + " gold)");
        quests.splice(index, 1);
      }
      updateUI();
    });
  }
  
  function openGlobal(){
    let html='<h2 style="color:#2196F3; text-align:center; margin-bottom:15px;">🏪 Global Market</h2>';
    html += `<div style="text-align:center; margin-bottom:20px; padding:8px; background:#333; border-radius:6px; color:#FFD700;">`;
    html += `<strong>Your Gold: ${p.g}</strong>`;
    html += `</div>`;
    
    html+='<h3 style="color:#4CAF50; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:15px;">💰 Buy Items (2x Town Price)</h3>';
    html += '<div style="display:grid; gap:8px; margin-bottom:25px;">';
    Object.entries(shops).forEach(([shopName, items]) => {
      let shopColors = {'Potion Seller': '#4CAF50', 'Blacksmith': '#FF5722', 'Scroll Merchant': '#9C27B0'};
      html+=`<div style="margin-bottom:10px;"><h4 style="color:${shopColors[shopName]}; margin-bottom:8px;">${shopName}</h4>`;
      items.forEach(item => {
        let canAfford = (p.g || 0) >= (item.price * 2);
        let btnStyle = `padding:10px; border-radius:6px; border:1px solid ${canAfford ? '#4CAF50' : '#f44336'}; background:${canAfford ? '#2E7D32' : '#333'}; color:${canAfford ? 'white' : '#999'}; cursor:${canAfford ? 'pointer' : 'not-allowed'}; display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;`;
        
        html+=`<button data-buyg="${item.name}" style="${btnStyle}">`;
        html+=`<span>${item.name.replace(/_/g, ' ')}</span>`;
        html+=`<span style="color:#FFD700; font-weight:bold;">${item.price * 2}g</span>`;
        html+=`</button>`;
      });
      html+=`</div>`;
    });
    html += '</div>';
    
    if(Object.keys(p.inv).some(k => p.inv[k] > 0)) {
      html+='<h3 style="color:#FF9800; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:15px;">📦 Sell Items</h3>';
      html += '<div style="display:grid; gap:6px; margin-bottom:25px;">';
      Object.entries(p.inv).forEach(([k,v])=>{
        if(v>0) {
          let btnStyle = `padding:8px; border-radius:6px; border:1px solid #FF9800; background:#E65100; color:white; cursor:pointer; display:flex; justify-content:space-between; align-items:center;`;
          html+=`<button data-sell="${k}" style="${btnStyle}">`;
          html+=`<span>${k.replace(/_/g, ' ')} x${v}</span>`;
          html+=`<span style="color:#FFD700; font-weight:bold;">1g each</span>`;
          html+=`</button>`;
        }
      });
      html += '</div>';
    }
    
    if(p.eq.length > 0) {
      html+='<h3 style="color:#f44336; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:15px;">⚔️ Sell Equipment</h3>';
      html += '<div style="display:grid; gap:6px;">';
      p.eq.forEach((item,i)=>{
        let itemDef = itemDefs[item.name];
        let value = itemDef && itemDef.value ? itemDef.value : 5;
        let isEquipped = p.equipped && p.equipped === item;
        let isUnsellable = itemDef && itemDef.unsellable;
        let isDisabled = isEquipped || isUnsellable;
        let btnStyle = `padding:8px; border-radius:6px; border:1px solid #f44336; background:${isDisabled ? '#666' : '#C62828'}; color:${isDisabled ? '#999' : 'white'}; cursor:${isDisabled ? 'not-allowed' : 'pointer'}; display:flex; justify-content:space-between; align-items:center;`;
        
        html+=`<button data-selleq="${i}" style="${btnStyle}">`;
        html+=`<span>${item.name.replace(/_/g, ' ')} Lvl ${item.level || 1} (${item.durability})${isEquipped ? ' [EQUIPPED]' : ''}${isUnsellable ? ' [LEGENDARY]' : ''}</span>`;
        html+=`<span style="color:#FFD700; font-weight:bold;">${isUnsellable ? 'UNSELLABLE' : value + 'g'}</span>`;
        html+=`</button>`;
      });
      html += '</div>';
    }
    
    openModal(html, btn => {
      if(btn.dataset.buyg){
        let itemName = btn.dataset.buyg;
        let shopItem = null;
        Object.values(shops).forEach(shopItems => {
          shopItems.forEach(item => {
            if(item.name === itemName) shopItem = item;
          });
        });
        if(shopItem) {
          showPurchaseConfirmation(shopItem, 'Market', shopItem.price * 2);
        }
      }
      if(btn.dataset.sell){
        let item = btn.dataset.sell;
        if(p.inv[item] > 0) {
          p.inv[item]--;
          p.g = Math.max(0, (p.g || 0) + 1);
          log("Sold " + item + " for 1g");
        }
      }
      if(btn.dataset.selleq){
        let index = parseInt(btn.dataset.selleq);
        let item = p.eq[index];
        let itemDef = itemDefs[item.name];
        let value = itemDef && itemDef.value ? itemDef.value : 5;
        
        if(p.equipped && p.equipped === item) {
          log("Cannot sell equipped item!");
          return;
        }
        
        if(itemDef && itemDef.unsellable) {
          log("This legendary weapon cannot be sold!");
          return;
        }
        
        p.g = Math.max(0, (p.g || 0) + value);
        p.eq.splice(index, 1);
        log("Sold " + item.name + " for " + value + "g");
      }
      updateUI();
    });
  }
  
  function showPurchaseConfirmation(item, shopType, customPrice = null) {
    const price = customPrice || item.price;
    const canAfford = (p.g || 0) >= price;
    
    // Get item effects description
    let effectsHtml = '';
    const itemName = item.name.replace(/_/g, ' ');
    
    // Determine effects based on item type
    if(item.name === 'Health Potion') {
      effectsHtml = '<div style="color:#4CAF50;">✓ Restores HP to maximum</div>';
    } else if(item.name === 'Strength Potion') {
      effectsHtml = '<div style="color:#FF5722;">✓ +20 temporary ATK for 10 steps</div>';
    } else if(item.name === 'Scroll of Healing') {
      effectsHtml = '<div style="color:#4CAF50;">✓ Instantly restore full HP</div>';
    } else if(item.name === 'Luck Charm') {
      effectsHtml = '<div style="color:#FFD700;">✓ +10 temporary LUCK for 10 steps</div>';
    } else if(itemDefs[item.name] && itemDefs[item.name].boost) {
      // Equipment items
      const boost = itemDefs[item.name].boost;
      effectsHtml = Object.entries(boost).map(([stat, value]) => {
        const statName = stat === 'maxHp' ? 'MAX HP' : stat.toUpperCase();
        return `<div style="color:#9C27B0;">✓ +${value} ${statName}</div>`;
      }).join('');
      if(itemDefs[item.name].maxD) {
        effectsHtml += `<div style="color:#666;">✓ ${itemDefs[item.name].maxD} Durability</div>`;
      }
    } else {
      effectsHtml = '<div style="color:#999;">Item effects unknown</div>';
    }
    
    let confirmHtml = `
      <div style="text-align:center; padding:20px;">
        <h3 style="color:#FFD700; margin-bottom:20px;">Purchase Confirmation</h3>
        
        <div style="background:#333; padding:15px; border-radius:8px; margin-bottom:20px;">
          <h4 style="color:#fff; margin-bottom:10px;">${itemName}</h4>
          <div style="margin-bottom:10px;">
            ${effectsHtml}
          </div>
          <div style="color:#FFD700; font-size:18px; font-weight:bold;">
            Price: ${price}g
          </div>
        </div>
        
        <div style="margin-bottom:20px; padding:10px; background:${canAfford ? '#2E7D32' : '#C62828'}; border-radius:6px;">
          <div style="color:white; font-weight:bold;">
            Your Gold: ${p.g}g
          </div>
          ${canAfford ? 
            '<div style="color:#4CAF50; font-size:14px;">✓ You can afford this item</div>' : 
            '<div style="color:#f44336; font-size:14px;">✗ Not enough gold</div>'
          }
        </div>
        
        <div style="display:flex; gap:10px; justify-content:center;">
          <button id="confirm-purchase" style="background:${canAfford ? '#4CAF50' : '#666'}; color:white; border:none; padding:12px 24px; border-radius:6px; cursor:${canAfford ? 'pointer' : 'not-allowed'}; font-weight:bold;">
            ${canAfford ? 'Purchase' : 'Cannot Afford'}
          </button>
          <button id="cancel-purchase" style="background:#f44336; color:white; border:none; padding:12px 24px; border-radius:6px; cursor:pointer; font-weight:bold;">
            Cancel
          </button>
        </div>
      </div>
    `;
    
    // Open the confirmation modal
    OV.style.display='block';
    MD.style.display='block';
    MD.innerHTML = confirmHtml;
    
    // Add event listeners
    document.getElementById('confirm-purchase').onclick = () => {
      if(canAfford) {
        const playerGold = Number(p.g) || 0;
        p.g = Math.max(0, playerGold - price);
        item.apply();
        log(`Bought ${itemName} for ${price}g`);
        closeModal();
        updateUI();
      }
    };
    
    document.getElementById('cancel-purchase').onclick = () => {
      closeModal();
      updateUI();
    };
  }
  
  function openCraft(){
    let html='<h2 style="color:#FF9800; text-align:center; margin-bottom:15px;">🔨 Crafting</h2>';
    let currentCraft = round1(p.craft + (p.tempCraft ? p.tempCraft.value : 0));
    html += `<div style="text-align:center; margin-bottom:20px; padding:10px; background:#2E7D32; border-radius:6px; color:white;">`;
    html += `<strong>Craft Skill: ${currentCraft}% success chance</strong>`;
    html += `</div>`;
    
    html += '<div style="display:grid; gap:8px;">';
    recipes.forEach(r=>{
      // Hide Broken Stick recipe unless all required items are available
      if(r.name === 'Broken_Stick') {
        let hasAllItems = materials(r.need);
        if(!hasAllItems) return; // Skip showing this recipe
      }
      
      let canCraft = materials(r.need);
      let btnStyle = `padding:10px; border-radius:6px; border:1px solid ${canCraft ? '#4CAF50' : '#f44336'}; background:${canCraft ? '#2E7D32' : '#333'}; color:${canCraft ? 'white' : '#999'}; cursor:${canCraft ? 'pointer' : 'not-allowed'}; display:flex; justify-content:space-between; align-items:center;`;
      
      html += `<button data-r="${r.name}" style="${btnStyle}">`;
      html += `<div>`;
      html += `<div style="font-weight:bold; margin-bottom:4px;">${r.name.replace(/_/g, ' ')}</div>`;
      html += `<div style="font-size:12px; opacity:0.8;">Materials: ${Object.entries(r.need).map(e=>e.join('x')).join(', ')}</div>`;
      html += `</div>`;
      html += `<div style="text-align:right;">`;
      html += `<div style="font-size:12px; color:#FFD700;">${currentCraft}% chance</div>`;
      html += `<div style="font-size:10px; opacity:0.6;">+0.1 skill</div>`;
      html += `</div>`;
      html += `</button>`;
    });
    html += '</div>';
    
    openModal(html, btn => {
      if(btn.dataset.r){
        let recipe = recipes.find(r => r.name === btn.dataset.r);
        if(materials(recipe.need)){
          // Always consume materials on attempt
          Object.keys(recipe.need).forEach(k=>p.inv[k]-=recipe.need[k]);
          
          // Always increase craft skill by 0.1
          p.craft = round1(p.craft + 0.1);
          
          // Reduce tempCraft attempts
          if(p.tempCraft){
            p.tempCraft.steps--;
            if(p.tempCraft.steps <= 0){
              p.tempCraft = null;
              log("Crafting potion wore off!");
            }
          }
          
          // Check if crafting succeeded based on percentage
          let craftChance = round1(p.craft + (p.tempCraft ? p.tempCraft.value : 0));
          let craftRoll = Math.random() * 100;
          
          if(craftRoll <= craftChance) {
            p.inv[recipe.name]=(p.inv[recipe.name]||0)+1;
            log(`Crafting SUCCESS! Made ${recipe.name} (${craftChance}% chance, rolled ${round1(craftRoll)})`);
          } else {
            log(`Crafting FAILED! Lost materials (${craftChance}% chance, rolled ${round1(craftRoll)})`);
          }
          
          log(`Craft skill increased to ${round1(p.craft)}`);
        } else log("Missing materials");
      }
      updateUI();
    });
  }
  
  function openInventory() {
    let html = '<h2 style="color:#4CAF50; text-align:center; margin-bottom:15px;">📦 Inventory</h2>';
    
    if(Object.keys(p.inv).length === 0 && p.eq.length === 0) {
      html += '<div style="text-align:center; color:#888; padding:20px;">Empty inventory</div>';
    } else {
      // Show items
      if(Object.keys(p.inv).some(item => p.inv[item] > 0)) {
        html += '<h3 style="color:#FFD700; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:10px;">🍾 Items</h3>';
        html += '<div style="display:grid; gap:8px; margin-bottom:15px;">';
        Object.entries(p.inv).forEach(([item, count]) => {
          if(count > 0) {
            let itemStyle = 'padding:8px 12px; background:#333; border-radius:5px; border:1px solid #555; display:flex; justify-content:space-between; align-items:center;';
            html += `<div style="${itemStyle}">`;
            html += `<span style="color:#eee;">${item.replace(/_/g, ' ')} x${count}</span>`;
            html += `<div style="display:flex; gap:5px;">`;
            
            // Add use buttons for potions
            if(item === 'Health Potion') {
              html += ` <button data-use-health="${item}" style="background:#4CAF50; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Use</button>`;
            }
            if(item === 'Strength Potion') {
              html += ` <button data-use-strength="${item}" style="background:#FF9800; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Use</button>`;
            }
            if(item === 'Rage Potion') {
              html += ` <button data-use-rage="${item}" style="background:#f44336; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Use</button>`;
            }
            
            html += `</div></div>`;
          }
        });
        html += '</div>';
      }
      
      // Show equipment
      if(p.eq.length > 0) {
        html += '<h3 style="color:#FF6B6B; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:10px;">⚔️ Equipment</h3>';
        html += '<div style="display:grid; gap:8px;">';
        p.eq.forEach((item, index) => {
          let isEquipped = p.equipped && p.equipped === item;
          let itemStyle = `padding:8px 12px; background:${isEquipped ? '#2E7D32' : '#333'}; border-radius:5px; border:1px solid ${isEquipped ? '#4CAF50' : '#555'}; display:flex; justify-content:space-between; align-items:center;`;
          
          html += `<div style="${itemStyle}">`;
          html += `<span style="color:#eee;">${item.name.replace(/_/g, ' ')} Lvl ${item.level || 1} (${item.durability} dur)${isEquipped ? ' [EQUIPPED]' : ''}</span>`;
          html += `<div style="display:flex; gap:5px;">`;
          
          if (itemDefs[item.name]) {
            if (!isEquipped) {
              html += ` <button data-equip="${index}" style="background:#2196F3; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Equip</button>`;
            } else {
              html += ` <button data-unequip="${index}" style="background:#FF5722; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Unequip</button>`;
            }
          }
          
          html += `</div></div>`;
        });
        html += '</div>';
      }
    }
    
    openModal(html, btn => {
      if (btn.dataset.equip !== undefined) {
        const index = parseInt(btn.dataset.equip);
        equipItem(p.eq[index]);
      }
      if (btn.dataset.unequip !== undefined) {
        unequipItem();
      }
      if (btn.dataset.useHealth !== undefined) {
        const potion = btn.dataset.useHealth;
        if(p.inv[potion] > 0) {
          p.inv[potion]--;
          p.hp = round1(Math.min(p.maxHp, p.hp + 10));
          log("Used Health Potion (+10 HP)");
        }
      }
      if (btn.dataset.useStrength !== undefined) {
        const potion = btn.dataset.useStrength;
        if(p.inv[potion] > 0) {
          p.inv[potion]--;
          p.tempAtk = {value: roll(10,20), steps: roll(30,90)};
          log(`Used Strength Potion (+${p.tempAtk.value} ATK for ${p.tempAtk.steps} steps)`);
        }
      }
      if (btn.dataset.useRage !== undefined) {
        const potion = btn.dataset.useRage;
        if(p.inv[potion] > 0) {
          p.inv[potion]--;
          p.tempAtk = {value: Math.floor(p.atk * 2), steps: 30};
          p.hp = Math.max(1, round1(p.hp * 0.75));
          log("RAGE! ATK doubled, HP reduced by 25% for 30 steps");
        }
      }
      updateUI();
    });
  }
  
  function showQuestPopup(n) {
    const q = n.quest;
    let questType = q.type === 'kill' ? 'Kill Quest' : 'Fetch Quest';
    
    let requirementText = '';
    if(q.type === 'kill') {
      requirementText = Object.entries(q.need).map(([monster, count]) => 
        `${monster.replace(/_/g, ' ')} x${count}`
      ).join(', ');
    } else {
      requirementText = Object.entries(q.need).map(e => e.join(' x ')).join(', ');
    }
    
    let rewardText = '';
    if(q.rewardGold) {
      rewardText = `${q.rewardGold} gold`;
    } else if(q.reward) {
      rewardText = q.reward;
    }
    
    let html = `
      <h2>Quest from ${n.profession}</h2>
      <div class="quest-details">
        <p><strong>Type:</strong> ${questType}</p>
        <p><strong>Required:</strong> ${requirementText}</p>
        <p><strong>Reward:</strong> ${rewardText}</p>
      </div>
      <div class="quest-options">
        <button class="quest-accept" data-accept="true">Accept</button>
        <button class="quest-decline" data-accept="false">Decline</button>
      </div>
    `;
    
    QM.innerHTML = html;
    QM.style.display = 'block';
    OV.style.display = 'block';
    
    QM.querySelectorAll('button').forEach(btn => {
      btn.onclick = (e) => {
        e.stopPropagation();
        if (btn.dataset.accept === 'true') {
          acceptQuest(n);
        }
        closeQuestPopup();
      };
    });
  }
  
  function showTownQuestPopup(quest) {
    let html = `
      <h2>Quest: ${quest.name}</h2>
      <div class="quest-details">
        <p><strong>Description:</strong> ${quest.desc}</p>
        <p><strong>Reward:</strong> ${quest.reward.gold} gold</p>
      </div>
      <div class="quest-options">
        <button class="quest-accept" data-accept="true">Accept</button>
        <button class="quest-decline" data-accept="false">Decline</button>
      </div>
    `;
    
    QM.innerHTML = html;
    QM.style.display = 'block';
    OV.style.display = 'block';
    
    QM.querySelectorAll('button').forEach(btn => {
      btn.onclick = (e) => {
        e.stopPropagation();
        if (btn.dataset.accept === 'true') {
          quests.push({
            name: quest.name,
            type: quest.type,
            desc: quest.desc,
            need: quest.need,
            progress: {},
            reward: quest.reward,
            state: 1
          });
          log("Accepted quest: " + quest.name);
        }
        closeQuestPopup();
      };
    });
  }
  
  function acceptQuest(n) {
    const q = n.quest;
    q.state = 1;
    
    let questName = (q.type === 'kill' ? 'K' : 'F') + n.profession;
    let questDesc = '';
    
    if(q.type === 'kill') {
      questDesc = 'Kill ' + Object.entries(q.need).map(([monster, count]) => 
        `${monster.replace(/_/g, ' ')} x${count}`
      ).join(', ');
    } else {
      questDesc = 'Bring ' + Object.entries(q.need).map(e => e.join('x')).join(', ');
    }
    
    if(q.rewardGold) {
      questDesc += ` (Reward: ${q.rewardGold}g)`;
    } else if(q.reward) {
      questDesc += ` (Reward: ${q.reward})`;
    }
    
    quests.push({
      name: questName,
      type: q.type,
      desc: questDesc,
      need: q.need,
      progress: {},
      reward: { item: q.reward, gold: q.rewardGold },
      state: 1
    });
    log("Accepted quest from " + n.profession);
  }
  
  function closeQuestPopup() {
    QM.style.display = 'none';
    OV.style.display = 'none';
  }
  
  function materials(req){
    for(let k in req){
      if((p.inv[k]||0)<req[k]) return false;
    }
    return true;
  }
  
  function equip(nm){
    let def=itemDefs[nm];
    let maxDurability = typeof def.maxD === 'function' ? def.maxD() : def.maxD;
    let d=roll(1,maxDurability);
    p.eq.push({name:nm,durability:d,level:def.level||1});
    log("Got "+nm+"("+d+")");
  }
  
  function equipItem(item) {
    // Validate item definition exists
    if(!itemDefs[item.name]) {
      log("Error: Unknown item " + item.name);
      return;
    }
    
    // Unequip current item first if any
    if(p.equipped){
      let boostToRemove = p.equipped.boost || itemDefs[p.equipped.name].boost;
      if(boostToRemove) {
        Object.entries(boostToRemove).forEach(([stat,value])=>{
          p[stat] = round1(p[stat] - value);
        });
        log("Unequipped " + p.equipped.name);
      }
    }
    
    // Equip new item
    p.equipped = item;
    let boostToUse = item.boost || itemDefs[item.name].boost;
    if(boostToUse) {
      Object.entries(boostToUse).forEach(([stat,value])=>{
        p[stat] = round1(p[stat] + value);
      });
    }
    log("Equipped " + item.name);
  }
  
  function unequipItem() {
    if(p.equipped) {
      let boostToRemove = p.equipped.boost || itemDefs[p.equipped.name].boost;
      if(boostToRemove) {
        Object.entries(boostToRemove).forEach(([stat,value])=>{
          p[stat] = round1(p[stat] - value);
        });
      }
      log("Unequipped " + p.equipped.name);
      p.equipped = null;
    }
  }
  
  // Modal
  function openModal(html,act){
    OV.style.display='block';
    MD.style.display='block';
    MD.innerHTML=html+"<br><button id='close' style='background:#f44336; color:white; border:none; padding:10px 20px; border-radius:6px; cursor:pointer; font-weight:bold; margin-top:15px; display:block; margin-left:auto; margin-right:auto;'>✕ Close</button>";
    d('#close').onclick=()=>{
      closeModal();
      updateUI();
    };
    if(act) {
      MD.querySelectorAll('button[data-buy],button[data-buyg],button[data-sell],button[data-selleq],button[data-q],button[data-r],button[data-turn],button[data-equip],button[data-unequip],button[data-use-health],button[data-use-strength],button[data-use-rage],button[data-combine]').forEach(b=>{
        b.onclick=(e)=>{
          e.preventDefault();
          act(b);
        };
      });
    }
  }
  
  function openCombiner(){
    let html = '<h3>Equipment Combiner</h3>';
    html += '<p>I can combine 2 identical equipment pieces into a stronger version!</p>';
    html += '<p>Cost: Level 1→2: 100g, Level 2→3: 200g, Level 3→4: 300g, etc.</p>';
    html += '<p>Stats increase by 50%, durability adds up (max 100)</p>';
    
    // Find combinable equipment
    const equipmentCounts = {};
    p.eq.forEach(eq => {
      const key = `${eq.name}_${eq.level || 1}`;
      if (!equipmentCounts[key]) equipmentCounts[key] = [];
      equipmentCounts[key].push(eq);
    });
    
    html += '<br><h4>Available Combinations:</h4>';
    let hasOptions = false;
    
    Object.entries(equipmentCounts).forEach(([key, items]) => {
      if(items.length >= 2) {
        hasOptions = true;
        const [name, level] = key.split('_');
        const displayName = name.replace(/_/g, ' ');
        const cost = parseInt(level) * 100;
        const currentLevel = parseInt(level);
        const newLevel = currentLevel + 1;
        
        html += `<div style="margin: 10px 0; padding: 10px; background: #333; border-radius: 5px;">`;
        html += `<p>${displayName} Level ${currentLevel} → Level ${newLevel}</p>`;
        html += `<p>Cost: ${cost}g (Have: ${items.length} pieces)</p>`;
        html += `<button data-combine="${name}_${level}" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Combine</button>`;
        html += `</div>`;
      }
    });
    
    if(!hasOptions) {
      html += '<p style="color: #999;">No equipment available for combining.</p>';
    }
    
    openModal(html, (btn) => {
      if(btn.dataset.combine) {
        const [name, level] = btn.dataset.combine.split('_');
        combineEquipment(name, parseInt(level));
      }
    });
  }
  
  function combineEquipment(equipmentName, level) {
    const cost = level * 100;
    
    if(p.g < cost) {
      log("Not enough gold! Need " + cost + "g");
      return;
    }
    
    // Find two pieces of the same equipment and level
    const targetEquipment = p.eq.filter(eq => eq.name === equipmentName && (eq.level || 1) == level);
    
    if(targetEquipment.length < 2) {
      log("Need at least 2 pieces of the same equipment!");
      return;
    }
    
    // Remove the two pieces
    const piece1 = targetEquipment[0];
    const piece2 = targetEquipment[1];
    
    // Remove from equipment array
    const index1 = p.eq.indexOf(piece1);
    const index2 = p.eq.indexOf(piece2);
    p.eq.splice(Math.max(index1, index2), 1);
    p.eq.splice(Math.min(index1, index2), 1);
    
    // Create new combined piece
    const itemDef = itemDefs[equipmentName];
    const newLevel = level + 1;
    const newBoost = {};
    
    // Calculate new stats (50% increase from base or existing custom boost)
    const baseBoost = piece1.boost || itemDef.boost;
    Object.entries(baseBoost).forEach(([stat, value]) => {
      newBoost[stat] = Math.floor(value * 1.5);
    });
    
    // Calculate new durability (add up but max 100, minimum 2)
    const newDurability = Math.min(100, Math.max(2, piece1.durability + piece2.durability));
    
    const newItem = {
      name: equipmentName,
      level: newLevel,
      durability: newDurability,
      boost: newBoost
    };
    
    p.eq.push(newItem);
    
    p.g -= cost;
    log(`Combined ${equipmentName.replace(/_/g, ' ')} into Level ${newLevel}!`);
    log(`New stats: ${JSON.stringify(newBoost)}, Durability: ${newDurability}`);
    
    closeModal();
    updateUI();
  }

  function closeModal(){
    OV.style.display='none';
    MD.style.display='none';
    MD.innerHTML='';
  }
  
  // Bind & init
  document.addEventListener('DOMContentLoaded',()=>{
    ['up','down','left','right'].forEach(dn=>d(`[data-dir="${dn}"]`).onclick=()=>move(dn));
    d('#btn-inv').onclick    = openInventory;
    d('#btn-craft').onclick  = openCraft;
    d('#btn-shop').onclick   = openGlobal;
    d('#btn-quests').onclick = openQuests;
    d('#btn-reborn').onclick = ()=>{
      localStorage.removeItem(SAVE);
      LEl.innerHTML='';
      quests = []; // Clear quests array
      init();
      log("Reborn!");
      updateUI();
    };
    OV.onclick=() => {
      if(QM.style.display === 'block') {
        closeQuestPopup();
      } else {
        closeModal();
      }
    };
    init();
    log("Welcome to Dungeon Quest!");
    updateUI();
  });
})();
</script>
</body>
</html>
