<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Dungeon Quest</title>
<style>
  * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: monospace;
  background: #111;
  color: #eee;
  padding: 10px;
  font-size: 14px;
  line-height: 1.4;
  max-width: 100%;
  overflow-x: hidden;
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  gap: 10px;
}

#map {
  white-space: pre;
  font-family: monospace;
  font-size: 16px;
  line-height: 1.2;
  background: #222;
  padding: 10px;
  border-radius: 5px;
  overflow-x: auto;
  max-width: 100%;
}

#content-row {
  display: flex;
  gap: 10px;
  width: 100%;
}

#log {
  flex: 1;
  height: 150px;
  overflow-y: auto;
  background: #222;
  border: 1px solid #444;
  padding: 8px;
  border-radius: 5px;
}

#stats {
  flex: 1;
  background: #222;
  padding: 5px;
  border-radius: 5px;
  height: 150px;
  overflow-y: auto;
}

.stat-row {
  display: flex;
  justify-content: space-between;
}

.stat-item {
  background: #333;
  padding: 5px 8px;
  border-radius: 3px;
  flex: 1;
  text-align: center;
  margin: 0 2px;
}

#controls {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  width: 100%;
}

#nav {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: 5px;
  width: 40%;
  max-width: 150px;
}

.nav-btn {
  font-size: 1em;
  width: 100%;
  aspect-ratio: 1/1;
  background: #333;
  border: 1px solid #555;
  color: #eee;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  border-radius: 3px;
}

.nav-cell {
  visibility: hidden;
}

#actions {
  display: flex;
  flex-direction: column;
  gap: 5px;
  width: 40%;
}

.act-btn {
  font-size: 0.85em;
  padding: 6px 4px;
  background: #333;
  border: 1px solid #555;
  color: #eee;
  text-align: center;
  border-radius: 3px;
  flex: 1;
}

.act-btn:hover, .nav-btn:hover {
  background: #444;
  cursor: pointer;
}

/* Color coding for map elements */
.monster-lvl1 { color: #ff9999; }
.monster-lvl2 { color: #ff6666; }
.monster-lvl3 { color: #ff3333; }
.monster-lvl4 { color: #ff0000; }
.monster-lvl5 { color: #cc0000; }
.monster-lvl6 { color: #990000; }
.monster-lvl7 { color: #660000; }
.monster-lvl8 { color: #aa0000; }
.monster-lvl9 { color: #440000; }
.monster-lvl10 { color: #220000; }
.chest { color: #ffff00; }
.town-npc { color: #55ffff; }
.resource { color: #55ff55; }

/* Modal styles */
.overlay, .modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
}
.overlay {
  background: rgba(0,0,0,0.7);
  z-index: 10;
}
.modal {
  background: #222;
  width: 90%;
  max-width: 400px;
  max-height: 80vh;
  overflow: auto;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 15px;
  border: 1px solid #555;
  border-radius: 5px;
  z-index: 11;
}

/* Quest Modal Styles */
#quest-modal {
  display: none;
}

.quest-options {
  display: flex;
  justify-content: space-between;
  margin-top: 15px;
  gap: 10px;
}

.quest-options button {
  padding: 8px 15px;
  border-radius: 3px;
  border: none;
  flex: 1;
}

.quest-accept {
  background: #4CAF50;
  color: white;
}

.quest-decline {
  background: #f44336;
  color: white;
}

.quest-details {
  margin: 10px 0;
  line-height: 1.6;
}

@media (min-width: 500px) {
  #nav {
    width: 120px;
  }
  
  #actions {
    width: calc(100% - 130px);
  }
  
  .act-btn {
    padding: 10px;
  }
}
</style>
</head>
<body>

<div id="map"></div>
<div id="content-row">
  <div id="log"></div>
  <div id="stats"></div>
</div>

<div id="controls">
  <!-- Nav: plus shape -->
  <div id="nav">
    <div class="nav-cell"></div>
    <button class="nav-btn" data-dir="up">↑</button>
    <div class="nav-cell"></div>

    <button class="nav-btn" data-dir="left">←</button>
    <div class="nav-cell"></div>
    <button class="nav-btn" data-dir="right">→</button>

    <div class="nav-cell"></div>
    <button class="nav-btn" data-dir="down">↓</button>
    <div class="nav-cell"></div>
  </div>

  <!-- Actions -->
  <div id="actions">
    <button id="btn-inv" class="act-btn">Inventory</button>
    <button id="btn-craft" class="act-btn">Crafting</button>
    <button id="btn-shop" class="act-btn">Market</button>
    <button id="btn-quests" class="act-btn">Quests</button>
    <button id="btn-reborn" class="act-btn">Reborn</button>
  </div>
</div>

<div id="overlay" class="overlay"></div>
<div id="modal" class="modal"></div>
<div id="quest-modal" class="modal"></div>

<script>
(() => {
  // Helper function to round to 1 decimal place
  const round1 = num => Math.round(num * 10) / 10;
  
  // Data definitions - expanded monster templates with 10 levels
  const monsterTpl={
    Goblin: {base:{hp:8,atk:3,def:1,boost:'atk'}, levels:[
      {name:'Goblin',mult:1,reward:0.1},
      {name:'Hobgoblin',mult:2,reward:0.2},
      {name:'Goblin Warrior',mult:3,reward:0.3},
      {name:'Goblin Elite',mult:4,reward:0.4},
      {name:'Goblin Captain',mult:5,reward:0.5},
      {name:'Goblin King',mult:6,reward:0.6},
      {name:'Goblin Warlord',mult:7,reward:0.7},
      {name:'Goblin Overlord',mult:8,reward:0.8},
      {name:'Goblin Emperor',mult:9,reward:0.9},
      {name:'Ancient Goblin',mult:10,reward:1.0}
    ]},
    Skeleton: {base:{hp:12,atk:4,def:2,boost:'def'}, levels:[
      {name:'Skeleton',mult:1,reward:0.1},
      {name:'Skeleton Warrior',mult:2,reward:0.2},
      {name:'Skeleton Soldier',mult:3,reward:0.3},
      {name:'Skeleton Knight',mult:4,reward:0.4},
      {name:'Skeleton Elite',mult:5,reward:0.5},
      {name:'Skeleton Duke',mult:6,reward:0.6},
      {name:'Skeleton King',mult:7,reward:0.7},
      {name:'Skeleton Lord',mult:8,reward:0.8},
      {name:'Skeleton Emperor',mult:9,reward:0.9},
      {name:'Bone Archlich',mult:10,reward:1.0}
    ]},
    Wolf: {base:{hp:15,atk:5,def:3,boost:'maxHp'}, levels:[
      {name:'Wolf',mult:1,reward:1},
      {name:'Wild Wolf',mult:2,reward:1.5},
      {name:'Dark Wolf',mult:3,reward:2},
      {name:'Dire Wolf',mult:4,reward:2.5},
      {name:'Shadow Wolf',mult:5,reward:3},
      {name:'Alpha Wolf',mult:6,reward:3.5},
      {name:'Werewolf',mult:7,reward:4},
      {name:'Fenrir Wolf',mult:8,reward:4.5},
      {name:'Demon Wolf',mult:9,reward:5},
      {name:'Primordial Wolf',mult:10,reward:10}
    ]},
    Orc: {base:{hp:10,atk:6,def:2,boost:'atk'}, levels:[
      {name:'Orc',mult:1,reward:0.1},
      {name:'Orc Scout',mult:2,reward:0.2},
      {name:'Orc Fighter',mult:3,reward:0.3},
      {name:'Orc Berserker',mult:4,reward:0.4},
      {name:'Orc Champion',mult:5,reward:0.5},
      {name:'Orc Warlord',mult:6,reward:0.6},
      {name:'Orc Chieftain',mult:7,reward:0.7},
      {name:'Orc General',mult:8,reward:0.8},
      {name:'Orc Emperor',mult:9,reward:0.9},
      {name:'Orc Destroyer',mult:10,reward:1.0}
    ]},
    Ogre: {base:{hp:12,atk:4,def:4,boost:'maxHp'}, levels:[
      {name:'Ogre',mult:1,reward:1},
      {name:'Ogre Brute',mult:2,reward:1.5},
      {name:'Ogre Warrior',mult:3,reward:2},
      {name:'Ogre Berserker',mult:4,reward:2.5},
      {name:'Ogre Champion',mult:5,reward:3},
      {name:'Ogre Warlord',mult:6,reward:3.5},
      {name:'Ogre King',mult:7,reward:4},
      {name:'Ogre Titan',mult:8,reward:4.5},
      {name:'Ogre Colossus',mult:9,reward:5},
      {name:'Ancient Ogre',mult:10,reward:10}
    ]},
    Gnoll: {base:{hp:9,atk:5,def:3,boost:'def'}, levels:[
      {name:'Gnoll',mult:1,reward:0.1},
      {name:'Gnoll Hunter',mult:2,reward:0.2},
      {name:'Gnoll Warrior',mult:3,reward:0.3},
      {name:'Gnoll Shaman',mult:4,reward:0.4},
      {name:'Gnoll Chieftain',mult:5,reward:0.5},
      {name:'Gnoll Warlord',mult:6,reward:0.6},
      {name:'Gnoll King',mult:7,reward:0.7},
      {name:'Gnoll Packmaster',mult:8,reward:0.8},
      {name:'Gnoll Emperor',mult:9,reward:0.9},
      {name:'Gnoll Demigod',mult:10,reward:1.0}
    ]},
    Wyvern: {base:{hp:10,atk:6,def:5,boost:'atk'}, levels:[
      {name:'Wyvern',mult:1,reward:1},
      {name:'Young Wyvern',mult:2,reward:1.5},
      {name:'Adult Wyvern',mult:3,reward:2},
      {name:'Elder Wyvern',mult:4,reward:2.5},
      {name:'Wyvern Lord',mult:5,reward:3},
      {name:'Wyvern King',mult:6,reward:3.5},
      {name:'Dragon Wyvern',mult:7,reward:4},
      {name:'Ancient Wyvern',mult:8,reward:4.5},
      {name:'Primordial Wyvern',mult:9,reward:5},
      {name:'Wyvern God',mult:10,reward:10}
    ]}
  };

  const shops={ 
    'Potion Seller':[
      {name:'Health Potion',price:5,apply:()=>{p.hp=Math.min(p.maxHp,round1(p.hp+10))}},
      {name:'Strength Potion',price:10,apply:()=>{p.tempAtk={value:roll(10,20),steps:roll(30,90)}}},
      {name:'Rage Potion',price:50,apply:()=>{
        p.tempAtk={value:Math.floor(p.atk * 2),steps:30};
        p.hp = Math.max(1, round1(p.hp * 0.75));
        log("Rage consumes your health!");
      }},
      {name:'Warrior\'s Elixir',price:30,apply:()=>{p.tempAtk={value:15,steps:50}}},
      {name:'Guardian Tonic',price:20,apply:()=>{p.tempDef={value:20,steps:60}}},
      {name:'Master Crafter\'s Brew',price:100,apply:()=>{p.tempCraft={value:50,steps:30}}}
    ], 
    'Blacksmith':[
      {name:'Iron Sword',price:20,apply:()=>{equip('Iron Sword')}}
    ], 
    'Scroll Merchant':[
      {name:'Scroll of Healing',price:12,apply:()=>{p.hp=p.maxHp}},
      {name:'Luck Charm',price:50,apply:()=>{p.tempLuck={value:10,steps:10}}}
    ] 
  };

  const itemDefs={
    'Spear':{boost:{atk:2},maxD:100},
    'Shield':{boost:{def:3},maxD:100},
    'Greatsword':{boost:{atk:4},maxD:100},
    'PlateArmor':{boost:{maxHp:10},maxD:100},
    'Iron Sword':{boost:{atk:3},maxD:100},
    'Skeleton_King_Bone':{boost:{def:1},maxD:50},
    'Dire_Wolf_Pelt':{boost:{maxHp:5},maxD:50},
    // Level 10 special items
    'Ancient_Goblin_Crown':{boost:{atk:5,def:2},maxD:200,value:200},
    'Bone_Archlich_Staff':{boost:{atk:8},maxD:200,value:200},
    'Primordial_Wolf_Fang':{boost:{atk:6,maxHp:8},maxD:200,value:200},
    'Orc_Destroyer_Axe':{boost:{atk:10},maxD:200,value:200},
    'Ancient_Ogre_Club':{boost:{atk:7,maxHp:15},maxD:200,value:200},
    'Gnoll_Demigod_Spear':{boost:{atk:9,def:3},maxD:200,value:200},
    'Wyvern_God_Scale':{boost:{atk:12,def:5,maxHp:10},maxD:200,value:200},
    // Ultimate legendary weapon
    'Apex_Worldender':{boost:{atk:25,def:15,maxHp:25},maxD:500,value:1000},
    // New weapons with random durability
    'Shadowstrike_Blade':{boost:{atk:6,def:1},maxD:()=>roll(40,100),value:150},
    'Thundercaller_Hammer':{boost:{atk:8,maxHp:5},maxD:()=>roll(40,100),value:180},
    'Voidreaper_Scythe':{boost:{atk:10},maxD:()=>roll(40,100),value:200},
    'Dragonbane_Spear':{boost:{atk:5,def:4},maxD:()=>roll(40,100),value:160},
    'Soulrender_Axe':{boost:{atk:7,maxHp:3},maxD:()=>roll(40,100),value:170}
  };

  const recipes=[
    {name:'Health Potion',need:{Herb:1,Bottle:1}},
    {name:'Strength Potion',need:{Herb:2}},
    {name:'Scroll of Healing',need:{Paper:1,Herb:1}},
    {name:'Iron Ingot',need:{'Iron Ore':2,Coal:1}},
    {name:'Iron Sword',need:{'Iron Ingot':1,Wood:2}},
    {name:'Shadowstrike_Blade',need:{'Iron Ingot':2,'Skeleton_Bone':1,Wood:1}},
    {name:'Thundercaller_Hammer',need:{'Iron Ingot':3,Coal:2}},
    {name:'Voidreaper_Scythe',need:{'Iron Ingot':2,'Orc_Tusk':1,Wood:2}},
    {name:'Dragonbane_Spear',need:{'Iron Ingot':1,'Wolf_Pelt':1,Wood:3}},
    {name:'Soulrender_Axe',need:{'Iron Ingot':2,'Gnoll_Claw':1,Wood:1}},
    {name:'Apex_Worldender',need:{'Ancient_Goblin_Crown':1,'Bone_Archlich_Staff':1,'Primordial_Wolf_Fang':1,'Orc_Destroyer_Axe':1,'Ancient_Ogre_Club':1,'Gnoll_Demigod_Spear':1,'Wyvern_God_Scale':1}}
  ];

  const npcProfs=['Hunter','Herbalist','Miner','Scout','Mercenary'];
  
  const fetchTpl={ 
    Hunter:{need:{Wolf_Pelt:3},reward:'Spear'}, 
    Herbalist:{need:{Herb:3},rewardGold:15}, 
    Miner:{need:{'Iron Ore':2},reward:'Greatsword'}, 
    Scout:{need:{Wood:3},reward:'Shield'},
    Mercenary:{need:{Goblin_Ear:2},rewardGold:20}
  };

  const townQuests={ 
    easy:[
      {name:'Help Herbalist',type:'fetch',desc:'Bring 2 Herbs',need:{Herb:2},reward:{gold:10}},
      {name:'Wolf Pelt',type:'fetch',desc:'Bring 1 Wolf Pelt',need:{Wolf_Pelt:1},reward:{gold:15}},
      {name:'Orc Tusks',type:'fetch',desc:'Bring 2 Orc Tusks',need:{Orc_Tusk:2},reward:{gold:20}},
      {name:'Gnoll Claws',type:'fetch',desc:'Bring 1 Gnoll Claw',need:{Gnoll_Claw:1},reward:{gold:18}}
    ], 
    med:[
      {name:'Slay Goblins',type:'kill',desc:'Defeat 3 Goblins',need:{Goblin:3},reward:{gold:15}},
      {name:'Skeleton Bones',type:'fetch',desc:'Bring 2 Skeleton Bones',need:{Skeleton_Bone:2},reward:{gold:20}},
      {name:'Orc Hunt',type:'kill',desc:'Defeat 2 Orcs',need:{Orc:2},reward:{gold:25}},
      {name:'Ogre Challenge',type:'kill',desc:'Defeat 1 Ogre',need:{Ogre:1},reward:{gold:30}}
    ], 
    hard:[
      {name:'Defeat Skeletons',type:'kill',desc:'Defeat 2 Skeleton Soldiers',need:{Skeleton_Soldier:2},reward:{gold:25}},
      {name:'Hob Goblin Challenge',type:'kill',desc:'Defeat 1 Hobgoblin',need:{Hobgoblin:1},reward:{gold:30}},
      {name:'Wyvern Hunt',type:'kill',desc:'Defeat 1 Wyvern',need:{Wyvern:1},reward:{gold:40}},
      {name:'Gnoll Pack',type:'kill',desc:'Defeat 3 Gnoll Hunters',need:{Gnoll_Hunter:3},reward:{gold:45}}
    ],
    elite:[
      {name:'Goblin King',type:'kill',desc:'Defeat the Goblin King',need:{Goblin_King:1},reward:{gold:50}},
      {name:'Skeleton Duke',type:'kill',desc:'Defeat a Skeleton Duke',need:{Skeleton_Duke:1},reward:{gold:60}},
      {name:'Orc Warlord',type:'kill',desc:'Defeat an Orc Warlord',need:{Orc_Warlord:1},reward:{gold:70}},
      {name:'Elder Wyvern',type:'kill',desc:'Defeat an Elder Wyvern',need:{Elder_Wyvern:1},reward:{gold:80}}
    ],
    legendary:[
      {name:'Ancient Goblin',type:'kill',desc:'Defeat the Ancient Goblin',need:{Ancient_Goblin:1},reward:{gold:500}},
      {name:'Bone Archlich',type:'kill',desc:'Defeat the Bone Archlich',need:{Bone_Archlich:1},reward:{gold:500}},
      {name:'Primordial Wolf',type:'kill',desc:'Defeat the Primordial Wolf',need:{Primordial_Wolf:1},reward:{gold:500}},
      {name:'Orc Destroyer',type:'kill',desc:'Defeat the Orc Destroyer',need:{Orc_Destroyer:1},reward:{gold:500}},
      {name:'Ancient Ogre',type:'kill',desc:'Defeat the Ancient Ogre',need:{Ancient_Ogre:1},reward:{gold:500}},
      {name:'Gnoll Demigod',type:'kill',desc:'Defeat the Gnoll Demigod',need:{Gnoll_Demigod:1},reward:{gold:500}},
      {name:'Wyvern God',type:'kill',desc:'Defeat the Wyvern God',need:{Wyvern_God:1},reward:{gold:500}}
    ]
  };
  
  // State - changed to 512x512 map (32x32 areas of 16x16 tiles)
  const AREA=16,GRID_W=16,GRID_H=16,TOWN=16,SIZE=512,SAVE='dqSave';
  let p,world,quests=[];
  const d=s=>document.querySelector(s),dA=s=>document.querySelectorAll(s),
        SEl=d('#stats'),MEl=d('#map'),LEl=d('#log'),OV=d('#overlay'),MD=d('#modal'),
        QM=d('#quest-modal');
  
  function roll(a,b){return Math.floor(Math.random()*(b-a+1))+a;}
  
  function init(){
    const s=localStorage.getItem(SAVE);
    if(s) try{ 
      let o=JSON.parse(s); 
      p=o.player; 
      // Ensure all numeric values are properly typed and rounded
      p.atk = round1(p.atk);
      p.def = round1(p.def);
      p.luck = round1(p.luck);
      p.maxHp = round1(p.maxHp);
      p.hp = round1(p.hp);
      p.craft = round1(p.craft);
      // Fix gold to ensure it's always a number
      p.g = Number(p.g) || 0;
      // Initialize missing temporary effects
      p.tempDef = p.tempDef || null;
      p.tempCraft = p.tempCraft || null;
      // Track current area for refresh system
      p.currentArea = p.currentArea || {x: TOWN, y: TOWN};
      quests=o.quests||[];
    }catch{localStorage.removeItem(SAVE);return init();}
    else p={
      x:TOWN*AREA+8,
      y:TOWN*AREA+8,
      maxHp:20,
      hp:20,
      atk:round1(roll(1,7)),
      def:round1(roll(1,7)),
      luck:round1(roll(1,5)),
      g:0,
      inv:{},
      eq:[],
      craft:0,
      equipped:null,
      tempAtk:null,
      tempLuck:null,
      tempDef:null,
      tempCraft:null,
      steps:0,
      kills:{},
      preventFlee:0,
      currentArea: {x: TOWN, y: TOWN}
    };
    world=Array.from({length:32},(_,y)=>Array.from({length:32},(_,x)=>gen(x===TOWN&&y===TOWN, x, y)));
    save();
  }
  
  function save(){
    // Round all numeric values before saving
    const saveData = {
      player: {
        ...p,
        atk: round1(p.atk),
        def: round1(p.def),
        luck: round1(p.luck),
        maxHp: round1(p.maxHp),
        hp: round1(p.hp),
        craft: round1(p.craft),
        g: Number(p.g) || 0
      },
      quests: quests
    };
    localStorage.setItem(SAVE,JSON.stringify(saveData));
  }

  function generateRandomQuest(distFromTown) {
    // 60% kill quests, 40% gathering quests
    const isKillQuest = Math.random() < 0.6;
    
    // Calculate difficulty multiplier based on distance
    const difficultyMult = Math.max(1, Math.floor(distFromTown / 3));
    
    let quest;
    
    if (isKillQuest) {
      // Generate kill quest
      const monsterTypes = ['Goblin','Skeleton','Wolf','Orc','Ogre','Gnoll','Wyvern'];
      const monsterType = monsterTypes[roll(0, monsterTypes.length-1)];
      
      // Determine quest level based on distance
      let questLevel = 0;
      if(distFromTown > 6) questLevel = Math.min(8, Math.floor(distFromTown));
      else if(distFromTown > 3) questLevel = Math.min(5, Math.floor(distFromTown));
      else if(distFromTown > 1.5) questLevel = Math.min(3, Math.floor(distFromTown));
      
      const monsterData = monsterTpl[monsterType];
      const levelData = monsterData.levels[questLevel];
      const targetMonster = levelData.name.replace(/\s+/g, '_');
      
      const questCount = Math.max(1, roll(1, 3) + Math.floor(difficultyMult / 2));
      
      quest = {
        type: 'kill',
        need: {[targetMonster]: questCount},
        progress: {[targetMonster]: 0},
        state: 0
      };
    } else {
      // Generate gathering quest
      const gatherItems = ['Herb', 'Wood', 'Iron_Ore', 'Coal', 'Stone', 'Wolf_Pelt', 'Skeleton_Bone', 'Orc_Tusk', 'Gnoll_Claw'];
      const targetItem = gatherItems[roll(0, gatherItems.length-1)];
      const gatherCount = Math.max(1, roll(1, 4) + Math.floor(difficultyMult / 2));
      
      quest = {
        type: 'gather',
        need: {[targetItem]: gatherCount},
        state: 0
      };
    }
    
    // Generate reward - 50% equipment, 50% gold (never both)
    const isEquipmentReward = Math.random() < 0.5;
    
    if (isEquipmentReward) {
      // Equipment reward based on distance/difficulty
      const equipmentPool = ['Spear', 'Shield', 'Greatsword', 'PlateArmor', 'Iron_Sword'];
      if (difficultyMult >= 3) {
        equipmentPool.push('Shadowstrike_Blade', 'Thundercaller_Hammer', 'Voidreaper_Scythe', 'Dragonbane_Spear', 'Soulrender_Axe');
      }
      if (difficultyMult >= 5) {
        equipmentPool.push('Ancient_Goblin_Crown', 'Bone_Archlich_Staff', 'Primordial_Wolf_Fang');
      }
      
      quest.reward = equipmentPool[roll(0, equipmentPool.length-1)];
    } else {
      // Gold reward scaled by distance
      const baseGold = isKillQuest ? 20 : 15;
      const scaledGold = Math.floor(baseGold * (1 + difficultyMult * 0.5));
      quest.rewardGold = scaledGold;
    }
    
    return quest;
  }

  // Function to update quest progress and auto-complete quests
  function updateQuestProgress(questType, itemKey) {
    if(!quests || quests.length === 0) return;
    
    // Create a copy to avoid issues with array modification during iteration
    const questsCopy = [...quests];
    
    questsCopy.forEach((quest, index) => {
      if(!quest || !quest.type || !quest.need || quest.state !== 1) return;
      
      // Update progress for kill quests
      if(quest.type === 'kill' && questType === 'kill' && quest.need[itemKey]) {
        if(!quest.progress) quest.progress = {};
        quest.progress[itemKey] = (quest.progress[itemKey] || 0) + 1;
        
        // Check if quest is complete
        let isComplete = true;
        for(let [monster, needed] of Object.entries(quest.need)) {
          if((quest.progress[monster] || 0) < needed) {
            isComplete = false;
            break;
          }
        }
        
        if(isComplete) {
          // Find the actual index in the current quests array
          const actualIndex = quests.findIndex(q => q === quest);
          if(actualIndex !== -1) {
            completeQuestFromList(quest, actualIndex);
          }
        }
      }
      
      // Check gather quest completion whenever inventory changes
      if(quest.type === 'gather' && questType === 'gather') {
        let isComplete = true;
        for(let [item, needed] of Object.entries(quest.need)) {
          if((p.inv[item] || 0) < needed) {
            isComplete = false;
            break;
          }
        }
        
        if(isComplete) {
          // Find the actual index in the current quests array
          const actualIndex = quests.findIndex(q => q === quest);
          if(actualIndex !== -1) {
            completeQuestFromList(quest, actualIndex);
          }
        }
      }
    });
  }

  // Function to complete a quest from the quest list and give rewards
  function completeQuestFromList(quest, questIndex) {
    if(!quest || !quest.type || questIndex < 0 || questIndex >= quests.length) return;
    
    // Remove consumed items for gather quests
    if(quest.type === 'gather' && quest.need) {
      for(let [item, needed] of Object.entries(quest.need)) {
        if(p.inv[item] >= needed) {
          p.inv[item] = (p.inv[item] || 0) - needed;
          if(p.inv[item] <= 0) delete p.inv[item];
        }
      }
    }
    
    // Give rewards - handle the correct reward structure
    if(quest.reward && quest.reward.gold) {
      p.g = Math.max(0, (p.g || 0) + quest.reward.gold);
      log(`Quest completed! Received ${quest.reward.gold} gold.`);
    }
    
    if(quest.reward && quest.reward.item) {
      // Add equipment to inventory or equip directly
      let itemDef = itemDefs[quest.reward.item];
      if(itemDef) {
        let durability = typeof itemDef.maxD === 'function' ? itemDef.maxD() : itemDef.maxD;
        p.eq.push({name: quest.reward.item, durability: durability});
        log(`Quest completed! Received ${quest.reward.item.replace(/_/g, ' ')}.`);
      } else {
        p.inv[quest.reward.item] = (p.inv[quest.reward.item] || 0) + 1;
        log(`Quest completed! Received ${quest.reward.item.replace(/_/g, ' ')}.`);
      }
    }
    
    // Remove quest from active list
    quests.splice(questIndex, 1);
    log(`Quest completed automatically!`);
    save();
  }
  
  function gen(isTown, areaX, areaY){
    let tiles=Array.from({length:AREA},()=>Array.from({length:AREA},()=>({type:'empty'})));
    if(isTown){
      ['Potion Seller','Blacksmith','Scroll Merchant','Quest Giver EM','Quest Giver H','Quest Giver S']
        .forEach(pr=>place(tiles,pr,true,areaX,areaY));
    } else {
      for(let i=0;i<2;i++) place(tiles,npcProfs[roll(0,npcProfs.length-1)],false,areaX,areaY);
      for(let y=0;y<AREA;y++)for(let x=0;x<AREA;x++){
        if(tiles[y][x].type!=='empty')continue;
        let r=Math.random()*100;
        if(r<20) { // Reduced from 30 to 20 for less clutter
          // Monster spawn based on distance from town - fixed distance calculation
          const distFromTown = Math.sqrt(Math.pow(areaX-TOWN,2) + Math.pow(areaY-TOWN,2));
          const monsterTypes = ['Goblin','Skeleton','Wolf','Orc','Ogre','Gnoll','Wyvern'];
          const monsterType = monsterTypes[roll(0,monsterTypes.length-1)];
          const monsterData = monsterTpl[monsterType];
          
          // Fixed level spawning - areas adjacent to town only spawn level 1-2
          let maxLevel = 0;
          if(distFromTown <= 1.5) {
            // Adjacent areas: only level 1-2
            maxLevel = Math.random() < 0.7 ? 0 : 1;
          } else if(distFromTown <= 3) {
            // Nearby areas: level 1-4
            maxLevel = Math.min(3, Math.floor(distFromTown));
          } else if(distFromTown <= 6) {
            // Mid-distance: level 3-7
            maxLevel = Math.min(6, Math.floor(distFromTown) + 1);
          } else {
            // Far areas: level 6-10
            maxLevel = Math.min(9, Math.floor(distFromTown));
          }
          
          let level = 0;
          for(let l=maxLevel;l>=0;l--){
            if(Math.random() < 1/Math.pow(1.5,l)){
              level = l;
              break;
            }
          }
          
          const levelData = monsterData.levels[level];
          const monster = {
            ...structuredClone(monsterData.base),
            name: levelData.name,
            level: level+1,
            reward: levelData.reward,
            boost: monsterData.base.boost,
            type: monsterType
          };
          
          // Scale stats by level multiplier
          Object.keys(monsterData.base).forEach(stat => {
            if(stat !== 'boost') monster[stat] = Math.floor(monster[stat] * levelData.mult);
          });
          
          tiles[y][x]={type:'monster',data:monster};
        }
        else if(r<40) { // Reduced from 55 to 40 for less clutter
          const resources = ['Herb','Bottle','Wood','Iron Ore','Coal','Paper','Wolf_Pelt','Goblin_Ear','Skeleton_Bone','Orc_Tusk','Ogre_Hide','Gnoll_Claw','Wyvern_Scale'];
          tiles[y][x]={type:'resource',data:resources[roll(0,resources.length-1)]};
        }
        else if(r<50) tiles[y][x]={type:'trap'}; // Reduced from 65 to 50
        else if(r<55) tiles[y][x]={type:'chest'}; // Reduced from 70 to 55
      }
    }
    return {tiles};
  }
  
  function place(tiles,prof,town,areaX,areaY){
    for(let i=0;i<100;i++){
      let x=roll(0,AREA-1),y=roll(0,AREA-1);
      if(tiles[y][x].type==='empty'){
        let npc={type:'npc',data:{profession:prof}};
        if(town) {
          npc.data.abbr = prof === 'Quest Giver S' ? 'S' : prof[0]; // Special handler for Quest Giver S
          npc.data.isTown = true;
        } else {
          npc.data.abbr = 'N'; // Random NPCs show as 'N'
        }
        if(!town&&fetchTpl[prof]) {
          npc.data.quest={...fetchTpl[prof],state:0};
        } else if(!town) {
          // Create distance-based random quests for NPCs without fetch templates
          const distFromTown = Math.sqrt(Math.pow(areaX-TOWN,2) + Math.pow(areaY-TOWN,2));
          npc.data.quest = generateRandomQuest(distFromTown);
        }
        tiles[y][x]=npc;
        return;
      }
    }
  }
  
  function getT(x,y){
    let ax=Math.floor(x/AREA),ay=Math.floor(y/AREA),lx=x%AREA,ly=y%AREA;
    return world[ay][ax].tiles[ly][lx];
  }
  
  function setT(x,y,t){
    let ax=Math.floor(x/AREA),ay=Math.floor(y/AREA),lx=x%AREA,ly=y%AREA;
    world[ay][ax].tiles[ly][lx]=t;
  }
  
  function log(m){LEl.innerHTML+=m+'<br>';LEl.scrollTop=LEl.scrollHeight;save();}
  
  function updateUI(){
    // Handle temporary buffs
    if(p.tempAtk){
      p.tempAtk.steps--;
      if(p.tempAtk.steps <= 0){
        p.tempAtk = null;
        log("Strength potion wore off!");
      }
    }
    
    if(p.tempLuck){
      p.tempLuck.steps--;
      if(p.tempLuck.steps <= 0){
        p.tempLuck = null;
        log("Luck charm wore off!");
      }
    }
    
    if(p.tempDef){
      p.tempDef.steps--;
      if(p.tempDef.steps <= 0){
        p.tempDef = null;
        log("Defense potion wore off!");
      }
    }
    
    p.steps++;
    
    const currentAtk = round1(p.atk + (p.tempAtk ? p.tempAtk.value : 0));
    const currentLuck = round1(p.luck + (p.tempLuck ? p.tempLuck.value : 0));
    const currentDef = round1(p.def + (p.tempDef ? p.tempDef.value : 0));
    const currentCraft = round1(p.craft + (p.tempCraft ? p.tempCraft.value : 0));
    
    // Update stats display
    let statsHTML = `
      <div class="stat-bar"><span class="stat-name">HP:</span> ${round1(p.hp)}/${round1(p.maxHp)}</div>
      <div class="stat-bar"><span class="stat-name">ATK:</span> ${currentAtk}(${round1(p.atk)})</div>
      <div class="stat-bar"><span class="stat-name">DEF:</span> ${currentDef}(${round1(p.def)})</div>
      <div class="stat-bar"><span class="stat-name">LUCK:</span> ${currentLuck}(${round1(p.luck)})</div>
      <div class="stat-bar"><span class="stat-name">GOLD:</span> ${p.g}</div>
      <div class="stat-bar"><span class="stat-name">CRAFT:</span> ${currentCraft}(${round1(p.craft)})</div>
    `;
    
    if(p.equipped) {
      statsHTML += `<div class="stat-bar"><span class="stat-name">EQUIP:</span> ${p.equipped.name}(${p.equipped.durability})</div>`;
    }
    
    SEl.innerHTML = statsHTML;
    
    let gx=p.x,gy=p.y,ax=Math.floor(gx/AREA),ay=Math.floor(gy/AREA),lx=gx%AREA,ly=gy%AREA,
        sx=Math.max(0,Math.min(AREA-GRID_W,lx-Math.floor(GRID_W/2))),
        sy=Math.max(0,Math.min(AREA-GRID_H,ly-Math.floor(GRID_H/2))),
        o='';
    
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        let tx=sx+x,ty=sy+y,ch='.';
        if(tx===lx&&ty===ly) ch='P';
        else {
          let c=getT(tx+ax*AREA,ty+ay*AREA);
          if(c.type==='monster') {
            const levelClass = `monster-lvl${Math.min(10, c.data.level)}`;
            ch=`<span class="${levelClass}">M</span>`;
          }
          else if(c.type==='resource') ch=`<span class="resource">R</span>`;
          else if(c.type==='trap') ch='T';
          else if(c.type==='chest') ch='<span class="chest">C</span>';
          else if(c.type==='npc') {
            if(c.data.isTown) {
              ch=`<span class="town-npc">${c.data.abbr}</span>`;
            } else {
              ch=`<span class="town-npc">N</span>`;
            }
          }
        }
        o+=ch+' ';
      }
      o+='\n';
    }
    MEl.innerHTML=o;
  }
  
  function move(dir){
    // Prevent movement if player is dead
    if(p.hp <= 0) {
      log("You are dead! Use Reborn to start over.");
      return;
    }
    
    let nx=p.x,ny=p.y;
    if(dir==='up') ny--;
    else if(dir==='down') ny++;
    else if(dir==='left') nx--;
    else if(dir==='right') nx++;
    
    if(nx<0||nx>=SIZE||ny<0||ny>=SIZE) return;
    
    let t=getT(nx,ny);
    if(t.type==='monster') {
      if(p.preventFlee>0) {
        log("Cannot flee!");
        return;
      }
      fight(t.data,nx,ny);
    }
    else if(t.type==='resource') {
      p.inv[t.data]=(p.inv[t.data]||0)+1;
      log("Found "+t.data);
      setT(nx,ny,{type:'empty'});
      p.x=nx; p.y=ny;
      
      // Check quest progress for gather quests
      updateQuestProgress('gather', t.data);
      
      checkAreaChange();
      updateUI();
    }
    else if(t.type==='trap') {
      let dmg=roll(1,5);
      p.hp=Math.max(0,round1(p.hp-dmg));
      log("Trap! -"+dmg+" HP");
      setT(nx,ny,{type:'empty'});
      p.x=nx; p.y=ny;
      checkAreaChange();
      updateUI();
    }
    else if(t.type==='chest') {
      let g=roll(5,15);
      p.g = Math.max(0, (p.g || 0) + g);
      log("Chest! +"+g+" gold");
      setT(nx,ny,{type:'empty'});
      p.x=nx; p.y=ny;
      checkAreaChange();
      updateUI();
    }
    else if(t.type==='npc') {
      interact(t.data);
    }
    else {
      p.x=nx; p.y=ny;
      
      checkAreaChange();
      updateUI();
    }
  }
  
  function checkAreaChange() {
    // Check if player moved to a different area
    let newAreaX = Math.floor(p.x / AREA);
    let newAreaY = Math.floor(p.y / AREA);
    
    if(newAreaX !== p.currentArea.x || newAreaY !== p.currentArea.y) {
      // Player moved to a new area - refresh the old area
      world[p.currentArea.y][p.currentArea.x] = gen(p.currentArea.x === TOWN && p.currentArea.y === TOWN, p.currentArea.x, p.currentArea.y);
      p.currentArea = {x: newAreaX, y: newAreaY};
    }
  }
  
  function fight(m,x,y){
    let playerAtk = round1(p.atk + (p.tempAtk ? p.tempAtk.value : 0));
    let playerLuck = round1(p.luck + (p.tempLuck ? p.tempLuck.value : 0));
    
    // Calculate attack with equipment
    let equipAtk = 0;
    if(p.equipped && itemDefs[p.equipped.name] && itemDefs[p.equipped.name].boost && itemDefs[p.equipped.name].boost.atk) {
      equipAtk = itemDefs[p.equipped.name].boost.atk;
    }
    
    let totalPlayerAtk = playerAtk + equipAtk;
    
    log("Fighting "+m.name+" (HP:"+m.hp+", ATK:"+m.atk+", DEF:"+m.def+")");
    
    while(m.hp > 0 && p.hp > 0) {
      // Player attacks monster
      let playerDmg = roll(1, totalPlayerAtk); // Random damage from 1 to attack stat
      let defenseReduction = Math.floor(m.def / 2); // Defense reduces damage by 1 per 2 defense
      playerDmg = Math.max(1, playerDmg - defenseReduction);
      
      // Apply luck to damage
      if(Math.random() < playerLuck/100) {
        playerDmg = Math.floor(playerDmg * 1.5);
        log("Lucky hit!");
      }
      
      m.hp = Math.max(0, m.hp - playerDmg);
      log("You deal "+playerDmg+" damage to "+m.name);
      
      if(m.hp <= 0) break;
      
      // Monster attacks player
      let monsterDmg = roll(1, m.atk); // Random damage from 1 to attack stat
      let currentPlayerDef = round1(p.def + (p.tempDef ? p.tempDef.value : 0));
      let playerDefenseReduction = Math.floor(currentPlayerDef / 2); // Defense reduces damage by 1 per 2 defense
      monsterDmg = Math.max(1, monsterDmg - playerDefenseReduction);
      
      p.hp = Math.max(0, round1(p.hp - monsterDmg));
      log(m.name+" deals "+monsterDmg+" damage to you");
      
      // Reduce equipment durability
      if(p.equipped) {
        p.equipped.durability--;
        if(p.equipped.durability <= 0) {
          log(p.equipped.name+" broke!");
          unequipItem();
        }
      }
    }
    
    if(p.hp <= 0) {
      p.hp = 0;
      log("You died!");
      updateUI();
      return;
    }
    
    log("You defeated "+m.name+"!");
    log("Remaining HP: " + round1(p.hp) + "/" + round1(p.maxHp));
    
    // Award experience based on monster level and reward
    let statGain = round1(m.reward || 0.1);
    if(m.level === 10) statGain = round1((m.reward || 0.1) * 10); // Level 10 monsters give 10x rewards
    
    // Apply stat boost based on monster type
    if(m.boost === 'atk') {
      p.atk = round1(p.atk + statGain);
      log("ATK +" + statGain);
    } else if(m.boost === 'def') {
      p.def = round1(p.def + statGain);
      log("DEF +" + statGain);
    } else if(m.boost === 'maxHp') {
      p.maxHp = round1(p.maxHp + statGain);
      p.hp = round1(p.hp + statGain);
      log("HP +" + statGain);
    }
    
    // Gold reward
    let goldReward = roll(1, m.level * 5);
    p.g = Math.max(0, (p.g || 0) + goldReward);
    log("+" + goldReward + " gold");
    
    // Track kills for quests
    let monsterKey = m.name.replace(/\s+/g, '_');
    p.kills[monsterKey] = (p.kills[monsterKey] || 0) + 1;
    
    // Update quest progress for kill quests
    updateQuestProgress('kill', monsterKey);
    
    // Level 10 monsters drop special items
    if(m.level === 10) {
      let specialItems = {
        'Ancient_Goblin': 'Ancient_Goblin_Crown',
        'Bone_Archlich': 'Bone_Archlich_Staff',
        'Primordial_Wolf': 'Primordial_Wolf_Fang',
        'Orc_Destroyer': 'Orc_Destroyer_Axe',
        'Ancient_Ogre': 'Ancient_Ogre_Club',
        'Gnoll_Demigod': 'Gnoll_Demigod_Spear',
        'Wyvern_God': 'Wyvern_God_Scale'
      };
      
      let itemKey = specialItems[monsterKey];
      if(itemKey) {
        let itemDef = itemDefs[itemKey];
        let durability = roll(1, itemDef.maxD);
        p.eq.push({name: itemKey, durability: durability});
        log("Found rare item: " + itemKey.replace(/_/g, ' ') + " (" + durability + " durability)");
      }
    }
    
    // Random resource drop
    if(Math.random() < 0.3) {
      let resourceMap = {
        'Goblin': 'Goblin_Ear',
        'Skeleton': 'Skeleton_Bone',
        'Wolf': 'Wolf_Pelt',
        'Orc': 'Orc_Tusk',
        'Ogre': 'Ogre_Hide',
        'Gnoll': 'Gnoll_Claw',
        'Wyvern': 'Wyvern_Scale'
      };
      
      let resource = resourceMap[m.type] || 'Herb';
      p.inv[resource] = (p.inv[resource] || 0) + 1;
      log("Found " + resource.replace(/_/g, ' '));
    }
    
    // Update quest progress
    quests.forEach(q => {
      if(q.state === 1 && q.type === 'kill' && q.need[monsterKey]) {
        q.progress[monsterKey] = (q.progress[monsterKey] || 0) + 1;
        if(q.progress[monsterKey] >= q.need[monsterKey]) {
          log("Quest progress: " + q.name);
        }
      }
    });
    
    setT(x,y,{type:'empty'});
    p.x=x; p.y=y;
    checkAreaChange();
    updateUI();
  }
  
  function interact(n){
    if(n.profession==='Potion Seller'||n.profession==='Blacksmith'||n.profession==='Scroll Merchant'){
      openShop(n.profession);
    }
    else if(n.profession==='Quest Giver EM'||n.profession==='Quest Giver H'||n.profession==='Quest Giver S'){
      if(n.profession==='Quest Giver EM') openQuestGiver('easy','med');
      else if(n.profession==='Quest Giver H') openQuestGiver('hard','elite');
      else if(n.profession==='Quest Giver S') openQuestGiver('legendary');
    }
    else if(n.quest){
      if(n.quest.state===0) {
        showQuestPopup(n);
      }
      else if(n.quest.state===1){
        let canComplete = true;
        
        // Debug logging
        log(`DEBUG: Attempting to complete quest. Type: ${n.quest.type}`);
        log(`DEBUG: Quest needs: ${JSON.stringify(n.quest.need)}`);
        
        // Enhanced validation for quest completion
        if(n.quest.type === 'kill') {
          // Kill quest validation - check each monster requirement
          log(`DEBUG: Player kills: ${JSON.stringify(p.kills)}`);
          Object.entries(n.quest.need).forEach(([monster, needed]) => {
            let killed = p.kills[monster] || 0;
            log(`DEBUG: Need ${needed} ${monster}, have ${killed}`);
            if(killed < needed) {
              canComplete = false;
              log(`DEBUG: Cannot complete - insufficient kills for ${monster}`);
            }
          });
        } else {
          // Fetch quest validation - check each item requirement
          log(`DEBUG: Player inventory: ${JSON.stringify(p.inv)}`);
          Object.entries(n.quest.need).forEach(([item, needed]) => {
            let have = p.inv[item] || 0;
            log(`DEBUG: Need ${needed} ${item}, have ${have}`);
            if(have < needed) {
              canComplete = false;
              log(`DEBUG: Cannot complete - insufficient items for ${item}`);
            }
          });
        }
        
        // Double-check validation to prevent any bypasses
        if(canComplete) {
          // Re-validate one more time before completion
          if(n.quest.type === 'kill') {
            for(let [monster, needed] of Object.entries(n.quest.need)) {
              if((p.kills[monster] || 0) < needed) {
                log("Quest validation failed: insufficient kills for " + monster);
                canComplete = false;
                break;
              }
            }
          } else {
            for(let [item, needed] of Object.entries(n.quest.need)) {
              if((p.inv[item] || 0) < needed) {
                log("Quest validation failed: insufficient items for " + item);
                canComplete = false;
                break;
              }
            }
          }
        }
        
        if(canComplete){
          // Remove items for fetch quests only after final validation
          if(n.quest.type !== 'kill') {
            let validationFailed = false;
            for(let [item, needed] of Object.entries(n.quest.need)) {
              if((p.inv[item] || 0) >= needed) {
                p.inv[item] = (p.inv[item] || 0) - needed;
              } else {
                log("ERROR: Tried to remove " + item + " but player doesn't have enough!");
                validationFailed = true;
                break;
              }
            }
            
            if(validationFailed) {
              log("Quest completion aborted due to validation failure!");
              return; // Exit the entire function without completing quest
            }
          }
          
          // Give rewards - either gold OR item, not both
          if(n.quest.rewardGold) {
            const goldReward = Number(n.quest.rewardGold) || 0;
            p.g = Math.max(0, (p.g || 0) + goldReward);
            log("Quest complete! +" + goldReward + "g");
          }
          if(n.quest.reward) {
            equip(n.quest.reward);
            log("Quest complete! Received " + n.quest.reward);
          }
          
          n.quest.state=2;
        } else {
          if(n.quest.type === 'kill') {
            log("Cannot complete quest! Need to kill: " + Object.entries(n.quest.need).map(([monster, needed]) => 
              `${monster.replace(/_/g, ' ')} (${p.kills[monster] || 0}/${needed})`
            ).join(', '));
          } else {
            log("Cannot complete quest! Need: " + Object.entries(n.quest.need).map(([item, needed]) => 
              `${item.replace(/_/g, ' ')} (${p.inv[item] || 0}/${needed})`
            ).join(', '));
          }
        }
      }
      else log("Quest already complete");
    }
  }
  
  function openShop(prof){
    let arr=shops[prof];
    let shopIcons = {'Potion Seller': '🧪', 'Blacksmith': '⚒️', 'Scroll Merchant': '📜'};
    let shopColors = {'Potion Seller': '#4CAF50', 'Blacksmith': '#FF5722', 'Scroll Merchant': '#9C27B0'};
    
    let html=`<h2 style="color:${shopColors[prof]}; text-align:center; margin-bottom:15px;">${shopIcons[prof]} ${prof}</h2>`;
    html += `<div style="text-align:center; margin-bottom:20px; padding:8px; background:#333; border-radius:6px; color:#FFD700;">`;
    html += `<strong>Your Gold: ${p.g}</strong>`;
    html += `</div>`;
    
    html += '<div style="display:grid; gap:8px;">';
    arr.forEach(it=>{
      let canAfford = (p.g || 0) >= it.price;
      let btnStyle = `padding:12px; border-radius:6px; border:1px solid ${canAfford ? '#4CAF50' : '#f44336'}; background:${canAfford ? '#2E7D32' : '#333'}; color:${canAfford ? 'white' : '#999'}; cursor:${canAfford ? 'pointer' : 'not-allowed'}; display:flex; justify-content:space-between; align-items:center;`;
      
      html += `<button data-buy="${it.name}" style="${btnStyle}">`;
      html += `<div style="font-weight:bold;">${it.name.replace(/_/g, ' ')}</div>`;
      html += `<div style="color:#FFD700; font-weight:bold;">${it.price}g</div>`;
      html += `</button>`;
    });
    html += '</div>';
    
    openModal(html, btn => {
      if(btn.dataset.buy){
        let it=arr.find(x=>x.name===btn.dataset.buy);
        const itemPrice = Number(it.price) || 0;
        const playerGold = Number(p.g) || 0;
        
        if(playerGold >= itemPrice){
          p.g = Math.max(0, playerGold - itemPrice);
          it.apply();
          log("Bought "+it.name);
        } else log("Not enough gold");
      }
      updateUI();
    });
  }
  
  function openQuestGiver(tier1, tier2) {
    let availableQuests = [];
    let questMap = [];
    
    // Add tier1 quests
    (townQuests[tier1] || []).forEach((quest, index) => {
      availableQuests.push(quest);
      questMap.push({tier: tier1, index: index});
    });
    
    // Add tier2 quests if provided
    if(tier2) {
      (townQuests[tier2] || []).forEach((quest, index) => {
        availableQuests.push(quest);
        questMap.push({tier: tier2, index: index});
      });
    }
    
    let tierColors = {'easy': '#4CAF50', 'med': '#FF9800', 'hard': '#f44336', 'elite': '#9C27B0', 'legendary': '#FFD700'};
    let tierNames = {'easy': 'Easy', 'med': 'Medium', 'hard': 'Hard', 'elite': 'Elite', 'legendary': 'Legendary'};
    
    let html = `<h2 style="color:#FFD700; text-align:center; margin-bottom:15px;">🎯 Quest Giver</h2>`;
    html += `<div style="text-align:center; margin-bottom:20px; padding:8px; background:#333; border-radius:6px; color:#ddd;">`;
    html += `Available Quests: ${tier2 ? `${tierNames[tier1]} & ${tierNames[tier2]}` : tierNames[tier1]} Tier`;
    html += `</div>`;
    
    html += '<div style="display:grid; gap:8px;">';
    availableQuests.forEach((quest, index) => {
      let tier = questMap[index].tier;
      let existing = quests.find(q => q.name === quest.name);
      let isAccepted = !!existing;
      
      let btnStyle = `padding:12px; border-radius:6px; border:1px solid ${isAccepted ? '#666' : tierColors[tier]}; background:${isAccepted ? '#333' : tierColors[tier]}; color:${isAccepted ? '#999' : 'white'}; cursor:${isAccepted ? 'not-allowed' : 'pointer'}; display:flex; justify-content:space-between; align-items:center;`;
      
      html += `<button data-q="${index}" style="${btnStyle}">`;
      html += `<div>`;
      html += `<div style="font-weight:bold; margin-bottom:4px;">${quest.name}${isAccepted ? ' [ACCEPTED]' : ''}</div>`;
      html += `<div style="font-size:12px; opacity:0.8;">${quest.desc}</div>`;
      html += `</div>`;
      html += `<div style="text-align:right;">`;
      html += `<div style="color:#FFD700; font-weight:bold;">${quest.reward.gold}g</div>`;
      html += `<div style="font-size:10px; opacity:0.6;">${tierNames[tier]}</div>`;
      html += `</div>`;
      html += `</button>`;
    });
    html += '</div>';
    
    openModal(html, btn => {
      if(btn.dataset.q) {
        let questIndex = parseInt(btn.dataset.q);
        if(questIndex >= 0 && questIndex < availableQuests.length) {
          let quest = availableQuests[questIndex];
          
          // Check if quest already accepted
          let existing = quests.find(q => q.name === quest.name);
          if(existing) {
            log("Quest already accepted");
            return;
          }
          
          // Show quest popup instead of directly accepting
          showTownQuestPopup(quest);
        }
      }
      updateUI();
    });
  }
  
  function openQuests() {
    let html = '<h2 style="color:#FFD700; text-align:center; margin-bottom:15px;">📋 Active Quests</h2>';
    if(quests.length === 0) {
      html += '<div style="text-align:center; color:#888; padding:20px;">No active quests</div>';
    } else {
      html += '<div style="display:grid; gap:12px;">';
      quests.forEach((quest, index) => {
        // Check if quest can be completed
        let canComplete = true;
        if(quest.type === 'kill') {
          Object.entries(quest.need).forEach(([monster, needed]) => {
            if((p.kills[monster] || 0) < needed) canComplete = false;
          });
        } else if(quest.type === 'fetch') {
          Object.entries(quest.need).forEach(([item, needed]) => {
            if((p.inv[item] || 0) < needed) canComplete = false;
          });
        }
        
        let questStyle = `padding:12px; background:${canComplete ? '#1B5E20' : '#333'}; border-radius:8px; border:1px solid ${canComplete ? '#4CAF50' : '#555'};`;
        html += `<div style="${questStyle}">`;
        html += `<div style="color:#FFD700; font-weight:bold; margin-bottom:8px;">${quest.name}</div>`;
        html += `<div style="color:#ddd; margin-bottom:8px; font-size:14px;">${quest.desc}</div>`;
        
        html += '<div style="margin-bottom:8px;">';
        if(quest.type === 'kill') {
          Object.entries(quest.need).forEach(([monster, needed]) => {
            let killed = p.kills[monster] || 0;
            let color = killed >= needed ? '#4CAF50' : '#FF9800';
            html += `<div style="color:${color}; font-size:13px;">• ${monster.replace(/_/g, ' ')}: ${killed}/${needed}</div>`;
          });
        } else if(quest.type === 'fetch') {
          Object.entries(quest.need).forEach(([item, needed]) => {
            let have = p.inv[item] || 0;
            let color = have >= needed ? '#4CAF50' : '#FF9800';
            html += `<div style="color:${color}; font-size:13px;">• ${item.replace(/_/g, ' ')}: ${have}/${needed}</div>`;
          });
        }
        html += '</div>';
        
        if(canComplete) {
          html += `<button data-turn="${index}" style="background:#4CAF50; color:white; border:none; padding:6px 12px; border-radius:4px; cursor:pointer;">Turn In Quest</button>`;
        } else {
          html += `<div style="color:#888; font-size:12px; font-style:italic;">Requirements not met</div>`;
        }
        html += '</div>';
      });
      html += '</div>';
    }
    
    openModal(html, btn => {
      if(btn.dataset.turn) {
        let index = parseInt(btn.dataset.turn);
        let quest = quests[index];
        
        // Validate quest completion before completing
        let canComplete = true;
        if(quest.type === 'kill') {
          Object.entries(quest.need).forEach(([monster, needed]) => {
            if((p.kills[monster] || 0) < needed) canComplete = false;
          });
        } else if(quest.type === 'fetch') {
          Object.entries(quest.need).forEach(([item, needed]) => {
            if((p.inv[item] || 0) < needed) canComplete = false;
          });
        }
        
        if(!canComplete) {
          log("Quest requirements not met!");
          return;
        }
        
        // Complete quest
        if(quest.type === 'fetch') {
          Object.entries(quest.need).forEach(([item, needed]) => {
            p.inv[item] = (p.inv[item] || 0) - needed;
          });
        }
        
        const goldReward = Number(quest.reward.gold) || 0;
        p.g = Math.max(0, (p.g || 0) + goldReward);
        log("Quest completed: " + quest.name + " (+" + goldReward + " gold)");
        quests.splice(index, 1);
      }
      updateUI();
    });
  }
  
  function openGlobal(){
    let html='<h2 style="color:#2196F3; text-align:center; margin-bottom:15px;">🏪 Global Market</h2>';
    html += `<div style="text-align:center; margin-bottom:20px; padding:8px; background:#333; border-radius:6px; color:#FFD700;">`;
    html += `<strong>Your Gold: ${p.g}</strong>`;
    html += `</div>`;
    
    html+='<h3 style="color:#4CAF50; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:15px;">💰 Buy Items (2x Town Price)</h3>';
    html += '<div style="display:grid; gap:8px; margin-bottom:25px;">';
    Object.entries(shops).forEach(([shopName, items]) => {
      let shopColors = {'Potion Seller': '#4CAF50', 'Blacksmith': '#FF5722', 'Scroll Merchant': '#9C27B0'};
      html+=`<div style="margin-bottom:10px;"><h4 style="color:${shopColors[shopName]}; margin-bottom:8px;">${shopName}</h4>`;
      items.forEach(item => {
        let canAfford = (p.g || 0) >= (item.price * 2);
        let btnStyle = `padding:10px; border-radius:6px; border:1px solid ${canAfford ? '#4CAF50' : '#f44336'}; background:${canAfford ? '#2E7D32' : '#333'}; color:${canAfford ? 'white' : '#999'}; cursor:${canAfford ? 'pointer' : 'not-allowed'}; display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;`;
        
        html+=`<button data-buyg="${item.name}" style="${btnStyle}">`;
        html+=`<span>${item.name.replace(/_/g, ' ')}</span>`;
        html+=`<span style="color:#FFD700; font-weight:bold;">${item.price * 2}g</span>`;
        html+=`</button>`;
      });
      html+=`</div>`;
    });
    html += '</div>';
    
    if(Object.keys(p.inv).some(k => p.inv[k] > 0)) {
      html+='<h3 style="color:#FF9800; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:15px;">📦 Sell Items</h3>';
      html += '<div style="display:grid; gap:6px; margin-bottom:25px;">';
      Object.entries(p.inv).forEach(([k,v])=>{
        if(v>0) {
          let btnStyle = `padding:8px; border-radius:6px; border:1px solid #FF9800; background:#E65100; color:white; cursor:pointer; display:flex; justify-content:space-between; align-items:center;`;
          html+=`<button data-sell="${k}" style="${btnStyle}">`;
          html+=`<span>${k.replace(/_/g, ' ')} x${v}</span>`;
          html+=`<span style="color:#FFD700; font-weight:bold;">1g each</span>`;
          html+=`</button>`;
        }
      });
      html += '</div>';
    }
    
    if(p.eq.length > 0) {
      html+='<h3 style="color:#f44336; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:15px;">⚔️ Sell Equipment</h3>';
      html += '<div style="display:grid; gap:6px;">';
      p.eq.forEach((item,i)=>{
        let value = itemDefs[item.name] && itemDefs[item.name].value ? itemDefs[item.name].value : 5;
        let isEquipped = p.equipped && p.equipped.name === item.name;
        let btnStyle = `padding:8px; border-radius:6px; border:1px solid #f44336; background:${isEquipped ? '#666' : '#C62828'}; color:${isEquipped ? '#999' : 'white'}; cursor:${isEquipped ? 'not-allowed' : 'pointer'}; display:flex; justify-content:space-between; align-items:center;`;
        
        html+=`<button data-selleq="${i}" style="${btnStyle}">`;
        html+=`<span>${item.name.replace(/_/g, ' ')} (${item.durability})${isEquipped ? ' [EQUIPPED]' : ''}</span>`;
        html+=`<span style="color:#FFD700; font-weight:bold;">${value}g</span>`;
        html+=`</button>`;
      });
      html += '</div>';
    }
    
    openModal(html, btn => {
      if(btn.dataset.buyg){
        let itemName = btn.dataset.buyg;
        let shopItem = null;
        Object.values(shops).forEach(shopItems => {
          shopItems.forEach(item => {
            if(item.name === itemName) shopItem = item;
          });
        });
        if(shopItem) {
          const itemPrice = Number(shopItem.price * 2) || 0;
          const playerGold = Number(p.g) || 0;
          
          if(playerGold >= itemPrice) {
            p.g = Math.max(0, playerGold - itemPrice);
            shopItem.apply();
            log("Bought " + itemName + " for " + itemPrice + "g");
          } else {
            log("Not enough gold");
          }
        }
      }
      if(btn.dataset.sell){
        let item = btn.dataset.sell;
        if(p.inv[item] > 0) {
          p.inv[item]--;
          p.g = Math.max(0, (p.g || 0) + 1);
          log("Sold " + item + " for 1g");
        }
      }
      if(btn.dataset.selleq){
        let index = parseInt(btn.dataset.selleq);
        let item = p.eq[index];
        let value = itemDefs[item.name] && itemDefs[item.name].value ? itemDefs[item.name].value : 5;
        
        if(p.equipped && p.equipped.name === item.name) {
          log("Cannot sell equipped item!");
          return;
        }
        
        p.g = Math.max(0, (p.g || 0) + value);
        p.eq.splice(index, 1);
        log("Sold " + item.name + " for " + value + "g");
      }
      updateUI();
    });
  }
  
  function openCraft(){
    let html='<h2 style="color:#FF9800; text-align:center; margin-bottom:15px;">🔨 Crafting</h2>';
    let currentCraft = round1(p.craft + (p.tempCraft ? p.tempCraft.value : 0));
    html += `<div style="text-align:center; margin-bottom:20px; padding:10px; background:#2E7D32; border-radius:6px; color:white;">`;
    html += `<strong>Craft Skill: ${currentCraft}% success chance</strong>`;
    html += `</div>`;
    
    html += '<div style="display:grid; gap:8px;">';
    recipes.forEach(r=>{
      let canCraft = materials(r.need);
      let btnStyle = `padding:10px; border-radius:6px; border:1px solid ${canCraft ? '#4CAF50' : '#f44336'}; background:${canCraft ? '#2E7D32' : '#333'}; color:${canCraft ? 'white' : '#999'}; cursor:${canCraft ? 'pointer' : 'not-allowed'}; display:flex; justify-content:space-between; align-items:center;`;
      
      html += `<button data-r="${r.name}" style="${btnStyle}">`;
      html += `<div>`;
      html += `<div style="font-weight:bold; margin-bottom:4px;">${r.name.replace(/_/g, ' ')}</div>`;
      html += `<div style="font-size:12px; opacity:0.8;">Materials: ${Object.entries(r.need).map(e=>e.join('x')).join(', ')}</div>`;
      html += `</div>`;
      html += `<div style="text-align:right;">`;
      html += `<div style="font-size:12px; color:#FFD700;">${currentCraft}% chance</div>`;
      html += `<div style="font-size:10px; opacity:0.6;">+0.1 skill</div>`;
      html += `</div>`;
      html += `</button>`;
    });
    html += '</div>';
    
    openModal(html, btn => {
      if(btn.dataset.r){
        let recipe = recipes.find(r => r.name === btn.dataset.r);
        if(materials(recipe.need)){
          // Always consume materials on attempt
          Object.keys(recipe.need).forEach(k=>p.inv[k]-=recipe.need[k]);
          
          // Always increase craft skill by 0.1
          p.craft = round1(p.craft + 0.1);
          
          // Reduce tempCraft attempts
          if(p.tempCraft){
            p.tempCraft.steps--;
            if(p.tempCraft.steps <= 0){
              p.tempCraft = null;
              log("Crafting potion wore off!");
            }
          }
          
          // Check if crafting succeeded based on percentage
          let craftChance = round1(p.craft + (p.tempCraft ? p.tempCraft.value : 0));
          let craftRoll = Math.random() * 100;
          
          if(craftRoll <= craftChance) {
            p.inv[recipe.name]=(p.inv[recipe.name]||0)+1;
            log(`Crafting SUCCESS! Made ${recipe.name} (${craftChance}% chance, rolled ${round1(craftRoll)})`);
          } else {
            log(`Crafting FAILED! Lost materials (${craftChance}% chance, rolled ${round1(craftRoll)})`);
          }
          
          log(`Craft skill increased to ${round1(p.craft)}`);
        } else log("Missing materials");
      }
      updateUI();
    });
  }
  
  function openInventory() {
    let html = '<h2 style="color:#4CAF50; text-align:center; margin-bottom:15px;">📦 Inventory</h2>';
    
    if(Object.keys(p.inv).length === 0 && p.eq.length === 0) {
      html += '<div style="text-align:center; color:#888; padding:20px;">Empty inventory</div>';
    } else {
      // Show items
      if(Object.keys(p.inv).some(item => p.inv[item] > 0)) {
        html += '<h3 style="color:#FFD700; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:10px;">🍾 Items</h3>';
        html += '<div style="display:grid; gap:8px; margin-bottom:15px;">';
        Object.entries(p.inv).forEach(([item, count]) => {
          if(count > 0) {
            let itemStyle = 'padding:8px 12px; background:#333; border-radius:5px; border:1px solid #555; display:flex; justify-content:space-between; align-items:center;';
            html += `<div style="${itemStyle}">`;
            html += `<span style="color:#eee;">${item.replace(/_/g, ' ')} x${count}</span>`;
            html += `<div style="display:flex; gap:5px;">`;
            
            // Add use buttons for potions
            if(item === 'Health Potion') {
              html += ` <button data-use-health="${item}" style="background:#4CAF50; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Use</button>`;
            }
            if(item === 'Strength Potion') {
              html += ` <button data-use-strength="${item}" style="background:#FF9800; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Use</button>`;
            }
            if(item === 'Rage Potion') {
              html += ` <button data-use-rage="${item}" style="background:#f44336; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Use</button>`;
            }
            
            html += `</div></div>`;
          }
        });
        html += '</div>';
      }
      
      // Show equipment
      if(p.eq.length > 0) {
        html += '<h3 style="color:#FF6B6B; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:10px;">⚔️ Equipment</h3>';
        html += '<div style="display:grid; gap:8px;">';
        p.eq.forEach((item, index) => {
          let isEquipped = p.equipped && p.equipped.name === item.name;
          let itemStyle = `padding:8px 12px; background:${isEquipped ? '#2E7D32' : '#333'}; border-radius:5px; border:1px solid ${isEquipped ? '#4CAF50' : '#555'}; display:flex; justify-content:space-between; align-items:center;`;
          
          html += `<div style="${itemStyle}">`;
          html += `<span style="color:#eee;">${item.name.replace(/_/g, ' ')} (${item.durability} dur)${isEquipped ? ' [EQUIPPED]' : ''}</span>`;
          html += `<div style="display:flex; gap:5px;">`;
          
          if (itemDefs[item.name]) {
            if (!isEquipped) {
              html += ` <button data-equip="${index}" style="background:#2196F3; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Equip</button>`;
            } else {
              html += ` <button data-unequip="${index}" style="background:#FF5722; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Unequip</button>`;
            }
          }
          
          html += `</div></div>`;
        });
        html += '</div>';
      }
    }
    
    openModal(html, btn => {
      if (btn.dataset.equip !== undefined) {
        const index = parseInt(btn.dataset.equip);
        equipItem(p.eq[index]);
      }
      if (btn.dataset.unequip !== undefined) {
        unequipItem();
      }
      if (btn.dataset.useHealth !== undefined) {
        const potion = btn.dataset.useHealth;
        if(p.inv[potion] > 0) {
          p.inv[potion]--;
          p.hp = round1(Math.min(p.maxHp, p.hp + 10));
          log("Used Health Potion (+10 HP)");
        }
      }
      if (btn.dataset.useStrength !== undefined) {
        const potion = btn.dataset.useStrength;
        if(p.inv[potion] > 0) {
          p.inv[potion]--;
          p.tempAtk = {value: roll(10,20), steps: roll(30,90)};
          log(`Used Strength Potion (+${p.tempAtk.value} ATK for ${p.tempAtk.steps} steps)`);
        }
      }
      if (btn.dataset.useRage !== undefined) {
        const potion = btn.dataset.useRage;
        if(p.inv[potion] > 0) {
          p.inv[potion]--;
          p.tempAtk = {value: Math.floor(p.atk * 2), steps: 30};
          p.hp = Math.max(1, round1(p.hp * 0.75));
          log("RAGE! ATK doubled, HP reduced by 25% for 30 steps");
        }
      }
      updateUI();
    });
  }
  
  function showQuestPopup(n) {
    const q = n.quest;
    let questType = q.type === 'kill' ? 'Kill Quest' : 'Fetch Quest';
    
    let requirementText = '';
    if(q.type === 'kill') {
      requirementText = Object.entries(q.need).map(([monster, count]) => 
        `${monster.replace(/_/g, ' ')} x${count}`
      ).join(', ');
    } else {
      requirementText = Object.entries(q.need).map(e => e.join(' x ')).join(', ');
    }
    
    let rewardText = '';
    if(q.rewardGold) {
      rewardText = `${q.rewardGold} gold`;
    } else if(q.reward) {
      rewardText = q.reward;
    }
    
    let html = `
      <h2>Quest from ${n.profession}</h2>
      <div class="quest-details">
        <p><strong>Type:</strong> ${questType}</p>
        <p><strong>Required:</strong> ${requirementText}</p>
        <p><strong>Reward:</strong> ${rewardText}</p>
      </div>
      <div class="quest-options">
        <button class="quest-accept" data-accept="true">Accept</button>
        <button class="quest-decline" data-accept="false">Decline</button>
      </div>
    `;
    
    QM.innerHTML = html;
    QM.style.display = 'block';
    OV.style.display = 'block';
    
    QM.querySelectorAll('button').forEach(btn => {
      btn.onclick = (e) => {
        e.stopPropagation();
        if (btn.dataset.accept === 'true') {
          acceptQuest(n);
        }
        closeQuestPopup();
      };
    });
  }
  
  function showTownQuestPopup(quest) {
    let html = `
      <h2>Quest: ${quest.name}</h2>
      <div class="quest-details">
        <p><strong>Description:</strong> ${quest.desc}</p>
        <p><strong>Reward:</strong> ${quest.reward.gold} gold</p>
      </div>
      <div class="quest-options">
        <button class="quest-accept" data-accept="true">Accept</button>
        <button class="quest-decline" data-accept="false">Decline</button>
      </div>
    `;
    
    QM.innerHTML = html;
    QM.style.display = 'block';
    OV.style.display = 'block';
    
    QM.querySelectorAll('button').forEach(btn => {
      btn.onclick = (e) => {
        e.stopPropagation();
        if (btn.dataset.accept === 'true') {
          quests.push({
            name: quest.name,
            type: quest.type,
            desc: quest.desc,
            need: quest.need,
            progress: {},
            reward: quest.reward,
            state: 1
          });
          log("Accepted quest: " + quest.name);
        }
        closeQuestPopup();
      };
    });
  }
  
  function acceptQuest(n) {
    const q = n.quest;
    q.state = 1;
    
    let questName = (q.type === 'kill' ? 'K' : 'F') + n.profession;
    let questDesc = '';
    
    if(q.type === 'kill') {
      questDesc = 'Kill ' + Object.entries(q.need).map(([monster, count]) => 
        `${monster.replace(/_/g, ' ')} x${count}`
      ).join(', ');
    } else {
      questDesc = 'Bring ' + Object.entries(q.need).map(e => e.join('x')).join(', ');
    }
    
    if(q.rewardGold) {
      questDesc += ` (Reward: ${q.rewardGold}g)`;
    } else if(q.reward) {
      questDesc += ` (Reward: ${q.reward})`;
    }
    
    quests.push({
      name: questName,
      type: q.type,
      desc: questDesc,
      need: q.need,
      progress: {},
      reward: { item: q.reward, gold: q.rewardGold },
      state: 1
    });
    log("Accepted quest from " + n.profession);
  }
  
  function closeQuestPopup() {
    QM.style.display = 'none';
    OV.style.display = 'none';
  }
  
  function materials(req){
    for(let k in req){
      if((p.inv[k]||0)<req[k]) return false;
    }
    return true;
  }
  
  function equip(nm){
    let def=itemDefs[nm];
    let maxDurability = typeof def.maxD === 'function' ? def.maxD() : def.maxD;
    let d=roll(1,maxDurability);
    p.eq.push({name:nm,durability:d});
    log("Got "+nm+"("+d+")");
  }
  
  function equipItem(item) {
    // Validate item definition exists
    if(!itemDefs[item.name]) {
      log("Error: Unknown item " + item.name);
      return;
    }
    
    // Unequip current item first if any
    if(p.equipped){
      if(itemDefs[p.equipped.name] && itemDefs[p.equipped.name].boost) {
        Object.entries(itemDefs[p.equipped.name].boost).forEach(([stat,value])=>{
          p[stat] = round1(p[stat] - value);
        });
        log("Unequipped " + p.equipped.name);
      }
    }
    
    // Equip new item
    p.equipped = item;
    if(itemDefs[item.name].boost) {
      Object.entries(itemDefs[item.name].boost).forEach(([stat,value])=>{
        p[stat] = round1(p[stat] + value);
      });
    }
    log("Equipped " + item.name);
  }
  
  function unequipItem() {
    if(p.equipped) {
      if(itemDefs[p.equipped.name] && itemDefs[p.equipped.name].boost) {
        Object.entries(itemDefs[p.equipped.name].boost).forEach(([stat,value])=>{
          p[stat] = round1(p[stat] - value);
        });
      }
      log("Unequipped " + p.equipped.name);
      p.equipped = null;
    }
  }
  
  // Modal
  function openModal(html,act){
    OV.style.display='block';
    MD.style.display='block';
    MD.innerHTML=html+"<br><button id='close' style='background:#f44336; color:white; border:none; padding:10px 20px; border-radius:6px; cursor:pointer; font-weight:bold; margin-top:15px; display:block; margin-left:auto; margin-right:auto;'>✕ Close</button>";
    d('#close').onclick=()=>{
      closeModal();
      updateUI();
    };
    if(act) {
      MD.querySelectorAll('button[data-buy],button[data-buyg],button[data-sell],button[data-selleq],button[data-q],button[data-r],button[data-turn],button[data-equip],button[data-unequip],button[data-use-health],button[data-use-strength],button[data-use-rage]').forEach(b=>{
        b.onclick=(e)=>{
          e.preventDefault();
          act(b);
        };
      });
    }
  }
  
  function closeModal(){
    OV.style.display='none';
    MD.style.display='none';
    MD.innerHTML='';
  }
  
  // Bind & init
  document.addEventListener('DOMContentLoaded',()=>{
    ['up','down','left','right'].forEach(dn=>d(`[data-dir="${dn}"]`).onclick=()=>move(dn));
    d('#btn-inv').onclick    = openInventory;
    d('#btn-craft').onclick  = openCraft;
    d('#btn-shop').onclick   = openGlobal;
    d('#btn-quests').onclick = openQuests;
    d('#btn-reborn').onclick = ()=>{
      localStorage.removeItem(SAVE);
      LEl.innerHTML='';
      quests = []; // Clear quests array
      init();
      log("Reborn!");
      updateUI();
    };
    OV.onclick=() => {
      if(QM.style.display === 'block') {
        closeQuestPopup();
      } else {
        closeModal();
      }
    };
    init();
    log("Welcome to Dungeon Quest!");
    updateUI();
  });
})();
</script>
</body>
</html>
