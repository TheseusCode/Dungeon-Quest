<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Dungeon Quest</title>
<style>
  * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: monospace;
  background: linear-gradient(135deg, #0a0f15 0%, #151a20 50%, #0a0f15 100%);
  color: #e8eaed;
  padding: 10px;
  font-size: 14px;
  line-height: 1.4;
  max-width: 100%;
  overflow-x: hidden;
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  gap: 10px;
  transition: all 0.3s ease;
}

#map {
  white-space: pre;
  font-family: monospace;
  font-size: 16px;
  line-height: 1.2;
  background: linear-gradient(145deg, #1a2332, #0f1419);
  border: 1px solid #2a3441;
  box-shadow: 
    inset 0 1px 3px rgba(255, 255, 255, 0.05),
    inset 0 -1px 3px rgba(0, 0, 0, 0.4),
    0 4px 12px rgba(0, 0, 0, 0.5);
  padding: 10px;
  border-radius: 8px;
  overflow-x: auto;
  max-width: 100%;
  transition: box-shadow 0.3s ease;
}

#map:hover {
  box-shadow: 
    inset 0 1px 3px rgba(255, 255, 255, 0.08),
    inset 0 -1px 3px rgba(0, 0, 0, 0.5),
    0 6px 16px rgba(0, 5, 15, 0.6);
}

#content-row {
  display: flex;
  gap: 10px;
  width: 100%;
}

#log {
  flex: 1;
  height: 150px;
  overflow-y: auto;
  background: linear-gradient(145deg, #1a2332, #0f1419);
  border: 1px solid #2a3441;
  box-shadow: 
    inset 0 2px 4px rgba(0, 0, 0, 0.4),
    inset 0 -1px 2px rgba(255, 255, 255, 0.05),
    0 2px 8px rgba(0, 5, 15, 0.4);
  padding: 8px;
  border-radius: 8px;
  transition: all 0.3s ease;
}

#stats {
  flex: 1;
  background: linear-gradient(145deg, #1a2332, #0f1419);
  border: 1px solid #2a3441;
  box-shadow: 
    inset 0 2px 4px rgba(0, 0, 0, 0.4),
    inset 0 -1px 2px rgba(255, 255, 255, 0.05),
    0 2px 8px rgba(0, 5, 15, 0.4);
  padding: 5px;
  border-radius: 8px;
  height: 150px;
  overflow-y: auto;
  transition: all 0.3s ease;
}

.stat-row {
  display: flex;
  justify-content: space-between;
}

.stat-item {
  background: linear-gradient(145deg, #243242, #1a2530);
  border: 1px solid #344250;
  box-shadow: 
    inset 0 1px 2px rgba(255, 255, 255, 0.08),
    inset 0 -1px 2px rgba(0, 0, 0, 0.4),
    0 2px 4px rgba(0, 5, 15, 0.3);
  padding: 5px 8px;
  border-radius: 6px;
  flex: 1;
  text-align: center;
  margin: 0 2px;
  transition: all 0.3s ease;
  color: #e8eaed;
  font-weight: 500;
}

#controls {
  display: flex;
  justify-content: space-between;
  gap: 10px;
  width: 100%;
}

#nav {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: 5px;
  width: 50%;
  margin-right: auto;
  max-width: 200px;
}

.nav-btn {
  font-size: 1em;
  width: 100%;
  aspect-ratio: 1/1;
  background: linear-gradient(145deg, #243242, #1a2530);
  border: 1px solid #344250;
  box-shadow: 
    inset 0 1px 2px rgba(255, 255, 255, 0.08),
    inset 0 -1px 2px rgba(0, 0, 0, 0.4),
    0 3px 6px rgba(0, 5, 15, 0.4);
  color: #e8eaed;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  border-radius: 8px;
  transition: all 0.2s ease;
  font-weight: 600;
  cursor: pointer;
}

.nav-cell {
  visibility: hidden;
}

#actions {
  display: flex;
  flex-direction: column;
  gap: 5px;
  width: 40%;
  margin-left: auto;
}

.act-btn {
  font-size: 0.85em;
  padding: 6px 4px;
  background: linear-gradient(145deg, #243242, #1a2530);
  border: 1px solid #344250;
  box-shadow: 
    inset 0 1px 2px rgba(255, 255, 255, 0.08),
    inset 0 -1px 2px rgba(0, 0, 0, 0.4),
    0 3px 6px rgba(0, 5, 15, 0.4);
  color: #e8eaed;
  text-align: center;
  border-radius: 6px;
  flex: 1;
  transition: all 0.2s ease;
  font-weight: 500;
  cursor: pointer;
}

.nav-btn:hover {
  background: linear-gradient(145deg, #2a3a4a, #1f2d3a);
  box-shadow: 
    inset 0 1px 2px rgba(255, 255, 255, 0.12),
    inset 0 -1px 2px rgba(0, 0, 0, 0.5),
    0 5px 10px rgba(0, 10, 25, 0.5);
  transform: translateY(-2px);
  color: #f0f2f5;
}

.nav-btn:active {
  transform: translateY(0px);
  box-shadow: 
    inset 0 2px 4px rgba(0, 0, 0, 0.4),
    inset 0 -1px 1px rgba(255, 255, 255, 0.05),
    0 1px 3px rgba(0, 0, 0, 0.2);
}

.act-btn:hover {
  background: linear-gradient(145deg, #2a3a4a, #1f2d3a);
  box-shadow: 
    inset 0 1px 2px rgba(255, 255, 255, 0.12),
    inset 0 -1px 2px rgba(0, 0, 0, 0.5),
    0 5px 10px rgba(0, 10, 25, 0.5);
  transform: translateY(-1px);
  color: #f0f2f5;
}

.act-btn:active {
  transform: translateY(0px);
  box-shadow: 
    inset 0 2px 4px rgba(0, 0, 0, 0.4),
    inset 0 -1px 1px rgba(255, 255, 255, 0.05),
    0 1px 3px rgba(0, 0, 0, 0.2);
}

.stat-item:hover {
  background: linear-gradient(145deg, #2a3a4a, #1f2d3a);
  box-shadow: 
    inset 0 1px 2px rgba(255, 255, 255, 0.12),
    inset 0 -1px 2px rgba(0, 0, 0, 0.5),
    0 4px 8px rgba(0, 10, 25, 0.4);
  transform: translateY(-1px);
}

/* Color coding for map elements */
.monster-lvl1 { color: #ff9999; }
.monster-lvl2 { color: #ff6666; }
.monster-lvl3 { color: #ff3333; }
.monster-lvl4 { color: #ff0000; }
.monster-lvl5 { color: #cc0000; }
.monster-lvl6 { color: #990000; }
.monster-lvl7 { color: #660000; }
.monster-lvl8 { color: #aa0000; }
.monster-lvl9 { color: #440000; }
.monster-lvl10 { color: #9b59b6; }
.chest { color: #ffff00; }
.town-npc { color: #55ffff; }
.resource { color: #55ff55; }

/* Modal styles */
.overlay, .modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
}

.overlay {
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(4px);
  z-index: 10;
  transition: opacity 0.3s ease;
}

.modal {
  background: linear-gradient(145deg, #1a2332, #0f1419);
  border: 1px solid #2a3441;
  box-shadow: 
    inset 0 1px 3px rgba(255, 255, 255, 0.08),
    inset 0 -1px 3px rgba(0, 0, 0, 0.4),
    0 20px 40px rgba(0, 5, 15, 0.7);
  width: 90%;
  max-width: 400px;
  max-height: 80vh;
  overflow: auto;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 15px;
  border-radius: 12px;
  z-index: 11;
  transition: all 0.3s ease;
}

/* Quest Modal Styles */
#quest-modal {
  display: none;
}

.quest-options {
  display: flex;
  justify-content: space-between;
  margin-top: 15px;
  gap: 10px;
}

.quest-options button {
  padding: 8px 15px;
  border-radius: 6px;
  border: none;
  flex: 1;
  transition: all 0.2s ease;
  font-weight: 600;
  cursor: pointer;
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
}

.quest-options button:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 10px rgba(0, 0, 0, 0.4);
}

.quest-options button:active {
  transform: translateY(0px);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

.quest-accept {
  background: linear-gradient(145deg, #4CAF50, #45a049);
  color: white;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.quest-accept:hover {
  background: linear-gradient(145deg, #5cbf60, #4CAF50);
}

.quest-decline {
  background: linear-gradient(145deg, #f44336, #da190b);
  color: white;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.quest-decline:hover {
  background: linear-gradient(145deg, #f66356, #f44336);
}

.quest-details {
  margin: 10px 0;
  line-height: 1.6;
}

@media (min-width: 500px) {
  #nav {
    width: 180px;
  }
  
  #actions {
    width: calc(100% - 190px);
  }
  
  .act-btn {
    padding: 10px;
  }
}
</style>
</head>
<body>

<div id="map"></div>
<div id="content-row">
  <div id="log"></div>
  <div id="stats"></div>
</div>

<div id="controls">
  <!-- Nav: plus shape -->
  <div id="nav">
    <div class="nav-cell"></div>
    <button class="nav-btn" data-dir="up">‚Üë</button>
    <div class="nav-cell"></div>

    <button class="nav-btn" data-dir="left">‚Üê</button>
    <div class="nav-cell"></div>
    <button class="nav-btn" data-dir="right">‚Üí</button>

    <div class="nav-cell"></div>
    <button class="nav-btn" data-dir="down">‚Üì</button>
    <div class="nav-cell"></div>
  </div>

  <!-- Actions -->
  <div id="actions">
    <button id="btn-inv" class="act-btn">Inventory</button>
    <button id="btn-craft" class="act-btn">Crafting</button>
    <button id="btn-shop" class="act-btn">Market</button>
    <button id="btn-quests" class="act-btn">Quests</button>
    <button id="btn-npc-quests" class="act-btn">RNPC Quests</button>
    <button id="btn-reborn" class="act-btn">Reborn</button>
  </div>
</div>

<div id="overlay" class="overlay"></div>
<div id="modal" class="modal"></div>
<div id="quest-modal" class="modal"></div>
<div id="welcome-modal" class="modal" style="display: none;">
  <div class="welcome-content">
    <h2 style="text-align: center; color: #e8eaed; margin-bottom: 15px; font-size: 1.5em;">üè∞ Dungeon Quest</h2>
    <p style="text-align: center; color: #c0c4c7; margin-bottom: 20px; line-height: 1.6;">
      Embark on an epic adventure through dangerous dungeons filled with monsters, treasures, and mysteries.<br>
      Battle fierce creatures, collect powerful items, and become the ultimate dungeon explorer!
    </p>
    
    <div class="instructions">
      <h3 style="color: #e8eaed; margin-bottom: 10px; border-bottom: 1px solid #344250; padding-bottom: 5px;">How to Play</h3>
      <ul style="color: #c0c4c7; line-height: 1.6; margin-bottom: 15px;">
        <li><strong>Movement:</strong> Use arrow buttons to navigate through the dungeon</li>
        <li><strong>Combat:</strong> Walk into monsters to engage in automatic battle</li>
        <li><strong>Inventory:</strong> Manage your items and equipment</li>
        <li><strong>Crafting:</strong> Create powerful gear from materials</li>
        <li><strong>Market:</strong> Buy potions and equipment from NPCs</li>
      </ul>
      
      <h3 style="color: #e8eaed; margin-bottom: 10px; border-bottom: 1px solid #344250; padding-bottom: 5px;">Map Legend</h3>
      <ul style="color: #c0c4c7; line-height: 1.6; margin-bottom: 15px;">
        <li><span style="color: #ff9999;">Red symbols:</span> Monsters (darker = stronger)</li>
        <li><span style="color: #ffff00;">Yellow symbols:</span> Treasure chests</li>
        <li><span style="color: #55ffff;">Cyan symbols:</span> Town NPCs and shops</li>
        <li><span style="color: #55ff55;">Green symbols:</span> Resource nodes</li>
      </ul>
      
      <h3 style="color: #e8eaed; margin-bottom: 10px; border-bottom: 1px solid #344250; padding-bottom: 5px;">Monster Scaling & World Bosses</h3>
      <p style="color: #c0c4c7; line-height: 1.6; margin-bottom: 10px;">
        Monsters grow exponentially stronger with each level. Each monster type has 10+ evolution stages,
        from basic creatures to ancient legendary bosses. Higher level monsters provide better rewards!
      </p>
      <p style="color: #c0c4c7; line-height: 1.6; margin-bottom: 15px;">
        <strong>3 World Bosses:</strong> Leviathan, Death Star, and Susano - the ultimate challenges with 15 evolution stages each.
        These legendary beings offer the greatest rewards but require incredible strength to defeat.
      </p>
      
      <h3 style="color: #e8eaed; margin-bottom: 10px; border-bottom: 1px solid #344250; padding-bottom: 5px;">Starting Your Journey</h3>
      <p style="color: #c0c4c7; line-height: 1.6; margin-bottom: 15px;">
        You begin your adventure in the <strong>Town</strong> - a safe haven where you can find shops, NPCs, and prepare for your dungeon expeditions.
        The town serves as your base of operations for buying equipment, potions, and managing your inventory.
      </p>
      
      <h3 style="color: #e8eaed; margin-bottom: 10px; border-bottom: 1px solid #344250; padding-bottom: 5px;">Reborn System</h3>
      <p style="color: #c0c4c7; line-height: 1.6; margin-bottom: 15px;">
        The <strong>Reborn</strong> button allows you to completely reset your character and start fresh from the beginning.
        Use this feature when you want to restart your adventure or if your character dies and you need a fresh start.
      </p>
    </div>
    
    <button id="start-game-btn" style="
      width: 100%; 
      padding: 12px; 
      background: linear-gradient(145deg, #4CAF50, #45a049); 
      border: none; 
      border-radius: 8px; 
      color: white; 
      font-size: 1.1em; 
      font-weight: 600; 
      cursor: pointer; 
      transition: all 0.2s ease;
      box-shadow: 0 4px 8px rgba(0, 5, 15, 0.3);
    ">Start Adventure</button>
    <style>
    #start-game-btn:hover {
      background: linear-gradient(145deg, #5cbf60, #4CAF50) !important;
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0, 5, 15, 0.4) !important;
    }
    #start-game-btn:active {
      transform: translateY(0px);
      box-shadow: 0 2px 4px rgba(0, 5, 15, 0.2) !important;
    }
    </style>
  </div>
</div>

<script>
(() => {
  // Helper function to round to 1 decimal place
  const round1 = num => Math.round(num * 10) / 10;
  
  // Data definitions - expanded monster templates with exponential scaling
  const monsterTpl={
    Goblin: {base:{hp:8,atk:3,def:1,boost:'atk'}, levels:[
      {name:'Goblin',mult:1,reward:0.1},
      {name:'Hobgoblin',mult:2,reward:0.2},
      {name:'Goblin Warrior',mult:4,reward:0.4},
      {name:'Goblin Elite',mult:8,reward:0.8},
      {name:'Goblin Captain',mult:16,reward:1.6},
      {name:'Goblin King',mult:32,reward:3.2},
      {name:'Goblin Warlord',mult:64,reward:6.4},
      {name:'Goblin Overlord',mult:128,reward:12.8},
      {name:'Goblin Emperor',mult:256,reward:25.6},
      {name:'Ancient Goblin',mult:512,reward:51.2}
    ]},
    Skeleton: {base:{hp:12,atk:4,def:2,boost:'def'}, levels:[
      {name:'Skeleton',mult:1,reward:0.1},
      {name:'Skeleton Warrior',mult:2,reward:0.2},
      {name:'Skeleton Soldier',mult:4,reward:0.4},
      {name:'Skeleton Knight',mult:8,reward:0.8},
      {name:'Skeleton Elite',mult:16,reward:1.6},
      {name:'Skeleton Duke',mult:32,reward:3.2},
      {name:'Skeleton King',mult:64,reward:6.4},
      {name:'Skeleton Lord',mult:128,reward:12.8},
      {name:'Skeleton Emperor',mult:256,reward:25.6},
      {name:'Bone Archlich',mult:512,reward:51.2}
    ]},
    Wolf: {base:{hp:15,atk:5,def:3,boost:'maxHp'}, levels:[
      {name:'Wolf',mult:1,reward:0.1},
      {name:'Wild Wolf',mult:2,reward:0.2},
      {name:'Dark Wolf',mult:4,reward:0.4},
      {name:'Dire Wolf',mult:8,reward:0.8},
      {name:'Shadow Wolf',mult:16,reward:1.6},
      {name:'Alpha Wolf',mult:32,reward:3.2},
      {name:'Werewolf',mult:64,reward:6.4},
      {name:'Fenrir Wolf',mult:128,reward:12.8},
      {name:'Demon Wolf',mult:256,reward:25.6},
      {name:'Primordial Wolf',mult:512,reward:51.2}
    ]},
    Orc: {base:{hp:10,atk:6,def:2,boost:'atk'}, levels:[
      {name:'Orc',mult:1,reward:0.1},
      {name:'Orc Scout',mult:2,reward:0.2},
      {name:'Orc Fighter',mult:4,reward:0.4},
      {name:'Orc Berserker',mult:8,reward:0.8},
      {name:'Orc Champion',mult:16,reward:1.6},
      {name:'Orc Warlord',mult:32,reward:3.2},
      {name:'Orc Chieftain',mult:64,reward:6.4},
      {name:'Orc General',mult:128,reward:12.8},
      {name:'Orc Emperor',mult:256,reward:25.6},
      {name:'Orc Destroyer',mult:512,reward:51.2}
    ]},
    Ogre: {base:{hp:12,atk:4,def:4,boost:'maxHp'}, levels:[
      {name:'Ogre',mult:1,reward:0.1},
      {name:'Ogre Brute',mult:2,reward:0.2},
      {name:'Ogre Warrior',mult:4,reward:0.4},
      {name:'Ogre Berserker',mult:8,reward:0.8},
      {name:'Ogre Champion',mult:16,reward:1.6},
      {name:'Ogre Warlord',mult:32,reward:3.2},
      {name:'Ogre King',mult:64,reward:6.4},
      {name:'Ogre Titan',mult:128,reward:12.8},
      {name:'Ogre Colossus',mult:256,reward:25.6},
      {name:'Ancient Ogre',mult:512,reward:51.2}
    ]},
    Gnoll: {base:{hp:9,atk:5,def:3,boost:'def'}, levels:[
      {name:'Gnoll',mult:1,reward:0.1},
      {name:'Gnoll Hunter',mult:2,reward:0.2},
      {name:'Gnoll Warrior',mult:4,reward:0.4},
      {name:'Gnoll Shaman',mult:8,reward:0.8},
      {name:'Gnoll Chieftain',mult:16,reward:1.6},
      {name:'Gnoll Warlord',mult:32,reward:3.2},
      {name:'Gnoll King',mult:64,reward:6.4},
      {name:'Gnoll Packmaster',mult:128,reward:12.8},
      {name:'Gnoll Emperor',mult:256,reward:25.6},
      {name:'Gnoll Demigod',mult:512,reward:51.2}
    ]},
    Wyvern: {base:{hp:10,atk:6,def:5,boost:'atk'}, levels:[
      {name:'Wyvern',mult:1,reward:0.1},
      {name:'Young Wyvern',mult:2,reward:0.2},
      {name:'Adult Wyvern',mult:4,reward:0.4},
      {name:'Elder Wyvern',mult:8,reward:0.8},
      {name:'Wyvern Lord',mult:16,reward:1.6},
      {name:'Wyvern King',mult:32,reward:3.2},
      {name:'Dragon Wyvern',mult:64,reward:6.4},
      {name:'Ancient Wyvern',mult:128,reward:12.8},
      {name:'Primordial Wyvern',mult:256,reward:25.6},
      {name:'Wyvern God',mult:512,reward:51.2}
    ]},
    Leviathan: {base:{hp:12,atk:8,def:6,boost:'atk'}, levels:[
      {name:'Leviathan',mult:1,reward:0.1},
      {name:'Young Leviathan',mult:2,reward:0.2},
      {name:'Adult Leviathan',mult:4,reward:0.4},
      {name:'Elder Leviathan',mult:8,reward:0.8},
      {name:'Leviathan Lord',mult:16,reward:1.6},
      {name:'Leviathan King',mult:32,reward:3.2},
      {name:'Dragon Leviathan',mult:64,reward:6.4},
      {name:'Ancient Leviathan',mult:128,reward:12.8},
      {name:'Primordial Leviathan',mult:256,reward:25.6},
      {name:'Leviathan God',mult:512,reward:51.2},
      {name:'Leviathan Titan',mult:1024,reward:102.4},
      {name:'Leviathan Emperor',mult:2048,reward:204.8},
      {name:'Leviathan Overlord',mult:4096,reward:409.6},
      {name:'Leviathan Destroyer',mult:8192,reward:819.2},
      {name:'Primordial Leviathan God',mult:16384,reward:1638.4}
    ]},
    DeathStar: {base:{hp:15,atk:7,def:8,boost:'def'}, levels:[
      {name:'Death Star',mult:1,reward:0.1},
      {name:'Young Death Star',mult:2,reward:0.2},
      {name:'Adult Death Star',mult:4,reward:0.4},
      {name:'Elder Death Star',mult:8,reward:0.8},
      {name:'Death Star Lord',mult:16,reward:1.6},
      {name:'Death Star King',mult:32,reward:3.2},
      {name:'Dragon Death Star',mult:64,reward:6.4},
      {name:'Ancient Death Star',mult:128,reward:12.8},
      {name:'Primordial Death Star',mult:256,reward:25.6},
      {name:'Death Star God',mult:512,reward:51.2},
      {name:'Death Star Titan',mult:1024,reward:102.4},
      {name:'Death Star Emperor',mult:2048,reward:204.8},
      {name:'Death Star Overlord',mult:4096,reward:409.6},
      {name:'Death Star Destroyer',mult:8192,reward:819.2},
      {name:'Primordial Death Star God',mult:16384,reward:1638.4}
    ]},
    Susano: {base:{hp:18,atk:9,def:7,boost:'maxHp'}, levels:[
      {name:'Susano',mult:1,reward:0.1},
      {name:'Young Susano',mult:2,reward:0.2},
      {name:'Adult Susano',mult:4,reward:0.4},
      {name:'Elder Susano',mult:8,reward:0.8},
      {name:'Susano Lord',mult:16,reward:1.6},
      {name:'Susano King',mult:32,reward:3.2},
      {name:'Dragon Susano',mult:64,reward:6.4},
      {name:'Ancient Susano',mult:128,reward:12.8},
      {name:'Primordial Susano',mult:256,reward:25.6},
      {name:'Susano God',mult:512,reward:51.2},
      {name:'Susano Titan',mult:1024,reward:102.4},
      {name:'Susano Emperor',mult:2048,reward:204.8},
      {name:'Susano Overlord',mult:4096,reward:409.6},
      {name:'Susano Destroyer',mult:8192,reward:819.2},
      {name:'Primordial Susano God',mult:16384,reward:1638.4}
    ]}
  };

  const shops={ 
    'Potion Seller':[
      {name:'Health Potion',price:5,desc:'Restores 10 HP',apply:()=>{p.hp=Math.min(p.maxHp,round1(p.hp+10))}},
      {name:'Strength Potion',price:10,desc:'Temporary attack boost (10-20 ATK for 30-90 steps)',apply:()=>{
        const newValue = roll(10,20);
        const newSteps = roll(30,90);
        applyPotionEffect({atk: newValue, steps: newSteps}, 'Strength Potion');
        updateRealTimeDisplays();
      }},
      {name:'Rage Potion',price:100,desc:'Permanent +0.5 ATK, -5 max HP',apply:()=>{
        p.atk = round1(p.atk + 0.5);
        p.maxHp = Math.max(1, round1(p.maxHp - 5));
        p.hp = Math.min(p.hp, p.maxHp);
        log("Rage Potion: +0.5 ATK, -5 max HP permanently!");
      }},
      {name:'Warrior\'s Elixir',price:30,desc:'Temporary +15 ATK for 50 steps',apply:()=>{
        applyPotionEffect({atk: 15, steps: 50}, 'Warrior\'s Elixir');
        updateRealTimeDisplays();
      }},
      {name:'Guardian Tonic',price:20,desc:'Temporary +20 DEF for 60 steps',apply:()=>{
        applyPotionEffect({def: 20, steps: 60}, 'Guardian Tonic');
        updateRealTimeDisplays();
      }},
      {name:'Master Crafter\'s Brew',price:100,desc:'Temporary +50 craft skill for 50 steps',apply:()=>{
        applyPotionEffect({craft: 50, steps: 50}, 'Master Crafter\'s Brew');
        updateRealTimeDisplays();
      }},
      {name:'Orc\'s Rage',price:175,desc:'Temporary +200 ATK, -50% DEF for 40 steps',apply:()=>{
        p.tempOrcsRage={atkBoost:200,defDebuff:0.5,steps:40};
        log("Orc's Rage: +200 attack, -50% defense for 40 steps!");
      }},
      {name:'Angel\'s Touch',price:250,desc:'Temporary +200 max HP, +100 DEF, -25% ATK for 40 steps',apply:()=>{
        p.tempAngelsTouch={maxHpBoost:200,defBoost:100,atkDebuff:0.75,steps:40};
        p.maxHp = round1(p.maxHp + 200);
        p.hp = round1(p.hp + 200);
        log("Angel's Touch: +200 max HP, +100 defense, -25% attack for 40 steps!");
      }},
      {name:'Dragon Fury',price:500,desc:'Temporary +800 ATK, -70% DEF, -50% max HP for 10 steps',apply:()=>{
        p.tempDragonFury={atkBoost:800,defDebuff:0.3,maxHpDebuff:0.5,steps:10};
        p.maxHp = Math.max(1, round1(p.maxHp * 0.5));
        p.hp = Math.min(p.hp, p.maxHp);
        log("Dragon Fury: +800 attack, -70% defense, -50% max HP for 10 steps!");
      }},
      {name:'God\'s Gift',price:2500,desc:'Temporary +7000 DEF for 5 steps',apply:()=>{
        p.tempGodsGift={defBoost:7000,steps:5};
        log("God's Gift: +7000 defense for 5 steps!");
      }},
      {name:'Berserker\'s Blend',price:50,desc:'Multi-effect: +10 ATK, +10 DEF for 40 steps',apply:()=>{
        applyPotionEffect({atk: 10, def: 10, steps: 40}, 'Berserker\'s Blend');
        updateRealTimeDisplays();
      }},
      {name:'Battle Brew',price:75,desc:'Multi-effect: +12 ATK, +8 DEF, +5 LUCK for 30 steps',apply:()=>{
        applyPotionEffect({atk: 12, def: 8, luck: 5, steps: 30}, 'Battle Brew');
        updateRealTimeDisplays();
      }}
    ], 
    'Blacksmith':[
      {name:'Iron Sword',price:20,desc:'Weapon: +3 ATK',apply:()=>{equip('Iron Sword')}}
    ], 
    'Scroll Merchant':[
      {name:'Scroll of Healing',price:25,desc:'Restores full HP',apply:()=>{p.hp=p.maxHp}},
      {name:'Luck Charm',price:50,desc:'Temporary +20 luck for 30 steps',apply:()=>{applyPotionEffect({luck: 20, steps: 30}, 'Luck Charm');updateRealTimeDisplays();}}
    ]
  };

  const itemDefs={
    'Spear':{boost:{atk:2},maxD:100,level:1},
    'Shield':{boost:{def:3},maxD:100,level:1},
    'Greatsword':{boost:{atk:4},maxD:100,level:1},
    'PlateArmor':{boost:{maxHp:10},maxD:100,level:1},
    'Iron Sword':{boost:{atk:3},maxD:100,level:1},
    'Skeleton_King_Bone':{boost:{def:1},maxD:50,level:1},
    'Dire_Wolf_Pelt':{boost:{maxHp:5},maxD:50,level:1},
    // Level 10 special items
    'Ancient_Goblin_Crown':{boost:{atk:250,def:100},maxD:200,value:200,level:1},
    'Bone_Archlich_Staff':{boost:{atk:400},maxD:200,value:200,level:1},
    'Primordial_Wolf_Fang':{boost:{atk:300,maxHp:400},maxD:200,value:200,level:1},
    'Orc_Destroyer_Axe':{boost:{atk:500},maxD:200,value:200,level:1},
    'Ancient_Ogre_Club':{boost:{atk:350,maxHp:750},maxD:200,value:200,level:1},
    'Gnoll_Demigod_Spear':{boost:{atk:450,def:150},maxD:200,value:200,level:1},
    'Wyvern_God_Scale':{boost:{atk:600,def:250,maxHp:500},maxD:200,value:200,level:1},
    // Ultimate legendary weapon
    'Apex_Predator':{boost:{atk:800,def:800,maxHp:1200},maxD:100,value:1000,level:1},
    // New ultimate weapon
    'Broken_Stick':{boost:{atk:50000},maxD:5,value:0,level:1,unsellable:true},
    // Level 15 boss weapons - cannot be sold
    'Tidepiercer':{boost:{atk:1000,def:400},maxD:100,value:0,level:1,unsellable:true},
    'Nova_Maul':{boost:{atk:600,maxHp:1000,def:200},maxD:100,value:0,level:1,unsellable:true},
    'Stormfang_Katana':{boost:{atk:2000,def:1000},maxD:100,value:0,level:1,unsellable:true},
    // New weapons with random durability
    'Shadowstrike_Blade':{boost:{atk:6,def:1},maxD:()=>roll(40,100),value:150,level:1},
    'Thundercaller_Hammer':{boost:{atk:8,maxHp:5},maxD:()=>roll(40,100),value:180,level:1},
    'Voidreaper_Scythe':{boost:{atk:10},maxD:()=>roll(40,100),value:200,level:1},
    'Dragonbane_Spear':{boost:{atk:5,def:4},maxD:()=>roll(40,100),value:160,level:1},
    'Soulrender_Axe':{boost:{atk:7,maxHp:3},maxD:()=>roll(40,100),value:170,level:1},
    // New crafted equipment
    'Scale_Dagger':{boost:{atk:4},maxD:()=>roll(40,100),value:120,level:1},
    'Hide_Shield':{boost:{def:7},maxD:()=>roll(40,100),value:200,level:1},
    'Wild_Cape':{boost:{atk:5,def:5,maxHp:-15},maxD:()=>roll(40,100),value:250,level:1},
    // Random NPC Quest Reward Equipment
    // Low Level Equipment (Level 1-3 monsters)
    'Rusty_Dagger':{boost:{atk:2},maxD:50,level:1},
    'Leather_Gloves':{boost:{atk:2,def:2},maxD:40,level:1},
    'Iron_Boots':{boost:{def:3},maxD:50,level:1},
    'Steel_Helm':{boost:{def:2,maxHp:5},maxD:50,level:1},
    'Hunter_Bow':{boost:{atk:3},maxD:50,level:1},
    // Mid Level Equipment (Level 4-6 monsters)
    'Chain_Mail':{boost:{def:4,maxHp:8},maxD:80,level:1},
    'Battle_Axe':{boost:{atk:20},maxD:50,level:1},
    'Magic_Ring':{boost:{atk:22,def:15,maxHp:10},maxD:30,level:1},
    'Enchanted_Blade':{boost:{atk:27},maxD:50,level:1},
    'Guardian_Shield':{boost:{def:28},maxD:40,level:1},
    'Shadow_Boots':{boost:{atk:25,def:22},maxD:50,level:1},
    // High Level Equipment (Level 7-9 monsters)
    'Dragon_Scale_Armor':{boost:{def:76,maxHp:72},maxD:60,level:1},
    'Mystic_Cloak':{boost:{maxHp:80,def:45},maxD:60,level:1},
    'Warrior_Gauntlets':{boost:{atk:90},maxD:50,level:1},
    'Crystal_Amulet':{boost:{atk:5,def:2,maxHp:7},maxD:80,level:1},
    'Ice_Staff':{boost:{atk:99},maxD:50,level:1},
    'Fire_Sword':{boost:{atk:88,maxHp:30},maxD:50,level:1},
    'Lightning_Spear':{boost:{atk:99},maxD:50,level:1},
    'Ancient_Relic':{boost:{atk:96,def:96,maxHp:115},maxD:90,level:1},
    'Demon_Blade':{boost:{atk:150},maxD:50,level:1},
    // New consumables
    'Resurrection_Charm':{consumable:true,desc:'One-time reborn with all stats intact when you die',level:1},
    'Asura_Blood':{consumable:true,desc:'100x all stats for 100 steps, then 75% stat reduction for 50 steps',level:1}
  };

  const recipes=[
    {name:'Health Potion',need:{Herb:1,Bottle:1}},
    {name:'Strength Potion',need:{Herb:2}},
    {name:'Scroll of Healing',need:{Paper:1,Herb:1}},
    {name:'Iron Ingot',need:{'Iron Ore':2,Coal:1}},
    {name:'Iron Sword',need:{'Iron Ingot':1,Wood:2}},
    {name:'Shadowstrike_Blade',need:{'Iron Ingot':2,'Skeleton_Bone':1,Wood:1}},
    {name:'Thundercaller_Hammer',need:{'Iron Ingot':3,Coal:2}},
    {name:'Voidreaper_Scythe',need:{'Iron Ingot':2,'Orc_Tusk':1,Wood:2}},
    {name:'Dragonbane_Spear',need:{'Iron Ingot':1,'Wolf_Pelt':1,Wood:3}},
    {name:'Soulrender_Axe',need:{'Iron Ingot':2,'Gnoll_Claw':1,Wood:1}},
    {name:'Scale_Dagger',need:{'Wyvern_Scale':2,'Skeleton_Bone':2}},
    {name:'Hide_Shield',need:{'Orc_Tusk':5,'Ogre_Hide':1,'Skeleton_Bone':10}},
    {name:'Wild_Cape',need:{'Ogre_Hide':5,'Goblin_Ear':2,'Wolf_Pelt':4}},
    {name:'Apex_Predator',need:{'Ancient_Goblin_Crown':1,'Bone_Archlich_Staff':1,'Primordial_Wolf_Fang':1,'Orc_Destroyer_Axe':1,'Ancient_Ogre_Club':1,'Gnoll_Demigod_Spear':1,'Wyvern_God_Scale':1},anyFourOf:true},
    {name:'Broken_Stick',need:{'Apex_Predator':1,'Tidepiercer':1,'Nova_Maul':1,'Stormfang_Katana':1}}
  ];

  const npcProfs=['Hunter','Herbalist','Miner','Scout','Mercenary'];
  
  const fetchTpl={ 
    Hunter:{need:{Wolf_Pelt:3},reward:'Spear'}, 
    Herbalist:{need:{Herb:3},reward:'PlateArmor'}, 
    Miner:{need:{'Iron Ore':2},reward:'Greatsword'}, 
    Scout:{need:{Wood:3},reward:'Shield'},
    Mercenary:{need:{Goblin_Ear:2},reward:'Iron Sword'}
  };

  const townQuests={ 
    easy:[
      {name:'Help Herbalist',type:'fetch',desc:'Bring 2 Herbs',need:{Herb:2},reward:{gold:20}},
      {name:'Wolf Pelt',type:'fetch',desc:'Bring 1 Wolf Pelt',need:{Wolf_Pelt:1},reward:{gold:30}},
      {name:'Orc Tusks',type:'fetch',desc:'Bring 2 Orc Tusks',need:{Orc_Tusk:2},reward:{gold:40}},
      {name:'Gnoll Claws',type:'fetch',desc:'Bring 1 Gnoll Claw',need:{Gnoll_Claw:1},reward:{gold:36}}
    ], 
    med:[
      {name:'Slay Goblins',type:'kill',desc:'Defeat 3 Goblins',need:{Goblin:3},reward:{gold:30}},
      {name:'Skeleton Bones',type:'fetch',desc:'Bring 2 Skeleton Bones',need:{Skeleton_Bone:2},reward:{gold:40}},
      {name:'Orc Hunt',type:'kill',desc:'Defeat 2 Orcs',need:{Orc:2},reward:{gold:50}},
      {name:'Ogre Challenge',type:'kill',desc:'Defeat 1 Ogre',need:{Ogre:1},reward:{gold:60}}
    ], 
    hard:[
      {name:'Defeat Skeletons',type:'kill',desc:'Defeat 2 Skeleton Soldiers',need:{Skeleton_Soldier:2},reward:{gold:50}},
      {name:'Hob Goblin Challenge',type:'kill',desc:'Defeat 1 Hobgoblin',need:{Hobgoblin:1},reward:{gold:60}},
      {name:'Wyvern Hunt',type:'kill',desc:'Defeat 1 Wyvern',need:{Wyvern:1},reward:{gold:80}},
      {name:'Gnoll Pack',type:'kill',desc:'Defeat 3 Gnoll Hunters',need:{Gnoll_Hunter:3},reward:{gold:90}}
    ],
    elite:[
      {name:'Goblin King',type:'kill',desc:'Defeat the Goblin King',need:{Goblin_King:1},reward:{gold:100}},
      {name:'Skeleton Duke',type:'kill',desc:'Defeat a Skeleton Duke',need:{Skeleton_Duke:1},reward:{gold:120}},
      {name:'Orc Warlord',type:'kill',desc:'Defeat an Orc Warlord',need:{Orc_Warlord:1},reward:{gold:140}},
      {name:'Elder Wyvern',type:'kill',desc:'Defeat an Elder Wyvern',need:{Elder_Wyvern:1},reward:{gold:160}}
    ],
    legendary:[
      {name:'Ancient Goblin',type:'kill',desc:'Defeat the Ancient Goblin',need:{Ancient_Goblin:1},reward:{gold:5000}},
      {name:'Bone Archlich',type:'kill',desc:'Defeat the Bone Archlich',need:{Bone_Archlich:1},reward:{gold:5000}},
      {name:'Primordial Wolf',type:'kill',desc:'Defeat the Primordial Wolf',need:{Primordial_Wolf:1},reward:{gold:5000}},
      {name:'Orc Destroyer',type:'kill',desc:'Defeat the Orc Destroyer',need:{Orc_Destroyer:1},reward:{gold:5000}},
      {name:'Ancient Ogre',type:'kill',desc:'Defeat the Ancient Ogre',need:{Ancient_Ogre:1},reward:{gold:5000}},
      {name:'Gnoll Demigod',type:'kill',desc:'Defeat the Gnoll Demigod',need:{Gnoll_Demigod:1},reward:{gold:5000}},
      {name:'Wyvern God',type:'kill',desc:'Defeat the Wyvern God',need:{Wyvern_God:1},reward:{gold:5000}},
      {name:'Leviathan Boss',type:'kill',desc:'Defeat the Level 15 Leviathan',need:{Leviathan:1},reward:{gold:100000}},
      {name:'DeathStar Boss',type:'kill',desc:'Defeat the Level 15 DeathStar',need:{DeathStar:1},reward:{gold:100000}},
      {name:'Susano Boss',type:'kill',desc:'Defeat the Level 15 Susano',need:{Susano:1},reward:{gold:100000}}
    ]
  };

  // 20 Random NPC Kill Quests - Organized by distance tiers matching monster spawning logic
  const randomNpcQuests = [
    // EASY TIER (Distance ‚â§ 3): Level 1-2 monsters, F-D tier equipment
    {name:'Goblin Menace',type:'kill',desc:'Kill 3 Goblins',need:{Goblin:3},reward:'Rusty_Dagger',consumableChance:0.2},
    {name:'Wolf Pack',type:'kill',desc:'Kill 2 Wolves',need:{Wolf:2},reward:'Leather_Gloves',consumableChance:0.2},
    {name:'Skeleton Guard',type:'kill',desc:'Kill 2 Skeletons',need:{Skeleton:2},reward:'Iron_Boots',consumableChance:0.2},
    {name:'Orc Scouts',type:'kill',desc:'Kill 1 Orc',need:{Orc:1},reward:'Steel_Helm',consumableChance:0.2},
    {name:'Hobgoblin Hunt',type:'kill',desc:'Kill 1 Hobgoblin',need:{Hobgoblin:1},reward:'Hunter_Bow',consumableChance:0.2},
    
    // MEDIUM TIER (Distance 4-8): Level 2-4 monsters, C-B tier equipment
    {name:'Orc War Party',type:'kill',desc:'Kill 2 Orcs',need:{Orc:2},reward:'Chain_Mail',consumableChance:0.2},
    {name:'Skeleton Warriors',type:'kill',desc:'Kill 2 Skeleton Warriors',need:{'Skeleton Warrior':2},reward:'Battle_Axe',consumableChance:0.2},
    {name:'Wild Wolf Pack',type:'kill',desc:'Kill 2 Wild Wolves',need:{'Wild Wolf':2},reward:'Magic_Ring',consumableChance:0.2},
    {name:'Goblin Warriors',type:'kill',desc:'Kill 1 Goblin Warrior',need:{'Goblin Warrior':1},reward:'Enchanted_Blade',consumableChance:0.2},
    {name:'Gnoll Hunters',type:'kill',desc:'Kill 1 Gnoll',need:{Gnoll:1},reward:'Guardian_Shield',consumableChance:0.2},
    
    // HARD TIER (Distance 9-16): Level 3-7 monsters, B-A tier equipment
    {name:'Ogre Domination',type:'kill',desc:'Kill 1 Ogre',need:{Ogre:1},reward:'Shadow_Boots',consumableChance:0.2},
    {name:'Dark Wolf Alpha',type:'kill',desc:'Kill 1 Dark Wolf',need:{'Dark Wolf':1},reward:'Mystic_Cloak',consumableChance:0.2},
    {name:'Skeleton Soldiers',type:'kill',desc:'Kill 2 Skeleton Soldiers',need:{'Skeleton Soldier':2},reward:'Crystal_Amulet',consumableChance:0.2},
    {name:'Gnoll Warband',type:'kill',desc:'Kill 2 Gnolls',need:{Gnoll:2},reward:'Warrior_Gauntlets',consumableChance:0.2},
    {name:'Orc Berserkers',type:'kill',desc:'Kill 1 Orc Berserker',need:{'Orc Berserker':1},reward:'Dragon_Scale_Armor',consumableChance:0.2},
    
    // ELITE TIER (Distance 17+): Level 6-10 monsters, A-S tier equipment
    {name:'Dire Wolf Hunt',type:'kill',desc:'Kill 1 Dire Wolf',need:{'Dire Wolf':1},reward:'Fire_Sword',consumableChance:0.2},
    {name:'Goblin Elite',type:'kill',desc:'Kill 1 Goblin Elite',need:{'Goblin Elite':1},reward:'Ice_Staff',consumableChance:0.2},
    {name:'Skeleton Knights',type:'kill',desc:'Kill 1 Skeleton Knight',need:{'Skeleton Knight':1},reward:'Lightning_Spear',consumableChance:0.2},
    {name:'Ogre Brutes',type:'kill',desc:'Kill 1 Ogre Brute',need:{'Ogre Brute':1},reward:'Demon_Blade',consumableChance:0.2},
    {name:'Orc Scout',type:'kill',desc:'Kill 1 Orc Scout',need:{'Orc Scout':1},reward:'Ancient_Relic',consumableChance:0.2}
  ];
  
  // State - changed to 1024x1024 map (64x64 areas of 16x16 tiles)
  const AREA=16,GRID_W=16,GRID_H=16,TOWN=32,SIZE=1024,SAVE='dqSave';
  let p,world,quests=[],randomNpcActiveQuests=[];
  let isQuestPopupOpen = false; // Track if quest popup is currently open
  const d=s=>document.querySelector(s),dA=s=>document.querySelectorAll(s),
        SEl=d('#stats'),MEl=d('#map'),LEl=d('#log'),OV=d('#overlay'),MD=d('#modal'),
        QM=d('#quest-modal');
  
  function roll(a,b){return Math.floor(Math.random()*(b-a+1))+a;}
  
  // Lazy loading function for world areas
  function ensureWorldArea(areaX, areaY) {
    if (areaX < 0 || areaX >= 64 || areaY < 0 || areaY >= 64) return null;
    
    // Double-check that world array exists and has the right structure
    if (!world || !world[areaY]) {
      console.error(`World structure invalid at (${areaX}, ${areaY})`);
      return null;
    }
    
    if (!world[areaY][areaX]) {
      try {
        world[areaY][areaX] = gen(areaX === TOWN && areaY === TOWN, areaX, areaY);
        // Debug logging for area generation
        if (areaX !== TOWN || areaY !== TOWN) {
          console.log(`Generated area (${areaX}, ${areaY}) lazily`);
        }
      } catch (error) {
        console.error(`Error generating area (${areaX}, ${areaY}):`, error);
        return null;
      }
    }
    return world[areaY][areaX];
  }
  
  function init(){
    const s=localStorage.getItem(SAVE);
    if(s) try{ 
      let o=JSON.parse(s); 
      p=o.player; 
      // Validate and ensure all numeric values are properly typed and rounded
      p.atk = Number(p.atk) ? round1(p.atk) : roll(1,8);
      p.def = Number(p.def) ? round1(p.def) : roll(1,8);
      p.luck = Number(p.luck) ? round1(p.luck) : roll(1,8);
      p.maxHp = Number(p.maxHp) ? round1(p.maxHp) : 20;
      p.hp = Number(p.hp) ? round1(p.hp) : p.maxHp;
      p.craft = Number(p.craft) ? round1(p.craft) : 0;
      // Fix gold to ensure it's always a number
      p.g = Number(p.g) || 0;
      // Initialize missing temporary effects with validation
      p.tempAtk = p.tempAtk && p.tempAtk.steps > 0 ? p.tempAtk : null;
      p.tempDef = p.tempDef && p.tempDef.steps > 0 ? p.tempDef : null;
      p.tempLuck = p.tempLuck && p.tempLuck.steps > 0 ? p.tempLuck : null;
      p.tempCraft = p.tempCraft && p.tempCraft.steps > 0 ? p.tempCraft : null;
      // Track current area for refresh system
      p.currentArea = p.currentArea || {x: TOWN, y: TOWN};
      // Initialize banking system with validation
      p.bankGold = Number(p.bankGold) || 0;
      p.bankDeaths = Number(p.bankDeaths) || 0;
      // Validate arrays
      quests=Array.isArray(o.quests) ? o.quests : [];
      randomNpcActiveQuests=Array.isArray(o.randomNpcActiveQuests) ? o.randomNpcActiveQuests : [];
    }catch{localStorage.removeItem(SAVE);return init();}
    else p={
      x:TOWN*AREA+8,
      y:TOWN*AREA+8,
      maxHp:20,
      hp:20,
      atk:roll(1,8),
      def:roll(1,8),
      luck:roll(1,8),
      g:0,
      inv:{},
      eq:[],
      craft:0,
      equipped:null,
      tempAtk:null,
      tempLuck:null,
      tempDef:null,
      tempCraft:null,
      steps:0,
      kills:{},
      preventFlee:0,
      bankGold:0,
      bankDeaths:0,
      currentArea: {x: TOWN, y: TOWN}
    };
    // Initialize world as empty 64x64 array for lazy loading
    world=Array.from({length:64},()=>Array.from({length:64},()=>null));
    
    // Only generate the town area initially (where player starts)
    world[TOWN][TOWN] = gen(true, TOWN, TOWN);
    
    save();
  }
  
  function save(){
    // Validate and round all numeric values before saving
    const saveData = {
      player: {
        ...p,
        atk: Number(p.atk) ? round1(p.atk) : 1,
        def: Number(p.def) ? round1(p.def) : 1,
        luck: Number(p.luck) ? round1(p.luck) : 1,
        maxHp: Number(p.maxHp) ? round1(p.maxHp) : 20,
        hp: Number(p.hp) ? round1(p.hp) : 20,
        craft: Number(p.craft) ? round1(p.craft) : 0,
        g: Number(p.g) || 0,
        bankGold: Number(p.bankGold) || 0,
        bankDeaths: Number(p.bankDeaths) || 0
      },
      quests: Array.isArray(quests) ? quests : [],
      randomNpcActiveQuests: Array.isArray(randomNpcActiveQuests) ? randomNpcActiveQuests : []
    };
    try {
      localStorage.setItem(SAVE,JSON.stringify(saveData));
    } catch(e) {
      log("Error saving game data. Storage may be full.");
    }
  }

  // Random NPC Quest System Functions - Uses same distance logic as monster spawning
  function getRandomNpcQuest(distFromTown, areaX, areaY) {
    // Use the same distance calculation as monster spawning for consistency
    const euclideanDistance = Math.sqrt(Math.pow(areaX-TOWN,2) + Math.pow(areaY-TOWN,2));
    
    // Apply the same area-based logic as monster spawning to quest tiers
    let questTier;
    if (euclideanDistance <= 3) {
      // Adjacent areas: Easy quests (Level 1-2 monsters)
      questTier = 'easy';
    } else if (euclideanDistance <= 8) {
      // Nearby areas: Easy to Medium quests (Level 1-4 monsters)
      questTier = Math.random() < 0.6 ? 'easy' : 'medium';
    } else if (euclideanDistance <= 16) {
      // Mid-distance: Medium to Hard quests (Level 3-7 monsters)
      questTier = Math.random() < 0.5 ? 'medium' : 'hard';
    } else if (euclideanDistance <= 24) {
      // Far areas: Hard to Elite quests (Level 6-10 monsters)
      questTier = Math.random() < 0.4 ? 'hard' : 'elite';
    } else {
      // Outermost areas: Elite quests only (Level 8-10 monsters)
      questTier = 'elite';
    }
    
    // Filter quests by calculated tier
    const questsByTier = {
      easy: randomNpcQuests.slice(0, 5),     // First 5 quests (indices 0-4)
      medium: randomNpcQuests.slice(5, 10),  // Next 5 quests (indices 5-9)
      hard: randomNpcQuests.slice(10, 15),   // Next 5 quests (indices 10-14)
      elite: randomNpcQuests.slice(15, 20)   // Last 5 quests (indices 15-19)
    };
    
    const availableQuests = questsByTier[questTier];
    return availableQuests[roll(0, availableQuests.length - 1)];
  }

  function generateRandomNpcQuest(npcId, areaX, areaY) {
    const distFromTown = Math.abs(areaX - TOWN) + Math.abs(areaY - TOWN);
    const questTemplate = getRandomNpcQuest(distFromTown, areaX, areaY);
    
    // 20% chance for consumable reward instead of equipment
    const isConsumable = Math.random() < questTemplate.consumableChance;
    const reward = isConsumable ? (Math.random() < 0.5 ? 'Scroll of Healing' : 'Strength Potion') : questTemplate.reward;
    
    return {
      id: npcId,
      name: questTemplate.name,
      type: questTemplate.type,
      desc: questTemplate.desc,
      need: {...questTemplate.need},
      progress: Object.keys(questTemplate.need).reduce((acc, key) => {acc[key] = 0; return acc;}, {}),
      reward: reward,
      isConsumable: isConsumable,
      areaX: areaX,
      areaY: areaY,
      equipLevel: questTemplate.equipLevel,
      completed: false
    };
  }

  function spawnRandomNpcs(areaX, areaY) {
    // Skip town area
    if (areaX === TOWN && areaY === TOWN) return [];
    
    const npcs = [];
    const npcNames = ['Wanderer', 'Merchant', 'Scout', 'Traveler', 'Adventurer', 'Explorer', 'Hunter', 'Trader'];
    
    // Generate 2 NPCs per area
    for (let i = 0; i < 2; i++) {
      const npcName = npcNames[roll(0, npcNames.length - 1)] + ` ${String.fromCharCode(65 + roll(0, 25))}`;
      // Generate unique ID with timestamp to ensure RNPCs refresh when areas are regenerated
      const npcId = `${areaX}_${areaY}_${i}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
      
      // Always generate new quest for fresh RNPCs when area refreshes
      const quest = generateRandomNpcQuest(npcId, areaX, areaY);
      npcs.push({
        name: npcName,
        symbol: 'N',
        quest: quest
      });
    }
    
    return npcs;
  }

  function acceptRandomNpcQuest(quest) {
    // Initialize quest progress counters to 0 for kill quests
    if (quest.type === 'kill') {
      quest.progress = {};
      Object.keys(quest.need).forEach(monster => {
        quest.progress[monster] = 0;
      });
    }
    
    // Add quest to active quests
    randomNpcActiveQuests.push(quest);
    log(`Accepted quest: ${quest.name}`);
    log(`${quest.desc}`);
    save();
  }

  function checkQuestCompletion() {
    let completedQuests = [];
    
    randomNpcActiveQuests.forEach(quest => {
      if (quest.completed) return;
      
      let canComplete = true;
      Object.entries(quest.need).forEach(([item, needed]) => {
        const have = quest.type === 'kill' ? (quest.progress[item] || 0) : (p.inv[item] || 0);
        // Don't overwrite progress, just check if requirement is met
        if (have < needed) canComplete = false;
      });
      
      if (canComplete) {
        // Remove required items for fetch quests
        if (quest.type === 'fetch') {
          Object.entries(quest.need).forEach(([item, needed]) => {
            p.inv[item] = (p.inv[item] || 0) - needed;
            if (p.inv[item] <= 0) delete p.inv[item];
          });
        }
        
        // Give reward
        if (quest.isConsumable) {
          if (quest.reward === 'Scroll of Healing') {
            // Add to inventory instead of using immediately
            p.inv['Scroll of Healing'] = (p.inv['Scroll of Healing'] || 0) + 1;
            log(`Completed ${quest.name}! Received: Scroll of Healing`);
          } else if (quest.reward === 'Strength Potion') {
            // Add to inventory instead of using immediately
            p.inv['Strength Potion'] = (p.inv['Strength Potion'] || 0) + 1;
            log(`Completed ${quest.name}! Received: Strength Potion`);
          }
        } else {
          // Equipment reward with level scaling
          const itemData = itemDefs[quest.reward];
          if (itemData) {
            const durability = typeof itemData.maxD === 'function' ? itemData.maxD() : itemData.maxD;
            
            // Calculate equipment level based on area-based quest requirements or distance from town
            let equipmentLevel = itemData.level || 1;
            
            // First check if this quest has a specific equipment level requirement
            if (quest.equipLevel) {
              equipmentLevel = quest.equipLevel;
            } else {
              // Fall back to distance-based scaling for areas 50-60
              const questDistance = Math.abs(quest.areaX - TOWN) + Math.abs(quest.areaY - TOWN);
              if (questDistance >= 18) { // Areas 50-60 (town is at 32, so distance 18+ is around areas 50+)
                equipmentLevel = Math.min(6, Math.max(3, Math.floor(questDistance / 6) + 1));
              }
            }
            
            // Use base stats without scaling multipliers
            p.eq.push({
              name: quest.reward,
              durability: durability,
              level: equipmentLevel,
              boost: itemData.boost
            });
            log(`Completed ${quest.name}! Received: ${quest.reward.replace(/_/g, ' ')} Level ${equipmentLevel}`);
          }
        }
        
        quest.completed = true;
        completedQuests.push(quest);
      }
    });
    
    // Remove completed quests
    randomNpcActiveQuests = randomNpcActiveQuests.filter(q => !q.completed);
    
    if (completedQuests.length > 0) {
      save();
      updateUI();
    } else {
      log("No completed quests to turn in.");
    }
  }

  function turnInQuestToNpc(questId) {
    const quest = randomNpcActiveQuests.find(q => q.id === questId);
    if (!quest) {
      log("Quest not found!");
      return;
    }
    
    let canComplete = true;
    Object.entries(quest.need).forEach(([item, needed]) => {
      const have = quest.type === 'kill' ? (quest.progress[item] || 0) : (p.inv[item] || 0);
      if (have < needed) canComplete = false;
    });
    
    if (!canComplete) {
      log("Quest requirements not met!");
      return;
    }
    
    // Remove required items for fetch quests
    if (quest.type === 'fetch') {
      Object.entries(quest.need).forEach(([item, needed]) => {
        p.inv[item] = (p.inv[item] || 0) - needed;
        if (p.inv[item] <= 0) delete p.inv[item];
      });
    }
    
    // Give reward
    if (quest.isConsumable) {
      if (quest.reward === 'Scroll of Healing') {
        p.inv['Scroll of Healing'] = (p.inv['Scroll of Healing'] || 0) + 1;
        log(`Completed ${quest.name}! Received: Scroll of Healing`);
      } else if (quest.reward === 'Strength Potion') {
        p.inv['Strength Potion'] = (p.inv['Strength Potion'] || 0) + 1;
        log(`Completed ${quest.name}! Received: Strength Potion`);
      }
    } else {
      // Equipment reward with level scaling for areas 50-60
      const itemData = itemDefs[quest.reward];
      if (itemData) {
        const durability = typeof itemData.maxD === 'function' ? itemData.maxD() : itemData.maxD;
        
        // Calculate equipment level based on distance from town for areas 50-60
        let equipmentLevel = itemData.level || 1;
        const questDistance = Math.abs(quest.areaX - TOWN) + Math.abs(quest.areaY - TOWN);
        
        if (questDistance >= 18) { // Areas 50-60 (town is at 32, so distance 18+ is around areas 50+)
          equipmentLevel = Math.min(6, Math.max(3, Math.floor(questDistance / 6) + 1));
        }
        
        // Use base stats without scaling multipliers
        p.eq.push({
          name: quest.reward,
          durability: durability,
          level: equipmentLevel,
          boost: itemData.boost
        });
        log(`Completed ${quest.name}! Received: ${quest.reward.replace(/_/g, ' ')} Level ${equipmentLevel}`);
      }
    }
    
    // Mark quest as completed and remove from active quests
    quest.completed = true;
    randomNpcActiveQuests = randomNpcActiveQuests.filter(q => q.id !== questId);
    
    save();
    updateUI();
  }

  function showRandomNpcQuestDialog(npc) {
    const quest = npc.quest;
    if (!quest) {
      log(`${npc.name || 'NPC'}: I have no quests for you right now.`);
      return;
    }
    
    if (quest.completed) {
      log(`${npc.name || 'NPC'}: Thank you for completing my quest!`);
      return;
    }
    
    // Check if quest is already accepted
    const acceptedQuest = randomNpcActiveQuests.find(q => q.id === quest.id);
    
    if (acceptedQuest) {
      // Check if quest can be completed
      let canComplete = true;
      let progressText = `${npc.name || 'NPC'}: "${quest.desc}"\n\nProgress:\n`;
      
      Object.entries(quest.need).forEach(([item, needed]) => {
        const have = quest.type === 'kill' ? (quest.progress[item] || 0) : (p.inv[item] || 0);
        const current = Math.min(have, needed);
        progressText += `${item.replace(/_/g, ' ')}: ${current}/${needed}\n`;
        if (current < needed) canComplete = false;
      });
      
      if (canComplete) {
        const rewardText = quest.isConsumable ? 
          (quest.reward === 'Scroll of Healing' ? 'Scroll of Healing' : 'Strength Potion') :
          quest.reward.replace(/_/g, ' ');
        
        progressText += `\n‚úì Quest Complete! Click to turn in for reward: ${rewardText}`;
        
        // Show turn-in dialog
        showTurnInDialog(npc, acceptedQuest);
      } else {
        log(progressText);
      }
    } else {
      // Show quest offer
      const rewardText = quest.isConsumable ? 
        (quest.reward === 'Scroll of Healing' ? 'Full Health Restoration' : 'Strength Potion') :
        quest.reward.replace(/_/g, ' ');
      
      d('#overlay').style.display = 'block';
      d('#quest-modal').style.display = 'block';
      d('#quest-modal').innerHTML = `
        <div style="background: linear-gradient(145deg, #1a2332, #0f1419); border: 2px solid #2a3441; border-radius: 12px; padding: 20px; max-width: 500px; margin: 10% auto; color: #e8eaed; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);">
          <h3 style="margin: 0 0 15px 0; text-align: center; color: #4CAF50; font-size: 1.3em;">Quest Offer</h3>
          <div style="margin-bottom: 15px;">
            <div style="font-weight: bold; color: #64B5F6; margin-bottom: 8px;">${npc.name || 'NPC'}</div>
            <div style="font-style: italic; color: #FFD54F; margin-bottom: 8px; font-size: 1.1em;">"${quest.name}"</div>
            <div style="margin-bottom: 12px; line-height: 1.4;">${quest.desc}</div>
            <div style="background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50; border-radius: 6px; padding: 8px; margin-bottom: 15px;">
              <strong style="color: #4CAF50;">Reward:</strong> ${rewardText}
            </div>
          </div>
          <div style="text-align: center; gap: 10px; display: flex; justify-content: center;">
            <button class="act-btn" onclick="acceptQuestOffer('${quest.id}')" style="background: linear-gradient(145deg, #2E7D32, #1B5E20); border: 1px solid #4CAF50; color: white; padding: 8px 16px; margin: 0 5px;">Accept</button>
            <button class="act-btn" onclick="closeRandomQuestPopup()" style="background: linear-gradient(145deg, #D32F2F, #B71C1C); border: 1px solid #F44336; color: white; padding: 8px 16px; margin: 0 5px;">Decline</button>
          </div>
        </div>
      `;
    }
  }

  function closeRandomQuestPopup() {
    d('#overlay').style.display = 'none';
    d('#quest-modal').style.display = 'none';
  }
  
  window.closeRandomQuestPopup = closeRandomQuestPopup;

  function showTurnInDialog(npc, quest) {
    const rewardText = quest.isConsumable ? 
      (quest.reward === 'Scroll of Healing' ? 'Scroll of Healing' : 'Strength Potion') :
      quest.reward.replace(/_/g, ' ');
    
    d('#overlay').style.display = 'block';
    d('#quest-modal').style.display = 'block';
    d('#quest-modal').innerHTML = `
      <div style="background: linear-gradient(145deg, #1a2332, #0f1419); border: 2px solid #4CAF50; border-radius: 12px; padding: 20px; max-width: 500px; margin: 10% auto; color: #e8eaed; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);">
        <h3 style="margin: 0 0 15px 0; text-align: center; color: #4CAF50; font-size: 1.3em;">Quest Complete!</h3>
        <div style="margin-bottom: 15px;">
          <div style="font-weight: bold; color: #64B5F6; margin-bottom: 8px;">${npc.name || 'NPC'}</div>
          <div style="font-style: italic; color: #FFD54F; margin-bottom: 8px; font-size: 1.1em;">"${quest.name}"</div>
          <div style="margin-bottom: 12px; line-height: 1.4; color: #4CAF50;">‚úì Quest objectives completed!</div>
          <div style="background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50; border-radius: 6px; padding: 8px; margin-bottom: 15px;">
            <strong style="color: #4CAF50;">Reward:</strong> ${rewardText}
          </div>
        </div>
        <div style="text-align: center; gap: 10px; display: flex; justify-content: center;">
          <button class="act-btn" onclick="turnInQuestToNpc('${quest.id}'); closeRandomQuestPopup();" style="background: linear-gradient(145deg, #2E7D32, #1B5E20); border: 1px solid #4CAF50; color: white; padding: 8px 16px; margin: 0 5px;">Turn In Quest</button>
          <button class="act-btn" onclick="closeRandomQuestPopup()" style="background: linear-gradient(145deg, #D32F2F, #B71C1C); border: 1px solid #F44336; color: white; padding: 8px 16px; margin: 0 5px;">Cancel</button>
        </div>
      </div>
    `;
  }

  window.turnInQuestToNpc = turnInQuestToNpc;

  window.acceptQuestOffer = function(questId) {
    // First check if quest is already in active quests
    let quest = randomNpcActiveQuests.find(q => q.id === questId);
    
    // If not found, look for it in NPCs across all areas
    if (!quest) {
      // Make sure current area is loaded first
      ensureWorldArea(p.currentArea.x, p.currentArea.y);
      
      // Search through all loaded areas AND ensure we check adjacent areas
      const searchAreas = [];
      
      // Add all currently loaded areas
      for (let y = 0; y < 64; y++) {
        for (let x = 0; x < 64; x++) {
          if (world[y][x] !== null) {
            searchAreas.push({x, y, area: world[y][x]});
          }
        }
      }
      
      // Also check adjacent areas to current position (lazy load them)
      const currentX = p.currentArea.x;
      const currentY = p.currentArea.y;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const areaX = currentX + dx;
          const areaY = currentY + dy;
          if (areaX >= 0 && areaX < 64 && areaY >= 0 && areaY < 64) {
            const area = ensureWorldArea(areaX, areaY);
            if (area) {
              searchAreas.push({x: areaX, y: areaY, area});
            }
          }
        }
      }
      
      // Now search through all areas
      for (let {area} of searchAreas) {
        if (area && area.tiles) {
          for (let row of area.tiles) {
            for (let tile of row) {
              if (tile.type === 'npc' && tile.data && tile.data.quest && tile.data.quest.id === questId) {
                quest = tile.data.quest;
                break;
              }
            }
            if (quest) break;
          }
        }
        if (quest) break;
      }
    }
    
    // Accept the quest if found and not already accepted
    if (quest) {
      const alreadyAccepted = randomNpcActiveQuests.some(q => q.id === questId);
      if (!alreadyAccepted) {
        acceptRandomNpcQuest(quest);
        log(`Quest accepted: ${quest.name}`);
      }
    } else {
      log('Quest not found. Try moving closer to the quest giver.');
    }
    closeRandomQuestPopup();
  }
  
  function gen(isTown, areaX, areaY){
    let tiles=Array.from({length:AREA},()=>Array.from({length:AREA},()=>({type:'empty'})));
    if(isTown){
      ['Potion Seller','Blacksmith','Scroll Merchant','Equipment Combiner','Quest Giver EM','Quest Giver H','Quest Giver L','Guild_Member','Banker','Repairer']
        .forEach(pr=>place(tiles,pr,true,areaX,areaY));
    } else {
      // Place 2 random NPCs with quests in non-town areas
      const randomNpcs = spawnRandomNpcs(areaX, areaY);
      randomNpcs.forEach(npc => {
        let placed = false;
        let attempts = 0;
        while (!placed && attempts < 20) {
          const x = roll(0, AREA - 1);
          const y = roll(0, AREA - 1);
          if (tiles[y][x].type === 'empty') {
            tiles[y][x] = {
              type: 'npc',
              data: {
                profession: 'Random_NPC',
                name: npc.name,
                symbol: npc.symbol,
                quest: npc.quest,
                abbr: 'N',
                isTown: false
              }
            };
            placed = true;
          }
          attempts++;
        }
      });
      for(let y=0;y<AREA;y++)for(let x=0;x<AREA;x++){
        if(tiles[y][x].type!=='empty')continue;
        let r=Math.random()*100;
        if(r<20) { // Reduced from 30 to 20 for less clutter
          // Monster spawn based on distance from town - fixed distance calculation
          const distFromTown = Math.sqrt(Math.pow(areaX-TOWN,2) + Math.pow(areaY-TOWN,2));
          
          // Check if we're at the edge of the map for level 15 boss spawning
          const mapSizeInAreas = SIZE / AREA; // 64 areas for 1024x1024 map
          const isEdgeArea = (areaX <= 1 || areaX >= mapSizeInAreas-2 || areaY <= 1 || areaY >= mapSizeInAreas-2);
          
          let monsterTypes = ['Goblin','Skeleton','Wolf','Orc','Ogre','Gnoll','Wyvern'];
          let monsterType = monsterTypes[roll(0,monsterTypes.length-1)];
          
          // 5% chance to spawn level 15 bosses in outermost areas (edge of map)
          if(isEdgeArea && Math.random() < 0.05) {
            const bossTypes = ['Leviathan','DeathStar','Susano'];
            monsterType = bossTypes[roll(0,bossTypes.length-1)];
          }
          const monsterData = monsterTpl[monsterType];
          
          // Fixed level spawning - areas adjacent to town only spawn level 1-2
          let maxLevel = 0;
          
          let level = 0;
          
          // Special handling for level 15 bosses
          if(['Leviathan','DeathStar','Susano'].includes(monsterType)) {
            maxLevel = 14; // Level 15 (index 14)
            level = 14; // Force level 15 for world bosses
          } else if(distFromTown <= 3) {
            // Adjacent areas: only level 1-2
            maxLevel = Math.random() < 0.7 ? 0 : 1;
          } else if(distFromTown <= 8) {
            // Nearby areas: level 1-4
            maxLevel = Math.min(3, Math.floor(distFromTown / 2));
          } else if(distFromTown <= 16) {
            // Mid-distance: level 3-7
            maxLevel = Math.min(6, Math.floor(distFromTown / 2));
          } else if(distFromTown <= 24) {
            // Far areas: level 6-10, with 40% chance for level 10 in outermost areas
            maxLevel = Math.min(9, Math.floor(distFromTown / 3));
            if(distFromTown >= 20 && Math.random() < 0.4) { // 40% chance for level 10 bosses
              maxLevel = 9; // Level 10 (index 9)
            }
          } else {
            // Outermost areas: level 8-10 only
            maxLevel = Math.max(7, Math.min(9, Math.floor(distFromTown / 3)));
            if(Math.random() < 0.4) { // 40% chance for level 10 bosses
              maxLevel = 9; // Level 10 (index 9)
            }
          }
          
          // Only run level generation for non-world bosses
          if(!['Leviathan','DeathStar','Susano'].includes(monsterType)) {
            for(let l=maxLevel;l>=0;l--){
              if(Math.random() < 1/Math.pow(1.5,l)){
                level = l;
                break;
              }
            }
          }
          
          let levelData = monsterData.levels[level];
          if(!levelData) {
            // Fallback to level 0 if data is missing
            level = 0;
            levelData = monsterData.levels[0];
          }
          const monster = {
            ...structuredClone(monsterData.base),
            name: levelData.name,
            level: level+1,
            reward: levelData.reward,
            boost: monsterData.base.boost,
            type: monsterType
          };
          
          // Scale stats by level multiplier
          Object.keys(monsterData.base).forEach(stat => {
            if(stat !== 'boost') monster[stat] = Math.floor(monster[stat] * levelData.mult);
          });
          
          // Debug log for level 15 bosses
          if(monster.level === 15) {
            console.log(`Level 15 Boss: ${monster.name}, HP: ${monster.hp}, Multiplier: ${levelData.mult}`);
          }
          
          tiles[y][x]={type:'monster',data:monster};
        }
        else if(r<40) { // Reduced from 55 to 40 for less clutter
          const resources = ['Herb','Bottle','Wood','Iron Ore','Coal','Paper','Wolf_Pelt','Goblin_Ear','Skeleton_Bone','Orc_Tusk','Ogre_Hide','Gnoll_Claw','Wyvern_Scale'];
          tiles[y][x]={type:'resource',data:resources[roll(0,resources.length-1)]};
        }
        else if(r<50) tiles[y][x]={type:'trap'}; // Reduced from 65 to 50
        else if(r<55) tiles[y][x]={type:'chest'}; // Reduced from 70 to 55
      }
    }
    return {tiles};
  }
  
  function place(tiles,prof,town,areaX,areaY){
    for(let i=0;i<100;i++){
      let x=roll(0,AREA-1),y=roll(0,AREA-1);
      if(tiles[y][x].type==='empty'){
        let npc={type:'npc',data:{profession:prof}};
        if(town) {
          if(prof === 'Quest Giver L') npc.data.abbr = 'L';
          else if(prof === 'Guild_Member') npc.data.abbr = 'G';
          else if(prof === 'Banker') npc.data.abbr = '$';
          else if(prof === 'Repairer') npc.data.abbr = 'R';
          else npc.data.abbr = prof[0];
          npc.data.isTown = true;
        } else {
          npc.data.abbr = 'N'; // Random NPCs show as 'N'
          npc.data.isTown = false;
        }
        if(!town&&fetchTpl[prof]) {
          npc.data.quest={...fetchTpl[prof],state:0};
        } else if(!town) {
          // Create distance-based random quests for NPCs without fetch templates
          const distFromTown = Math.sqrt(Math.pow(areaX-TOWN,2) + Math.pow(areaY-TOWN,2));
          npc.data.quest = generateRandomQuest(distFromTown);
        }
        tiles[y][x]=npc;
        return;
      }
    }
  }
  
  function getT(x,y){
    let ax=Math.floor(x/AREA),ay=Math.floor(y/AREA),lx=x%AREA,ly=y%AREA;
    let area = ensureWorldArea(ax, ay);
    
    // Additional safety checks
    if (!area || !area.tiles || !area.tiles[ly] || !area.tiles[ly][lx]) {
      return {type: 'empty'}; // Return empty tile instead of null for safety
    }
    
    return area.tiles[ly][lx];
  }
  
  function setT(x,y,t){
    let ax=Math.floor(x/AREA),ay=Math.floor(y/AREA),lx=x%AREA,ly=y%AREA;
    let area = ensureWorldArea(ax, ay);
    
    // Additional safety checks
    if (area && area.tiles && area.tiles[ly] && area.tiles[ly][lx] !== undefined) {
      area.tiles[ly][lx] = t;
    } else {
      console.warn(`Cannot set tile at (${x}, ${y}) - area not accessible`);
    }
  }
  
  function log(m){LEl.innerHTML+=m+'<br>';LEl.scrollTop=LEl.scrollHeight;save();}
  
  // Priority system for consumable effects
  function applyPotionEffect(effects, potionName) {
    // Calculate priority: higher value = higher priority
    // Multi-effect potions get +100 priority, single effects get base priority equal to their value
    let priority = 0;
    let effectCount = 0;
    
    if(effects.atk) { priority += effects.atk; effectCount++; }
    if(effects.def) { priority += effects.def; effectCount++; }
    if(effects.luck) { priority += effects.luck; effectCount++; }
    if(effects.craft) { priority += effects.craft; effectCount++; }
    
    // Multi-effect bonus
    if(effectCount > 1) priority += 100;
    
    // Apply ATK effects with priority
    if(effects.atk) {
      if(!p.tempAtk || priority > p.tempAtk.priority) {
        if(p.tempAtk) {
          log(`${potionName} (ATK +${effects.atk}) overwrote previous ATK effect!`);
        }
        p.tempAtk = {value: effects.atk, steps: effects.steps, priority: priority};
      } else if(priority === p.tempAtk.priority) {
        // Same priority, extend duration
        p.tempAtk.steps += effects.steps;
        log(`${potionName} extended ATK effect duration by ${effects.steps} steps!`);
      } else {
        log(`${potionName} ATK effect ignored (weaker than current effect)`);
      }
    }
    
    // Apply DEF effects with priority
    if(effects.def) {
      if(!p.tempDef || priority > p.tempDef.priority) {
        if(p.tempDef) {
          log(`${potionName} (DEF +${effects.def}) overwrote previous DEF effect!`);
        }
        p.tempDef = {value: effects.def, steps: effects.steps, priority: priority};
      } else if(priority === p.tempDef.priority) {
        // Same priority, extend duration
        p.tempDef.steps += effects.steps;
        log(`${potionName} extended DEF effect duration by ${effects.steps} steps!`);
      } else {
        log(`${potionName} DEF effect ignored (weaker than current effect)`);
      }
    }
    
    // Apply LUCK effects with priority
    if(effects.luck) {
      if(!p.tempLuck || priority > p.tempLuck.priority) {
        if(p.tempLuck) {
          log(`${potionName} (LUCK +${effects.luck}) overwrote previous LUCK effect!`);
        }
        p.tempLuck = {value: effects.luck, steps: effects.steps, priority: priority};
      } else if(priority === p.tempLuck.priority) {
        // Same priority, extend duration
        p.tempLuck.steps += effects.steps;
        log(`${potionName} extended LUCK effect duration by ${effects.steps} steps!`);
      } else {
        log(`${potionName} LUCK effect ignored (weaker than current effect)`);
      }
    }
    
    // Apply CRAFT effects with priority
    if(effects.craft) {
      if(!p.tempCraft || priority > p.tempCraft.priority) {
        if(p.tempCraft) {
          log(`${potionName} (CRAFT +${effects.craft}) overwrote previous CRAFT effect!`);
        }
        p.tempCraft = {value: effects.craft, steps: effects.steps, priority: priority};
      } else if(priority === p.tempCraft.priority) {
        // Same priority, extend duration
        p.tempCraft.steps += effects.steps;
        log(`${potionName} extended CRAFT effect duration by ${effects.steps} steps!`);
      } else {
        log(`${potionName} CRAFT effect ignored (weaker than current effect)`);
      }
    }
  }
  
  function updateUI(){
    // Handle temporary buffs
    if(p.tempAtk){
      p.tempAtk.steps--;
      if(p.tempAtk.steps <= 0){
        p.tempAtk = null;
        log("Strength potion wore off!");
        updateRealTimeDisplays();
      }
    }
    
    if(p.tempLuck){
      p.tempLuck.steps--;
      if(p.tempLuck.steps <= 0){
        p.tempLuck = null;
        log("Luck charm wore off!");
        updateRealTimeDisplays();
      }
    }
    
    if(p.tempDef){
      p.tempDef.steps--;
      if(p.tempDef.steps <= 0){
        p.tempDef = null;
        log("Defense potion wore off!");
        updateRealTimeDisplays();
      }
    }
    
    if(p.tempCraft){
      p.tempCraft.steps--;
      if(p.tempCraft.steps <= 0){
        p.tempCraft = null;
        log("Crafting potion wore off!");
        updateRealTimeDisplays();
      }
    }
    
    // Handle new potion effects
    if(p.tempOrcsRage){
      p.tempOrcsRage.steps--;
      if(p.tempOrcsRage.steps <= 0){
        p.tempOrcsRage = null;
        log("Orc's Rage wore off!");
      }
    }
    
    if(p.tempAngelsTouch){
      p.tempAngelsTouch.steps--;
      if(p.tempAngelsTouch.steps <= 0){
        p.maxHp = round1(p.maxHp - 200);
        p.hp = Math.min(p.hp, p.maxHp);
        p.tempAngelsTouch = null;
        log("Angel's Touch wore off! Lost temporary max HP.");
      }
    }
    
    if(p.tempDragonFury){
      p.tempDragonFury.steps--;
      if(p.tempDragonFury.steps <= 0){
        p.maxHp = round1(p.maxHp * 2); // Restore max HP (was halved, so multiply by 2)
        p.tempDragonFury = null;
        log("Dragon Fury wore off! Max HP restored.");
      }
    }
    
    if(p.tempGodsGift){
      p.tempGodsGift.steps--;
      if(p.tempGodsGift.steps <= 0){
        p.tempGodsGift = null;
        log("God's Gift wore off!");
      }
    }
    
    // Handle Asura Blood effects
    if(p.asuraBlood && p.asuraBlood.active){
      if(p.asuraBlood.boostSteps > 0){
        if(p.asuraBlood.boostSteps <= 1){
          log("Asura Blood boost phase ended! Stats returning to normal, then will be reduced by 75%...");
          // Restore to original stats first
          p.atk = p.asuraBlood.originalAtk;
          p.def = p.asuraBlood.originalDef;
          p.maxHp = p.asuraBlood.originalMaxHp;
          p.hp = Math.min(p.hp, p.maxHp);
          p.luck = p.asuraBlood.originalLuck;
          p.craft = p.asuraBlood.originalCraft;
          // Apply 75% reduction debuff
          p.atk = round1(p.atk * 0.25);
          p.def = round1(p.def * 0.25);
          p.maxHp = round1(p.maxHp * 0.25);
          p.hp = Math.min(p.hp, p.maxHp);
          p.luck = round1(p.luck * 0.25);
          p.craft = round1(p.craft * 0.25);
          log("Asura Blood debuff applied! All stats reduced by 75% for 50 steps.");
        }
        p.asuraBlood.boostSteps--;
      } else if(p.asuraBlood.debuffSteps > 0){
        if(p.asuraBlood.debuffSteps <= 1){
          // Restore to original stats
          p.atk = p.asuraBlood.originalAtk;
          p.def = p.asuraBlood.originalDef;
          p.maxHp = p.asuraBlood.originalMaxHp;
          p.hp = Math.min(p.hp, p.maxHp);
          p.luck = p.asuraBlood.originalLuck;
          p.craft = p.asuraBlood.originalCraft;
          log("Asura Blood effects have completely worn off! Stats restored to normal.");
          p.asuraBlood = null;
        } else {
          p.asuraBlood.debuffSteps--;
        }
      }
    }
    
    p.steps++;
    
    // Calculate current stats with all temporary effects
    let currentAtk = round1(p.atk + (p.tempAtk ? p.tempAtk.value : 0));
    let currentDef = round1(p.def + (p.tempDef ? p.tempDef.value : 0));
    let currentLuck = round1(p.luck + (p.tempLuck ? p.tempLuck.value : 0));
    let currentCraft = round1(p.craft + (p.tempCraft ? p.tempCraft.value : 0));
    
    // Apply new potion effects
    if(p.tempOrcsRage) {
      currentAtk = round1(currentAtk + p.tempOrcsRage.atkBoost);
      currentDef = round1(currentDef * p.tempOrcsRage.defDebuff);
    }
    
    if(p.tempAngelsTouch) {
      currentDef = round1(currentDef + p.tempAngelsTouch.defBoost);
      currentAtk = round1(currentAtk * p.tempAngelsTouch.atkDebuff);
    }
    
    if(p.tempDragonFury) {
      currentAtk = round1(currentAtk + p.tempDragonFury.atkBoost);
      currentDef = round1(currentDef * p.tempDragonFury.defDebuff);
    }
    
    if(p.tempGodsGift) {
      currentDef = round1(currentDef + p.tempGodsGift.defBoost);
    }
    
    // Update stats display
    let statsHTML = `
      <div class="stat-bar"><span class="stat-name">HP:</span> ${round1(p.hp)}/${round1(p.maxHp)}</div>
      <div class="stat-bar"><span class="stat-name">ATK:</span> ${currentAtk}(${round1(p.atk)})</div>
      <div class="stat-bar"><span class="stat-name">DEF:</span> ${currentDef}(${round1(p.def)})</div>
      <div class="stat-bar"><span class="stat-name">LUCK:</span> ${currentLuck}(${round1(p.luck)})</div>
      <div class="stat-bar"><span class="stat-name">GOLD:</span> ${p.g}</div>
      <div class="stat-bar"><span class="stat-name">CRAFT:</span> ${currentCraft}(${round1(p.craft)})</div>
      <div class="stat-bar"><span class="stat-name">P:</span> ${p.x},${p.y}</div>
    `;
    
    if(p.equipped) {
      statsHTML += `<div class="stat-bar"><span class="stat-name">EQUIP:</span> ${p.equipped.name}(${p.equipped.durability})</div>`;
    }
    
    // Show active consumable effects
    if(p.resurrectionCharm) {
      statsHTML += `<div class="stat-bar" style="color:#9C27B0;"><span class="stat-name">EFFECT:</span> Resurrection Charm Active</div>`;
    }
    if(p.tempAtk && p.tempAtk.steps > 0) {
      statsHTML += `<div class="stat-bar" style="color:#FF9800;"><span class="stat-name">EFFECT:</span> Strength Potion (${p.tempAtk.steps} steps)</div>`;
    }
    if(p.tempLuck && p.tempLuck.steps > 0) {
      statsHTML += `<div class="stat-bar" style="color:#4CAF50;"><span class="stat-name">EFFECT:</span> Luck Charm (${p.tempLuck.steps} steps)</div>`;
    }
    if(p.tempDef && p.tempDef.steps > 0) {
      statsHTML += `<div class="stat-bar" style="color:#2196F3;"><span class="stat-name">EFFECT:</span> Defense Potion (${p.tempDef.steps} steps)</div>`;
    }
    if(p.asuraBlood && p.asuraBlood.active) {
      if(p.asuraBlood.boostSteps > 0) {
        statsHTML += `<div class="stat-bar" style="color:#FF5722;"><span class="stat-name">EFFECT:</span> Asura Blood (${p.asuraBlood.boostSteps} steps)</div>`;
      } else if(p.asuraBlood.debuffSteps > 0) {
        statsHTML += `<div class="stat-bar" style="color:#FF5722;"><span class="stat-name">DEBUFF:</span> Asura Weakness (${p.asuraBlood.debuffSteps} steps)</div>`;
      }
    }
    
    SEl.innerHTML = statsHTML;
    
    let gx=p.x,gy=p.y,ax=Math.floor(gx/AREA),ay=Math.floor(gy/AREA),lx=gx%AREA,ly=gy%AREA,
        sx=Math.max(0,Math.min(AREA-GRID_W,lx-Math.floor(GRID_W/2))),
        sy=Math.max(0,Math.min(AREA-GRID_H,ly-Math.floor(GRID_H/2))),
        o='';
    
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        let tx=sx+x,ty=sy+y,ch='.';
        if(tx===lx&&ty===ly) ch='P';
        else {
          let c=getT(tx+ax*AREA,ty+ay*AREA);
          if(c && c.type==='monster') {
            let levelClass = `monster-lvl${Math.min(10, c.data.level)}`;
            let symbol = 'M';
            
            // Special symbols for bosses
            if(c.data.level === 10) {
              symbol = 'B'; // Level 10 bosses
              levelClass = 'monster-lvl10'; // Use purple color
            } else if(c.data.level === 15) {
              symbol = 'G'; // Level 15 bosses
              levelClass = 'monster-lvl10'; // Use purple color for level 15 bosses too
            }
            
            ch=`<span class="${levelClass}">${symbol}</span>`;
          }
          else if(c && c.type==='resource') ch=`<span class="resource">R</span>`;
          else if(c && c.type==='trap') ch='T';
          else if(c && c.type==='chest') ch='<span class="chest">C</span>';
          else if(c && c.type==='npc') {
            if(c.data && c.data.isTown) {
              ch=`<span class="town-npc">${c.data.abbr || 'N'}</span>`;
            } else {
              ch=`<span class="town-npc">${(c.data && c.data.abbr) || 'N'}</span>`;
            }
          }
        }
        o+=ch+' ';
      }
      o+='\n';
    }
    MEl.innerHTML=o;
  }
  
  function move(dir){
    // Prevent movement if player is dead
    if(p.hp <= 0) {
      log("You are dead! Use Reborn to start over.");
      return;
    }
    
    let nx=p.x,ny=p.y;
    if(dir==='up') ny--;
    else if(dir==='down') ny++;
    else if(dir==='left') nx--;
    else if(dir==='right') nx++;
    
    if(nx<0||nx>=SIZE||ny<0||ny>=SIZE) return;
    
    let t=getT(nx,ny);
    if(t && t.type==='monster') {
      if(p.preventFlee>0) {
        log("Cannot flee!");
        return;
      }
      fight(t.data,nx,ny);
    }
    else if(t && t.type==='resource') {
      p.inv[t.data]=(p.inv[t.data]||0)+1;
      log("Found "+t.data);
      
      // Update random NPC fetch quest progress
      randomNpcActiveQuests.forEach(quest => {
        if(quest.type === 'fetch' && quest.need[t.data]) {
          const currentProgress = Math.min(p.inv[t.data] || 0, quest.need[t.data]);
          if(currentProgress > quest.progress[t.data]) {
            quest.progress[t.data] = currentProgress;
            log(`Random quest progress: ${quest.name} - ${quest.progress[t.data]}/${quest.need[t.data]} ${t.data.replace(/_/g, ' ')}`);
          }
        }
      });
      
      // Update normal fetch quest progress and refresh popup if needed
      let fetchQuestProgressUpdated = false;
      quests.forEach(quest => {
        if(quest.type === 'fetch' && quest.need[t.data]) {
          const currentProgress = Math.min(p.inv[t.data] || 0, quest.need[t.data]);
          if(currentProgress > quest.progress[t.data]) {
            quest.progress[t.data] = currentProgress;
            fetchQuestProgressUpdated = true;
            log(`Quest progress: ${quest.name} - ${quest.progress[t.data]}/${quest.need[t.data]} ${t.data.replace(/_/g, ' ')}`);
          }
        }
      });
      
      if(fetchQuestProgressUpdated) {
        refreshQuestPopup();
      }
      
      setT(nx,ny,{type:'empty'});
      p.x=nx; p.y=ny;
      
      checkAreaChange();
      updateUI();
      updateRealTimeDisplays();
    }
    else if(t && t.type==='trap') {
      let dmg=roll(1,5);
      p.hp=Math.max(0,round1(p.hp-dmg));
      log("Trap! -"+dmg+" HP");
      setT(nx,ny,{type:'empty'});
      p.x=nx; p.y=ny;
      checkAreaChange();
      updateUI();
      updateRealTimeDisplays();
    }
    else if(t && t.type==='chest') {
      let g=roll(5,15);
      
      // Apply luck multiplier - every 5 luck beyond 5 increases multiplier
      let currentLuck = round1(p.luck + (p.tempLuck ? p.tempLuck.value : 0));
      let multiplier = 1;
      if(currentLuck > 5) {
        multiplier = Math.floor((currentLuck - 1) / 5);
      }
      
      g = g * multiplier;
      p.g = Math.max(0, (p.g || 0) + g);
      
      if(multiplier > 1) {
        log(`Chest! +${g} gold (${multiplier}x luck bonus!)`);
      } else {
        log("Chest! +"+g+" gold");
      }
      
      setT(nx,ny,{type:'empty'});
      p.x=nx; p.y=ny;
      checkAreaChange();
      updateUI();
    }
    else if(t && t.type==='npc') {
      interact(t.data);
    }
    else {
      p.x=nx; p.y=ny;
      
      checkAreaChange();
      updateUI();
    }
  }
  
  function checkAreaChange() {
    // Check if player moved to a different area
    let newAreaX = Math.floor(p.x / AREA);
    let newAreaY = Math.floor(p.y / AREA);
    
    if(newAreaX !== p.currentArea.x || newAreaY !== p.currentArea.y) {
      // Player moved to a new area - refresh the old area (regenerate monsters, resources, etc.)
      let oldAreaX = p.currentArea.x;
      let oldAreaY = p.currentArea.y;
      
      // Don't refresh the town area - it should stay static  
      // Also check if the old area was actually loaded before trying to refresh
      if((oldAreaX !== TOWN || oldAreaY !== TOWN) && 
         world[oldAreaY] && world[oldAreaY][oldAreaX] &&
         oldAreaX >= 0 && oldAreaX < 64 && oldAreaY >= 0 && oldAreaY < 64) {
        try {
          world[oldAreaY][oldAreaX] = gen(false, oldAreaX, oldAreaY);
          console.log(`Refreshed area (${oldAreaX}, ${oldAreaY}) - new monsters and resources spawned`);
        } catch (error) {
          console.error(`Error refreshing area (${oldAreaX}, ${oldAreaY}):`, error);
        }
      }
      
      // Ensure new area is loaded
      ensureWorldArea(newAreaX, newAreaY);
      p.currentArea = {x: newAreaX, y: newAreaY};
      
      // Clear the log panel when entering a new area
      LEl.innerHTML='';
      
      log(`Entered area (${newAreaX}, ${newAreaY})`);
    }
  }
  
  function fight(m,x,y){
    // Calculate player stats with all effects and equipment
    let playerAtk = round1(p.atk + (p.tempAtk ? p.tempAtk.value : 0));
    let playerDef = round1(p.def + (p.tempDef ? p.tempDef.value : 0));
    let playerLuck = round1(p.luck + (p.tempLuck ? p.tempLuck.value : 0));
    
    // Apply new potion effects to combat stats
    if(p.tempOrcsRage) {
      playerAtk = round1(playerAtk + p.tempOrcsRage.atkBoost);
      playerDef = round1(playerDef * p.tempOrcsRage.defDebuff);
    }
    
    if(p.tempAngelsTouch) {
      playerDef = round1(playerDef + p.tempAngelsTouch.defBoost);
      playerAtk = round1(playerAtk * p.tempAngelsTouch.atkDebuff);
    }
    
    if(p.tempDragonFury) {
      playerAtk = round1(playerAtk + p.tempDragonFury.atkBoost);
      playerDef = round1(playerDef * p.tempDragonFury.defDebuff);
    }
    
    if(p.tempGodsGift) {
      playerDef = round1(playerDef + p.tempGodsGift.defBoost);
    }
    
    // Calculate attack with equipment (including custom boost from combined items)
    let equipAtk = 0, equipDef = 0, equipHp = 0;
    if(p.equipped) {
      let boostToUse = p.equipped.boost || (itemDefs[p.equipped.name] && itemDefs[p.equipped.name].boost);
      if(boostToUse) {
        equipAtk = boostToUse.atk || 0;
        equipDef = boostToUse.def || 0;
        equipHp = boostToUse.maxHp || 0;
      }
    }
    
    let totalPlayerAtk = playerAtk + equipAtk;
    let totalPlayerDef = playerDef + equipDef;
    
    log("Fighting "+m.name+" (HP:"+m.hp+", ATK:"+m.atk+", DEF:"+m.def+")");
    
    while(m.hp > 0 && p.hp > 0) {
      // Player attacks monster
      let playerDmg = roll(1, totalPlayerAtk); // Random damage from 1 to attack stat
      let defenseReduction = Math.floor(m.def / 2); // Defense reduces damage by 1 per 2 defense
      playerDmg = Math.max(1, playerDmg - defenseReduction);
      
      // Apply luck to damage
      if(Math.random() < playerLuck/100) {
        playerDmg = Math.floor(playerDmg * 1.5);
        log("Lucky hit!");
      }
      
      m.hp = Math.max(0, m.hp - playerDmg);
      log("You deal "+playerDmg+" damage to "+m.name);
      
      // Monster attacks player
      let monsterDmg = roll(1, m.atk); // Random damage from 1 to attack stat
      let playerDefenseReduction = Math.floor(totalPlayerDef / 2); // Defense reduces damage by 1 per 2 defense
      monsterDmg = Math.max(1, monsterDmg - playerDefenseReduction);
      
      p.hp = Math.max(0, round1(p.hp - monsterDmg));
      log(m.name+" deals "+monsterDmg+" damage to you");
      
      // Reduce equipment durability
      if(p.equipped) {
        p.equipped.durability--;
        if(p.equipped.durability <= 0) {
          log(p.equipped.name+" broke!");
          unequipItem();
        }
      }
    }
    
    if(p.hp <= 0) {
      p.hp = 0;
      log("You died!");
      
      // Check if player has resurrection charm active
      if(p.resurrectionCharm) {
        p.resurrectionCharm = false;
        p.hp = p.maxHp;
        p.x = 264; p.y = 264; // Return to town
        log("Resurrection Charm activated! Automatically reborn with all stats intact!");
        updateUI();
        return;
      }
      
      // Handle banking death logic
      if(p.bankGold > 0) {
        // Player has gold in bank, increment death counter
        p.bankDeaths++;
        
        // Check if remaining gold after fees would be less than 10
        const totalFees = p.bankDeaths * 10;
        const remainingGold = p.bankGold - totalFees;
        
        if(remainingGold < 10) {
          // Close account and reset banking data
          p.bankGold = 0;
          p.bankDeaths = 0;
          log("Bank account closed due to insufficient funds after death fees. Banking data reset.");
        } else {
          log(`Death recorded by banker. Outstanding fees: ${totalFees} gold`);
        }
      } else {
        // Player has no gold in bank, reset banking data
        p.bankDeaths = 0;
        log("Bank services reset (no gold was stored)");
      }
      
      updateUI();
      return;
    }
    
    log("You defeated "+m.name+"!");
    log("Remaining HP: " + round1(p.hp) + "/" + round1(p.maxHp));
    
    // Level-based monster defeat rewards with tier-based doubling
    let hpGain = m.level; // +1 HP per monster level
    
    // Calculate stat gain based on tier system
    let atkDefGain;
    if(m.level <= 3) {
      // Level 1-3: 0.1, 0.2, 0.3
      atkDefGain = round1(m.level * 0.1);
    } else if(m.level <= 6) {
      // Level 4-6: 0.6, 0.7, 0.8 (base 0.6 + extra levels)
      atkDefGain = round1(0.6 + (m.level - 4) * 0.1);
    } else if(m.level <= 9) {
      // Level 7-9: 1.6, 1.7, 1.8 (base 1.6 + extra levels)
      atkDefGain = round1(1.6 + (m.level - 7) * 0.1);
    } else if(m.level == 10) {
      // Level 10: 3.6
      atkDefGain = 3.6;
    } else {
      // Levels above 10 follow the pattern (for future expansion)
      atkDefGain = round1(m.level * 0.1);
    }
    
    // Special rewards for level 15 bosses
    if(m.level === 15) {
      if(m.type === 'Leviathan') {
        p.atk = round1(p.atk + 10);
        p.luck = round1(p.luck + 0.2);
        log("Leviathan defeated! +10 ATK, +0.2 LUCK");
      } else if(m.type === 'DeathStar') {
        p.def = round1(p.def + 10);
        p.luck = round1(p.luck + 0.3);
        log("Death Star defeated! +10 DEF, +0.3 LUCK");
      } else if(m.type === 'Susano') {
        p.maxHp = round1(p.maxHp + 10);
        p.hp = round1(p.hp + 10);
        p.luck = round1(p.luck + 0.5);
        log("Susano defeated! +10 MAX HP, +0.5 LUCK");
      }
    } else {
      // Apply stat gains based on monster's boost specialty
      const monsterData = monsterTpl[m.type];
      const boostType = monsterData && monsterData.base ? monsterData.base.boost : null;
      
      if(boostType === 'atk') {
        // ATK specialty monsters give ATK bonus
        p.atk = round1(p.atk + atkDefGain);
        log("ATK +" + atkDefGain);
      } else if(boostType === 'def') {
        // DEF specialty monsters give DEF bonus
        p.def = round1(p.def + atkDefGain);
        log("DEF +" + atkDefGain);
      } else if(boostType === 'maxHp') {
        // HP specialty monsters give HP bonus
        p.maxHp = round1(p.maxHp + hpGain);
        p.hp = round1(p.hp + hpGain);
        log("MAX HP +" + hpGain + ", HP +" + hpGain);
      } else {
        // Fallback for monsters without defined boost type
        p.maxHp = round1(p.maxHp + hpGain);
        p.hp = round1(p.hp + hpGain);
        log("HP +" + hpGain);
      }
    }
    
    // Gold reward scales with monster level multiplier
    let baseGoldReward = roll(1, 5);
    let goldMultiplier = Math.pow(2, m.level - 1); // 2^(level-1) for exponential scaling
    let goldReward = Math.floor(baseGoldReward * goldMultiplier);
    p.g = Math.max(0, (p.g || 0) + goldReward);
    log("+" + goldReward + " gold");
    
    // Track kills for quests
    let monsterKey = m.name.replace(/\s+/g, '_');
    p.kills[monsterKey] = (p.kills[monsterKey] || 0) + 1;
    
    // Update random NPC kill quest progress
    randomNpcActiveQuests.forEach(quest => {
      if(quest.type === 'kill' && quest.need[monsterKey]) {
        quest.progress[monsterKey] = (quest.progress[monsterKey] || 0) + 1;
        if(quest.progress[monsterKey] <= quest.need[monsterKey]) {
          log(`Random quest progress: ${quest.name} - ${quest.progress[monsterKey]}/${quest.need[monsterKey]} ${monsterKey.replace(/_/g, ' ')}`);
        }
      }
    });
    
    // Update normal quest kill progress
    let questProgressUpdated = false;
    quests.forEach(quest => {
      if(quest.type === 'kill' && quest.need[monsterKey]) {
        quest.progress[monsterKey] = (quest.progress[monsterKey] || 0) + 1;
        questProgressUpdated = true;
        if(quest.progress[monsterKey] <= quest.need[monsterKey]) {
          log(`Quest progress: ${quest.name} - ${quest.progress[monsterKey]}/${quest.need[monsterKey]} ${monsterKey.replace(/_/g, ' ')}`);
        }
      }
    });
    
    // Refresh quest popup if open and progress was updated
    if(questProgressUpdated) {
      refreshQuestPopup();
    }
    
    // Boss monsters (level 10) drop special items 50% of the time + luck bonus
    let currentLuck = round1(p.luck + (p.tempLuck ? p.tempLuck.value : 0));
    let bossDropChance = 0.5 + (currentLuck / 100);
    if(m.level === 10 && Math.random() < bossDropChance) {
      let specialItems = {
        'Ancient_Goblin': 'Ancient_Goblin_Crown',
        'Bone_Archlich': 'Bone_Archlich_Staff',
        'Primordial_Wolf': 'Primordial_Wolf_Fang',
        'Orc_Destroyer': 'Orc_Destroyer_Axe',
        'Ancient_Ogre': 'Ancient_Ogre_Club',
        'Gnoll_Demigod': 'Gnoll_Demigod_Spear',
        'Wyvern_God': 'Wyvern_God_Scale'
      };
      
      let itemKey = specialItems[monsterKey];
      if(itemKey) {
        let itemDef = itemDefs[itemKey];
        let durability = roll(1, itemDef.maxD);
        p.eq.push({name: itemKey, durability: durability, level: itemDef.level || 1});
        log("Found rare item: " + itemKey.replace(/_/g, ' ') + " (" + durability + " durability)");
      }
    }
    
    // Level 15 boss monsters drop legendary weapons 90% of the time + luck bonus
    let legendaryDropChance = 0.9 + (currentLuck / 100);
    if(m.level === 15 && Math.random() < legendaryDropChance) {
      let legendaryWeapons = {
        'Leviathan': 'Tidepiercer',
        'DeathStar': 'Nova_Maul',
        'Susano': 'Stormfang_Katana'
      };
      
      // Use monster type instead of full monster key for level 15 bosses
      let weaponKey = legendaryWeapons[m.type];
      if(weaponKey) {
        let itemDef = itemDefs[weaponKey];
        let durability = itemDef.maxD;
        p.eq.push({name: weaponKey, durability: durability, level: itemDef.level || 1});
        log("Found legendary weapon: " + weaponKey.replace(/_/g, ' ') + " (" + durability + " durability)");
      }
    }
    
    // Random resource drop (30% base chance + luck bonus)
    let resourceDropChance = 0.3 + (currentLuck / 100);
    if(Math.random() < resourceDropChance) {
      let resourceMap = {
        'Goblin': 'Goblin_Ear',
        'Skeleton': 'Skeleton_Bone',
        'Wolf': 'Wolf_Pelt',
        'Orc': 'Orc_Tusk',
        'Ogre': 'Ogre_Hide',
        'Gnoll': 'Gnoll_Claw',
        'Wyvern': 'Wyvern_Scale'
      };
      
      let resource = resourceMap[m.type] || 'Herb';
      p.inv[resource] = (p.inv[resource] || 0) + 1;
      log("Found " + resource.replace(/_/g, ' '));
      
      // Update random NPC fetch quest progress
      randomNpcActiveQuests.forEach(quest => {
        if(quest.type === 'fetch' && quest.need[resource]) {
          const currentProgress = Math.min(p.inv[resource] || 0, quest.need[resource]);
          if(currentProgress > quest.progress[resource]) {
            quest.progress[resource] = currentProgress;
            log(`Random quest progress: ${quest.name} - ${quest.progress[resource]}/${quest.need[resource]} ${resource.replace(/_/g, ' ')}`);
          }
        }
      });
      
      // Update normal fetch quest progress and refresh popup if needed
      let fetchQuestProgressUpdated = false;
      quests.forEach(quest => {
        if(quest.type === 'fetch' && quest.need[resource]) {
          const currentProgress = Math.min(p.inv[resource] || 0, quest.need[resource]);
          if(currentProgress > quest.progress[resource]) {
            quest.progress[resource] = currentProgress;
            fetchQuestProgressUpdated = true;
            log(`Quest progress: ${quest.name} - ${quest.progress[resource]}/${quest.need[resource]} ${resource.replace(/_/g, ' ')}`);
          }
        }
      });
      
      if(fetchQuestProgressUpdated) {
        refreshQuestPopup();
      }
    }
    
    // Rare consumables drop from all monsters with specific drop rates
    // Asura Blood: 0.0001% chance, Resurrection Charm: 0.001% chance
    if(Math.random() < 0.000001) { // 0.0001% = 0.000001
      p.inv['Asura_Blood'] = (p.inv['Asura_Blood'] || 0) + 1;
      log("Found Asura Blood!");
    }
    if(Math.random() < 0.00001) { // 0.001% = 0.00001
      p.inv['Resurrection_Charm'] = (p.inv['Resurrection_Charm'] || 0) + 1;
      log("Found Resurrection Charm!");
    }
    
    // This quest progress tracking was moved earlier in the function to avoid duplicates
    
    setT(x,y,{type:'empty'});
    p.x=x; p.y=y;
    checkAreaChange();
    updateUI();
  }
  
  function interact(n){
    if(n.profession==='Potion Seller'||n.profession==='Blacksmith'||n.profession==='Scroll Merchant'){
      openShop(n.profession);
    }
    else if(n.profession==='Equipment Combiner'){
      openCombiner();
    }
    else if(n.profession==='Banker'){
      openBanker();
    }
    else if(n.profession==='Repairer'){
      openRepairer();
    }
    else if(n.profession==='Quest Giver EM'||n.profession==='Quest Giver H'||n.profession==='Quest Giver L'){
      if(n.profession==='Quest Giver EM') openQuestGiver('easy','med');
      else if(n.profession==='Quest Giver H') openQuestGiver('hard','elite');
      else if(n.profession==='Quest Giver L') openQuestGiver('legendary');
    }
    else if(n.profession==='Guild_Member'){
      checkQuestCompletion();
    }
    else if(n.profession==='Random_NPC'){
      showRandomNpcQuestDialog(n);
    }
    else if(n.quest){
      if(n.quest.state===0) {
        showQuestPopup(n);
      }
      else if(n.quest.state===1){
        let canComplete = true;
        
        // Debug logging
        log(`DEBUG: Attempting to complete quest. Type: ${n.quest.type}`);
        log(`DEBUG: Quest needs: ${JSON.stringify(n.quest.need)}`);
        
        // Enhanced validation for quest completion
        if(n.quest.type === 'kill') {
          // Kill quest validation - check each monster requirement
          log(`DEBUG: Player kills: ${JSON.stringify(p.kills)}`);
          Object.entries(n.quest.need).forEach(([monster, needed]) => {
            let killed = p.kills[monster] || 0;
            log(`DEBUG: Need ${needed} ${monster}, have ${killed}`);
            if(killed < needed) {
              canComplete = false;
              log(`DEBUG: Cannot complete - insufficient kills for ${monster}`);
            }
          });
        } else {
          // Fetch quest validation - check each item requirement
          log(`DEBUG: Player inventory: ${JSON.stringify(p.inv)}`);
          Object.entries(n.quest.need).forEach(([item, needed]) => {
            let have = p.inv[item] || 0;
            log(`DEBUG: Need ${needed} ${item}, have ${have}`);
            if(have < needed) {
              canComplete = false;
              log(`DEBUG: Cannot complete - insufficient items for ${item}`);
            }
          });
        }
        
        // Double-check validation to prevent any bypasses
        if(canComplete) {
          // Re-validate one more time before completion
          if(n.quest.type === 'kill') {
            for(let [monster, needed] of Object.entries(n.quest.need)) {
              if((p.kills[monster] || 0) < needed) {
                log("Quest validation failed: insufficient kills for " + monster);
                canComplete = false;
                break;
              }
            }
          } else {
            for(let [item, needed] of Object.entries(n.quest.need)) {
              if((p.inv[item] || 0) < needed) {
                log("Quest validation failed: insufficient items for " + item);
                canComplete = false;
                break;
              }
            }
          }
        }
        
        if(canComplete){
          // Remove items for fetch quests only after final validation
          if(n.quest.type !== 'kill') {
            let validationFailed = false;
            for(let [item, needed] of Object.entries(n.quest.need)) {
              if((p.inv[item] || 0) >= needed) {
                p.inv[item] = (p.inv[item] || 0) - needed;
              } else {
                log("ERROR: Tried to remove " + item + " but player doesn't have enough!");
                validationFailed = true;
                break;
              }
            }
            
            if(validationFailed) {
              log("Quest completion aborted due to validation failure!");
              return; // Exit the entire function without completing quest
            }
          }
          
          // Give rewards - either gold OR item, not both
          if(n.quest.rewardGold) {
            const goldReward = Number(n.quest.rewardGold) || 0;
            p.g = Math.max(0, (p.g || 0) + goldReward);
            log("Quest complete! +" + goldReward + "g");
          }
          if(n.quest.reward) {
            equip(n.quest.reward);
            log("Quest complete! Received " + n.quest.reward);
          }
          
          n.quest.state=2;
        } else {
          if(n.quest.type === 'kill') {
            log("Cannot complete quest! Need to kill: " + Object.entries(n.quest.need).map(([monster, needed]) => 
              `${monster.replace(/_/g, ' ')} (${p.kills[monster] || 0}/${needed})`
            ).join(', '));
          } else {
            log("Cannot complete quest! Need: " + Object.entries(n.quest.need).map(([item, needed]) => 
              `${item.replace(/_/g, ' ')} (${p.inv[item] || 0}/${needed})`
            ).join(', '));
          }
        }
      }
      else log("Quest already complete");
    }
  }
  
  function openShop(prof){
    let arr=shops[prof];
    let shopIcons = {'Potion Seller': 'üß™', 'Blacksmith': '‚öíÔ∏è', 'Scroll Merchant': 'üìú'};
    let shopColors = {'Potion Seller': '#4CAF50', 'Blacksmith': '#FF5722', 'Scroll Merchant': '#9C27B0'};
    
    let html=`<h2 style="color:${shopColors[prof]}; text-align:center; margin-bottom:15px;">${shopIcons[prof]} ${prof}</h2>`;
    html += `<div style="text-align:center; margin-bottom:20px; padding:8px; background:#333; border-radius:6px; color:#FFD700;">`;
    html += `<strong>Your Gold: ${p.g}</strong>`;
    html += `</div>`;
    
    html += '<div style="display:grid; gap:8px;">';
    arr.forEach(it=>{
      let canAfford = (p.g || 0) >= it.price;
      let btnStyle = `padding:12px; border-radius:6px; border:1px solid ${canAfford ? '#4CAF50' : '#f44336'}; background:${canAfford ? '#2E7D32' : '#333'}; color:${canAfford ? 'white' : '#999'}; cursor:${canAfford ? 'pointer' : 'not-allowed'}; display:flex; justify-content:space-between; align-items:center;`;
      
      html += `<button data-buy="${it.name}" style="${btnStyle}">`;
      html += `<div style="display:flex; flex-direction:column; align-items:flex-start;">`;
      html += `<div style="font-weight:bold;">${it.name.replace(/_/g, ' ')}</div>`;
      if(it.desc) {
        html += `<div style="font-size:0.9em; color:#ccc; margin-top:2px;">${it.desc}</div>`;
      }
      html += `</div>`;
      html += `<div style="color:#FFD700; font-weight:bold;">${it.price}g</div>`;
      html += `</button>`;
    });
    html += '</div>';
    
    openModal(html, btn => {
      if(btn.dataset.buy){
        let it=arr.find(x=>x.name===btn.dataset.buy);
        showPurchaseConfirmation(it, prof);
      }
      updateUI();
    });
  }
  
  function openQuestGiver(tier1, tier2) {
    let availableQuests = [];
    let questMap = [];
    
    // Add tier1 quests
    (townQuests[tier1] || []).forEach((quest, index) => {
      availableQuests.push(quest);
      questMap.push({tier: tier1, index: index});
    });
    
    // Add tier2 quests if provided
    if(tier2) {
      (townQuests[tier2] || []).forEach((quest, index) => {
        availableQuests.push(quest);
        questMap.push({tier: tier2, index: index});
      });
    }
    
    let tierColors = {'easy': '#4CAF50', 'med': '#FF9800', 'hard': '#f44336', 'elite': '#9C27B0', 'legendary': '#FFD700'};
    let tierNames = {'easy': 'Easy', 'med': 'Medium', 'hard': 'Hard', 'elite': 'Elite', 'legendary': 'Legendary'};
    
    let html = `<h2 style="color:#FFD700; text-align:center; margin-bottom:15px;">üéØ Quest Giver</h2>`;
    html += `<div style="text-align:center; margin-bottom:20px; padding:8px; background:#333; border-radius:6px; color:#ddd;">`;
    html += `Available Quests: ${tier2 ? `${tierNames[tier1]} & ${tierNames[tier2]}` : tierNames[tier1]} Tier`;
    html += `</div>`;
    
    html += '<div style="display:grid; gap:8px;">';
    availableQuests.forEach((quest, index) => {
      let tier = questMap[index].tier;
      let existing = quests.find(q => q.name === quest.name);
      let isAccepted = !!existing;
      
      let btnStyle = `padding:12px; border-radius:6px; border:1px solid ${isAccepted ? '#666' : tierColors[tier]}; background:${isAccepted ? '#333' : tierColors[tier]}; color:${isAccepted ? '#999' : 'white'}; cursor:${isAccepted ? 'not-allowed' : 'pointer'}; display:flex; justify-content:space-between; align-items:center;`;
      
      html += `<button data-q="${index}" style="${btnStyle}">`;
      html += `<div>`;
      html += `<div style="font-weight:bold; margin-bottom:4px;">${quest.name}${isAccepted ? ' [ACCEPTED]' : ''}</div>`;
      html += `<div style="font-size:12px; opacity:0.8;">${quest.desc}</div>`;
      html += `</div>`;
      html += `<div style="text-align:right;">`;
      html += `<div style="color:#FFD700; font-weight:bold;">${quest.reward.gold}g</div>`;
      html += `<div style="font-size:10px; opacity:0.6;">${tierNames[tier]}</div>`;
      html += `</div>`;
      html += `</button>`;
    });
    html += '</div>';
    
    openModal(html, btn => {
      if(btn.dataset.q) {
        let questIndex = parseInt(btn.dataset.q);
        if(questIndex >= 0 && questIndex < availableQuests.length) {
          let quest = availableQuests[questIndex];
          
          // Check if quest already accepted
          let existing = quests.find(q => q.name === quest.name);
          if(existing) {
            log("Quest already accepted");
            return;
          }
          
          // Show quest popup instead of directly accepting
          showTownQuestPopup(quest);
        }
      }
      updateUI();
    });
  }
  
  function generateQuestLogHTML() {
    let html = '<h2 style="color:#FFD700; text-align:center; margin-bottom:15px;">üìã Active Quests</h2>';
    if(quests.length === 0) {
      html += '<div style="text-align:center; color:#888; padding:20px;">No active quests</div>';
    } else {
      html += '<div style="display:grid; gap:12px;">';
      quests.forEach((quest, index) => {
        // Check if quest can be completed
        let canComplete = true;
        if(quest.type === 'kill') {
          Object.entries(quest.need).forEach(([monster, needed]) => {
            if((quest.progress[monster] || 0) < needed) canComplete = false;
          });
        } else if(quest.type === 'fetch') {
          Object.entries(quest.need).forEach(([item, needed]) => {
            if((p.inv[item] || 0) < needed) canComplete = false;
          });
        }
        
        let questStyle = `padding:12px; background:${canComplete ? '#1B5E20' : '#333'}; border-radius:8px; border:1px solid ${canComplete ? '#4CAF50' : '#555'};`;
        html += `<div style="${questStyle}">`;
        html += `<div style="color:#FFD700; font-weight:bold; margin-bottom:8px;">${quest.name}</div>`;
        html += `<div style="color:#ddd; margin-bottom:8px; font-size:14px;">${quest.desc}</div>`;
        
        html += '<div style="margin-bottom:8px;">';
        if(quest.type === 'kill') {
          Object.entries(quest.need).forEach(([monster, needed]) => {
            let killed = quest.progress[monster] || 0;
            let color = killed >= needed ? '#4CAF50' : '#FF9800';
            html += `<div style="color:${color}; font-size:13px;">‚Ä¢ ${monster.replace(/_/g, ' ')}: ${killed}/${needed}</div>`;
          });
        } else if(quest.type === 'fetch') {
          Object.entries(quest.need).forEach(([item, needed]) => {
            let have = p.inv[item] || 0;
            let color = have >= needed ? '#4CAF50' : '#FF9800';
            html += `<div style="color:${color}; font-size:13px;">‚Ä¢ ${item.replace(/_/g, ' ')}: ${have}/${needed}</div>`;
          });
        }
        html += '</div>';
        
        if(canComplete) {
          html += `<button data-turn="${index}" style="background:#4CAF50; color:white; border:none; padding:6px 12px; border-radius:4px; cursor:pointer;">Turn In Quest</button>`;
        } else {
          html += `<div style="color:#888; font-size:12px; font-style:italic;">Requirements not met</div>`;
        }
        html += '</div>';
      });
      html += '</div>';
    }
    return html;
  }

  function refreshQuestPopup() {
    if(!isQuestPopupOpen) return;
    
    const modal = d('#modal');
    if(modal && modal.style.display !== 'none') {
      modal.innerHTML = generateQuestLogHTML();
      
      // Re-attach event listeners to buttons
      modal.querySelectorAll('button[data-turn]').forEach(btn => {
        btn.onclick = () => {
          let index = parseInt(btn.dataset.turn);
          let quest = quests[index];
          
          // Validate quest completion before completing
          let canComplete = true;
          if(quest.type === 'kill') {
            Object.entries(quest.need).forEach(([monster, needed]) => {
              if((quest.progress[monster] || 0) < needed) canComplete = false;
            });
          } else if(quest.type === 'fetch') {
            Object.entries(quest.need).forEach(([item, needed]) => {
              if((p.inv[item] || 0) < needed) canComplete = false;
            });
          }
          
          if(!canComplete) {
            log("Quest requirements not met!");
            return;
          }
          
          // Complete quest
          if(quest.type === 'fetch') {
            Object.entries(quest.need).forEach(([item, needed]) => {
              p.inv[item] = (p.inv[item] || 0) - needed;
            });
          }
          
          const goldReward = Number(quest.reward.gold) || 0;
          p.g = Math.max(0, (p.g || 0) + goldReward);
          log("Quest completed: " + quest.name + " (+" + goldReward + " gold)");
          quests.splice(index, 1);
          
          // Refresh the popup after completing quest
          refreshQuestPopup();
          updateUI();
        };
      });
    }
  }

  function openQuests() {
    isQuestPopupOpen = true;
    
    openModal(generateQuestLogHTML(), btn => {
      if(btn.dataset.turn) {
        let index = parseInt(btn.dataset.turn);
        let quest = quests[index];
        
        // Validate quest completion before completing
        let canComplete = true;
        if(quest.type === 'kill') {
          Object.entries(quest.need).forEach(([monster, needed]) => {
            if((quest.progress[monster] || 0) < needed) canComplete = false;
          });
        } else if(quest.type === 'fetch') {
          Object.entries(quest.need).forEach(([item, needed]) => {
            if((p.inv[item] || 0) < needed) canComplete = false;
          });
        }
        
        if(!canComplete) {
          log("Quest requirements not met!");
          return;
        }
        
        // Complete quest
        if(quest.type === 'fetch') {
          Object.entries(quest.need).forEach(([item, needed]) => {
            p.inv[item] = (p.inv[item] || 0) - needed;
          });
        }
        
        const goldReward = Number(quest.reward.gold) || 0;
        p.g = Math.max(0, (p.g || 0) + goldReward);
        log("Quest completed: " + quest.name + " (+" + goldReward + " gold)");
        quests.splice(index, 1);
        
        // Refresh the popup after completing quest
        refreshQuestPopup();
      }
      updateUI();
    });
  }
  
  function openGlobal(){
    let html='<h2 style="color:#2196F3; text-align:center; margin-bottom:15px;">üè™ Global Market</h2>';
    html += `<div style="text-align:center; margin-bottom:20px; padding:8px; background:#333; border-radius:6px; color:#FFD700;">`;
    html += `<strong>Your Gold: ${p.g}</strong>`;
    html += `</div>`;
    
    html+='<h3 style="color:#4CAF50; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:15px;">üí∞ Buy Items (2x Town Price)</h3>';
    html += '<div style="display:grid; gap:8px; margin-bottom:25px;">';
    Object.entries(shops).forEach(([shopName, items]) => {
      let shopColors = {'Potion Seller': '#4CAF50', 'Blacksmith': '#FF5722', 'Scroll Merchant': '#9C27B0'};
      html+=`<div style="margin-bottom:10px;"><h4 style="color:${shopColors[shopName]}; margin-bottom:8px;">${shopName}</h4>`;
      items.forEach(item => {
        let canAfford = (p.g || 0) >= (item.price * 2);
        let btnStyle = `padding:10px; border-radius:6px; border:1px solid ${canAfford ? '#4CAF50' : '#f44336'}; background:${canAfford ? '#2E7D32' : '#333'}; color:${canAfford ? 'white' : '#999'}; cursor:${canAfford ? 'pointer' : 'not-allowed'}; display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;`;
        
        html+=`<button data-buyg="${item.name}" style="${btnStyle}">`;
        html+=`<div style="display:flex; flex-direction:column; align-items:flex-start;">`;
        html+=`<span style="font-weight:bold;">${item.name.replace(/_/g, ' ')}</span>`;
        if(item.desc) {
          html+=`<span style="font-size:0.9em; color:#ccc; margin-top:2px;">${item.desc}</span>`;
        }
        html+=`</div>`;
        html+=`<span style="color:#FFD700; font-weight:bold;">${item.price * 2}g</span>`;
        html+=`</button>`;
      });
      html+=`</div>`;
    });
    html += '</div>';
    
    if(Object.keys(p.inv).some(k => p.inv[k] > 0)) {
      html+='<h3 style="color:#FF9800; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:15px;">üì¶ Sell Items</h3>';
      html += '<div style="display:grid; gap:6px; margin-bottom:25px;">';
      Object.entries(p.inv).forEach(([k,v])=>{
        if(v>0) {
          let btnStyle = `padding:8px; border-radius:6px; border:1px solid #FF9800; background:#E65100; color:white; cursor:pointer; display:flex; justify-content:space-between; align-items:center;`;
          html+=`<button data-sell="${k}" style="${btnStyle}">`;
          html+=`<span>${k.replace(/_/g, ' ')} x${v}</span>`;
          html+=`<span style="color:#FFD700; font-weight:bold;">1g each</span>`;
          html+=`</button>`;
        }
      });
      html += '</div>';
    }
    
    if(p.eq.length > 0) {
      html+='<h3 style="color:#f44336; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:15px;">‚öîÔ∏è Sell Equipment</h3>';
      html += '<div style="display:grid; gap:6px;">';
      p.eq.forEach((item,i)=>{
        let itemDef = itemDefs[item.name];
        let value = itemDef && itemDef.value ? itemDef.value : 5;
        let isEquipped = p.equipped && p.equipped === item;
        let isUnsellable = itemDef && itemDef.unsellable;
        let isDisabled = isEquipped || isUnsellable;
        let btnStyle = `padding:8px; border-radius:6px; border:1px solid #f44336; background:${isDisabled ? '#666' : '#C62828'}; color:${isDisabled ? '#999' : 'white'}; cursor:${isDisabled ? 'not-allowed' : 'pointer'}; display:flex; justify-content:space-between; align-items:center;`;
        
        html+=`<button data-selleq="${i}" style="${btnStyle}">`;
        html+=`<span>${item.name.replace(/_/g, ' ')} Lvl ${item.level || 1} (${item.durability})${isEquipped ? ' [EQUIPPED]' : ''}${isUnsellable ? ' [LEGENDARY]' : ''}</span>`;
        html+=`<span style="color:#FFD700; font-weight:bold;">${isUnsellable ? 'UNSELLABLE' : value + 'g'}</span>`;
        html+=`</button>`;
      });
      html += '</div>';
    }
    
    openModal(html, btn => {
      if(btn.dataset.buyg){
        let itemName = btn.dataset.buyg;
        let shopItem = null;
        Object.values(shops).forEach(shopItems => {
          shopItems.forEach(item => {
            if(item.name === itemName) shopItem = item;
          });
        });
        if(shopItem) {
          showPurchaseConfirmation(shopItem, 'Market', shopItem.price * 2);
        }
      }
      if(btn.dataset.sell){
        let item = btn.dataset.sell;
        if(p.inv[item] > 0) {
          p.inv[item]--;
          p.g = Math.max(0, (p.g || 0) + 1);
          log("Sold " + item + " for 1g");
        }
      }
      if(btn.dataset.selleq){
        let index = parseInt(btn.dataset.selleq);
        let item = p.eq[index];
        let itemDef = itemDefs[item.name];
        let value = itemDef && itemDef.value ? itemDef.value : 5;
        
        if(p.equipped && p.equipped === item) {
          log("Cannot sell equipped item!");
          return;
        }
        
        if(itemDef && itemDef.unsellable) {
          log("This legendary weapon cannot be sold!");
          return;
        }
        
        p.g = Math.max(0, (p.g || 0) + value);
        p.eq.splice(index, 1);
        log("Sold " + item.name + " for " + value + "g");
      }
      updateUI();
    });
  }
  
  function showPurchaseConfirmation(item, shopType, customPrice = null) {
    const price = customPrice || item.price;
    const canAfford = (p.g || 0) >= price;
    
    // Get item effects description
    let effectsHtml = '';
    const itemName = item.name.replace(/_/g, ' ');
    
    // Determine effects based on item type
    if(item.name === 'Health Potion') {
      effectsHtml = '<div style="color:#4CAF50;">‚úì Restores HP to maximum</div>';
    } else if(item.name === 'Strength Potion') {
      effectsHtml = '<div style="color:#FF5722;">‚úì +20 temporary ATK for 10 steps</div>';
    } else if(item.name === 'Scroll of Healing') {
      effectsHtml = '<div style="color:#4CAF50;">‚úì Instantly restore full HP</div>';
    } else if(item.name === 'Luck Charm') {
      effectsHtml = '<div style="color:#FFD700;">‚úì +10 temporary LUCK for 10 steps</div>';
    } else if(itemDefs[item.name] && itemDefs[item.name].boost) {
      // Equipment items
      const boost = itemDefs[item.name].boost;
      effectsHtml = Object.entries(boost).map(([stat, value]) => {
        const statName = stat === 'maxHp' ? 'MAX HP' : stat.toUpperCase();
        return `<div style="color:#9C27B0;">‚úì +${value} ${statName}</div>`;
      }).join('');
      if(itemDefs[item.name].maxD) {
        effectsHtml += `<div style="color:#666;">‚úì ${itemDefs[item.name].maxD} Durability</div>`;
      }
    } else {
      effectsHtml = '<div style="color:#999;">Item effects unknown</div>';
    }
    
    let confirmHtml = `
      <div style="text-align:center; padding:20px;">
        <h3 style="color:#FFD700; margin-bottom:20px;">Purchase Confirmation</h3>
        
        <div style="background:#333; padding:15px; border-radius:8px; margin-bottom:20px;">
          <h4 style="color:#fff; margin-bottom:10px;">${itemName}</h4>
          <div style="margin-bottom:10px;">
            ${effectsHtml}
          </div>
          <div style="color:#FFD700; font-size:18px; font-weight:bold;">
            Price: ${price}g
          </div>
        </div>
        
        <div style="margin-bottom:20px; padding:10px; background:${canAfford ? '#2E7D32' : '#C62828'}; border-radius:6px;">
          <div style="color:white; font-weight:bold;">
            Your Gold: ${p.g}g
          </div>
          ${canAfford ? 
            '<div style="color:#4CAF50; font-size:14px;">‚úì You can afford this item</div>' : 
            '<div style="color:#f44336; font-size:14px;">‚úó Not enough gold</div>'
          }
        </div>
        
        <div style="display:flex; gap:10px; justify-content:center;">
          <button id="confirm-purchase" style="background:${canAfford ? '#4CAF50' : '#666'}; color:white; border:none; padding:12px 24px; border-radius:6px; cursor:${canAfford ? 'pointer' : 'not-allowed'}; font-weight:bold;">
            ${canAfford ? 'Purchase' : 'Cannot Afford'}
          </button>
          <button id="cancel-purchase" style="background:#f44336; color:white; border:none; padding:12px 24px; border-radius:6px; cursor:pointer; font-weight:bold;">
            Cancel
          </button>
        </div>
      </div>
    `;
    
    // Open the confirmation modal
    OV.style.display='block';
    MD.style.display='block';
    MD.innerHTML = confirmHtml;
    
    // Add event listeners
    document.getElementById('confirm-purchase').onclick = () => {
      if(canAfford) {
        // Check if player is dead when buying healing items
        if((item.name === 'Health Potion' || item.name === 'Scroll of Healing') && p.hp <= 0) {
          log("Cannot use healing items when dead! Use Reborn to restart.");
          closeModal();
          return;
        }
        const playerGold = Number(p.g) || 0;
        p.g = Math.max(0, playerGold - price);
        item.apply();
        log(`Bought ${itemName} for ${price}g`);
        closeModal();
        updateUI();
      }
    };
    
    document.getElementById('cancel-purchase').onclick = () => {
      closeModal();
      updateUI();
    };
  }
  
  function openCraft(){
    craftingModalOpen = true;
    updateCraftingDisplay();
  }
  
  function updateCraftingDisplay() {
    if (!craftingModalOpen) return;
    
    let html='<h2 style="color:#FF9800; text-align:center; margin-bottom:15px;">üî® Crafting</h2>';
    let currentCraft = round1(p.craft + (p.tempCraft ? p.tempCraft.value : 0));
    let currentLuck = round1(p.luck + (p.tempLuck ? p.tempLuck.value : 0));
    let totalChance = currentCraft + currentLuck;
    html += `<div style="text-align:center; margin-bottom:20px; padding:10px; background:#2E7D32; border-radius:6px; color:white;">`;
    html += `<strong>Success Chance: ${totalChance}% (${currentCraft}% craft + ${currentLuck}% luck)</strong>`;
    html += `</div>`;
    
    html += '<div style="display:grid; gap:8px;">';
    recipes.forEach(r=>{
      // Hide Broken Stick recipe unless all required items are available
      if(r.name === 'Broken_Stick') {
        let hasAllItems = materials(r.need, r);
        if(!hasAllItems) return; // Skip showing this recipe
      }
      
      let canCraft = materials(r.need, r);
      let btnStyle = `padding:10px; border-radius:6px; border:1px solid ${canCraft ? '#4CAF50' : '#f44336'}; background:${canCraft ? '#2E7D32' : '#333'}; color:${canCraft ? 'white' : '#999'}; cursor:${canCraft ? 'pointer' : 'not-allowed'}; display:flex; justify-content:space-between; align-items:center;`;
      
      html += `<button data-r="${r.name}" style="${btnStyle}">`;
      html += `<div>`;
      html += `<div style="font-weight:bold; margin-bottom:4px;">${r.name.replace(/_/g, ' ')}</div>`;
      
      // Special display for Apex Predator "any 4 of 7" requirement
      if(r.anyFourOf) {
        html += `<div style="font-size:12px; opacity:0.8;">Materials: Any 4 of these 7 items</div>`;
        html += `<div style="font-size:11px; opacity:0.6;">${Object.entries(r.need).map(e=>e.join('x')).join(', ')}</div>`;
        const availableItems = Object.keys(r.need).filter(item => (p.inv[item] || 0) >= r.need[item]);
        html += `<div style="font-size:11px; color:#FFD700;">Available: ${availableItems.length}/4 required</div>`;
      } else {
        html += `<div style="font-size:12px; opacity:0.8;">Materials: ${Object.entries(r.need).map(e=>e.join('x')).join(', ')}</div>`;
      }
      html += `</div>`;
      html += `<div style="text-align:right;">`;
      html += `<div style="font-size:12px; color:#FFD700;">${totalChance}% chance</div>`;
      html += `<div style="font-size:10px; opacity:0.6;">+0.1 skill</div>`;
      html += `</div>`;
      html += `</button>`;
    });
    html += '</div>';
    
    // Update modal content
    MD.innerHTML = html;
    
    // Re-add event listeners
    document.querySelectorAll('[data-r]').forEach(btn => {
      btn.onclick = () => {
        if(btn.dataset.r){
          let recipe = recipes.find(r => r.name === btn.dataset.r);
          if(materials(recipe.need, recipe)){
            // Special handling for Apex Predator "any 4 of 7" requirement
            if(recipe.anyFourOf) {
              const availableItems = Object.keys(recipe.need).filter(item => (p.inv[item] || 0) >= recipe.need[item]);
              // Select first 4 available items
              const selectedItems = availableItems.slice(0, 4);
              selectedItems.forEach(item => {
                p.inv[item] -= recipe.need[item];
                if(p.inv[item] <= 0) delete p.inv[item];
              });
            } else {
              // Always consume materials on attempt
              Object.keys(recipe.need).forEach(k=>p.inv[k]-=recipe.need[k]);
            }
            
            // Always increase craft skill by 0.1
            p.craft = round1(p.craft + 0.1);
            
            // Reduce tempCraft attempts
            if(p.tempCraft){
              p.tempCraft.steps--;
              if(p.tempCraft.steps <= 0){
                p.tempCraft = null;
                log("Crafting potion wore off!");
              }
            }
            
            // Check if crafting succeeded based on percentage (craft skill + luck bonus)
            let currentLuck = round1(p.luck + (p.tempLuck ? p.tempLuck.value : 0));
            let craftChance = round1(p.craft + (p.tempCraft ? p.tempCraft.value : 0) + currentLuck);
            let craftRoll = Math.random() * 100;
            
            if(craftRoll <= craftChance) {
              // Check if item is equipment (has definition in itemDefs)
              if(itemDefs[recipe.name]) {
                // It's equipment - add to equipment array
                const itemDef = itemDefs[recipe.name];
                const durability = typeof itemDef.maxD === 'function' ? itemDef.maxD() : itemDef.maxD;
                p.eq.push({
                  name: recipe.name,
                  durability: durability,
                  level: itemDef.level || 1,
                  boost: itemDef.boost
                });
                log(`Crafting SUCCESS! Made ${recipe.name.replace(/_/g, ' ')} (${craftChance}% chance, rolled ${round1(craftRoll)})`);
              } else {
                // It's a consumable - add to inventory
                p.inv[recipe.name]=(p.inv[recipe.name]||0)+1;
                log(`Crafting SUCCESS! Made ${recipe.name.replace(/_/g, ' ')} (${craftChance}% chance, rolled ${round1(craftRoll)})`);
              }
            } else {
              log(`Crafting FAILED! Lost materials (${craftChance}% chance, rolled ${round1(craftRoll)})`);
            }
            
            log(`Craft skill increased to ${round1(p.craft)}`);
            updateUI();
            updateRealTimeDisplays(); // Refresh all displays
            updateCraftingDisplay(); // Update the crafting interface in real-time
          } else {
            log("Missing materials");
          }
        }
      };
    });
    
    openModal(html, btn => {
      if(btn.dataset.r){
        let recipe = recipes.find(r => r.name === btn.dataset.r);
        if(materials(recipe.need)){
          // Always consume materials on attempt
          Object.keys(recipe.need).forEach(k=>p.inv[k]-=recipe.need[k]);
          
          // Always increase craft skill by 0.1
          p.craft = round1(p.craft + 0.1);
          
          // Reduce tempCraft attempts
          if(p.tempCraft){
            p.tempCraft.steps--;
            if(p.tempCraft.steps <= 0){
              p.tempCraft = null;
              log("Crafting potion wore off!");
            }
          }
          
          // Check if crafting succeeded based on percentage (craft skill + luck bonus)
          let currentLuck = round1(p.luck + (p.tempLuck ? p.tempLuck.value : 0));
          let craftChance = round1(p.craft + (p.tempCraft ? p.tempCraft.value : 0) + currentLuck);
          let craftRoll = Math.random() * 100;
          
          if(craftRoll <= craftChance) {
            // Check if item is equipment (has definition in itemDefs)
            if(itemDefs[recipe.name]) {
              // It's equipment - add to equipment array
              const itemDef = itemDefs[recipe.name];
              const durability = typeof itemDef.maxD === 'function' ? itemDef.maxD() : itemDef.maxD;
              p.eq.push({
                name: recipe.name,
                durability: durability,
                level: itemDef.level || 1,
                boost: itemDef.boost
              });
              log(`Crafting SUCCESS! Made ${recipe.name.replace(/_/g, ' ')} (${craftChance}% chance, rolled ${round1(craftRoll)})`);
            } else {
              // It's a consumable - add to inventory
              p.inv[recipe.name]=(p.inv[recipe.name]||0)+1;
              log(`Crafting SUCCESS! Made ${recipe.name.replace(/_/g, ' ')} (${craftChance}% chance, rolled ${round1(craftRoll)})`);
            }
          } else {
            log(`Crafting FAILED! Lost materials (${craftChance}% chance, rolled ${round1(craftRoll)})`);
          }
          
          log(`Craft skill increased to ${round1(p.craft)}`);
        } else log("Missing materials");
      }
      updateUI();
      updateRealTimeDisplays(); // Refresh all displays
      updateCraftingDisplay(); // Update the crafting interface in real-time
    });
  }
  
  // Global variables to track if modals are open
  let inventoryModalOpen = false;
  let craftingModalOpen = false;
  
  // Function to update all real-time displays
  function updateRealTimeDisplays() {
    updateInventoryDisplay();
    updateCraftingDisplay();
  }
  
  function openInventory() {
    inventoryModalOpen = true;
    updateInventoryDisplay();
  }
  
  function updateInventoryDisplay() {
    if (!inventoryModalOpen) return;
    
    let html = '<h2 style="color:#4CAF50; text-align:center; margin-bottom:15px;">üì¶ Inventory</h2>';
    

    
    if(Object.keys(p.inv).length === 0 && p.eq.length === 0) {
      html += '<div style="text-align:center; color:#888; padding:20px;">Empty inventory</div>';
    } else {
      // Show items
      if(Object.keys(p.inv).some(item => p.inv[item] > 0)) {
        html += '<h3 style="color:#FFD700; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:10px;">üçæ Items</h3>';
        html += '<div style="display:grid; gap:8px; margin-bottom:15px;">';
        Object.entries(p.inv).forEach(([item, count]) => {
          if(count > 0) {
            let itemStyle = 'padding:8px 12px; background:#333; border-radius:5px; border:1px solid #555; display:flex; justify-content:space-between; align-items:center;';
            html += `<div style="${itemStyle}">`;
            html += `<span style="color:#eee;">${item.replace(/_/g, ' ')} x${count}</span>`;
            html += `<div style="display:flex; gap:5px;">`;
            
            // Add use buttons for potions
            if(item === 'Health Potion') {
              html += ` <button data-use-health="${item}" style="background:#4CAF50; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Use</button>`;
            }
            if(item === 'Strength Potion') {
              html += ` <button data-use-strength="${item}" style="background:#FF9800; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Use</button>`;
            }
            if(item === 'Rage Potion') {
              html += ` <button data-use-rage="${item}" style="background:#f44336; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Use</button>`;
            }
            if(item === 'Scroll of Healing') {
              html += ` <button data-use-scroll="${item}" style="background:#4CAF50; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Use</button>`;
            }
            if(item === 'Resurrection_Charm') {
              html += ` <button data-use-resurrection="${item}" style="background:#9C27B0; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Use</button>`;
            }
            if(item === 'Asura_Blood') {
              html += ` <button data-use-asura="${item}" style="background:#FF5722; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Use</button>`;
            }
            if(item === 'Berserker\'s Blend') {
              html += ` <button data-use-berserker="${item}" style="background:#9C27B0; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Use</button>`;
            }
            if(item === 'Battle Brew') {
              html += ` <button data-use-battle="${item}" style="background:#FF9800; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Use</button>`;
            }
            // Add equip button for equipment items that ended up in inventory (but not consumables)
            if(itemDefs[item] && !itemDefs[item].consumable) {
              html += ` <button data-move-to-eq="${item}" style="background:#2196F3; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Move to Equipment</button>`;
            }
            
            html += `</div></div>`;
          }
        });
        html += '</div>';
      }
      
      // Show equipment
      if(p.eq.length > 0) {
        html += '<h3 style="color:#FF6B6B; border-bottom:1px solid #555; padding-bottom:5px; margin-bottom:10px;">‚öîÔ∏è Equipment</h3>';
        html += '<div style="display:grid; gap:8px;">';
        p.eq.forEach((item, index) => {
          let isEquipped = p.equipped && p.equipped === item;
          let itemStyle = `padding:8px 12px; background:${isEquipped ? '#2E7D32' : '#333'}; border-radius:5px; border:1px solid ${isEquipped ? '#4CAF50' : '#555'}; display:flex; justify-content:space-between; align-items:center;`;
          
          html += `<div style="${itemStyle}">`;
          html += `<span style="color:#eee;">${item.name.replace(/_/g, ' ')} Lvl ${item.level || 1} (${item.durability} dur)${isEquipped ? ' [EQUIPPED]' : ''}</span>`;
          html += `<div style="display:flex; gap:5px;">`;
          
          if (itemDefs[item.name]) {
            if (!isEquipped) {
              html += ` <button data-equip="${index}" style="background:#2196F3; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Equip</button>`;
            } else {
              html += ` <button data-unequip="${index}" style="background:#FF5722; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer;">Unequip</button>`;
            }
          }
          
          html += `</div></div>`;
        });
        html += '</div>';
      }
    }
    
    openModal(html, btn => {
      if (btn.dataset.equip !== undefined) {
        const index = parseInt(btn.dataset.equip);
        equipItem(p.eq[index]);
        updateInventoryDisplay(); // Update inventory display in real-time
      }
      if (btn.dataset.unequip !== undefined) {
        unequipItem();
        updateInventoryDisplay(); // Update inventory display in real-time
      }
      if (btn.dataset.useHealth !== undefined) {
        if (p.hp <= 0) {
          log("Cannot use healing items when dead! Use Reborn to restart.");
          return;
        }
        const potion = btn.dataset.useHealth;
        if(p.inv[potion] > 0) {
          p.inv[potion]--;
          if(p.inv[potion] <= 0) {
            delete p.inv[potion];
          }
          p.hp = round1(Math.min(p.maxHp, p.hp + 10));
          log("Used Health Potion (+10 HP)");
          closeModal();
          updateInventoryDisplay(); // Refresh inventory
        }
      }
      if (btn.dataset.useStrength !== undefined) {
        const potion = btn.dataset.useStrength;
        if(p.inv[potion] > 0) {
          p.inv[potion]--;
          if(p.inv[potion] <= 0) {
            delete p.inv[potion];
          }
          const newValue = roll(10,20);
          const newSteps = roll(30,90);
          applyPotionEffect({atk: newValue, steps: newSteps}, 'Strength Potion');
          updateRealTimeDisplays(); // Update stats display
          closeModal();
          updateInventoryDisplay(); // Refresh inventory
        }
      }
      if (btn.dataset.useRage !== undefined) {
        const potion = btn.dataset.useRage;
        if(p.inv[potion] > 0) {
          p.inv[potion]--;
          if(p.inv[potion] <= 0) {
            delete p.inv[potion];
          }
          p.atk = round1(p.atk + 0.5);
          p.maxHp = Math.max(1, round1(p.maxHp - 5));
          p.hp = Math.min(p.hp, p.maxHp);
          log("Rage Potion: +0.5 ATK, -5 max HP permanently!");
          closeModal();
          updateInventoryDisplay(); // Refresh inventory
        }
      }
      if (btn.dataset.useScroll !== undefined) {
        if (p.hp <= 0) {
          log("Cannot use healing items when dead! Use Reborn to restart.");
          return;
        }
        const scroll = btn.dataset.useScroll;
        if(p.inv[scroll] > 0) {
          p.inv[scroll]--;
          if(p.inv[scroll] <= 0) {
            delete p.inv[scroll];
          }
          p.hp = p.maxHp;
          log(`Used Scroll of Healing (Full HP restored)`);
          closeModal();
          updateInventoryDisplay(); // Refresh inventory
        }
      }
      if (btn.dataset.useResurrection !== undefined) {
        const charm = btn.dataset.useResurrection;
        if(p.inv[charm] > 0) {
          p.inv[charm]--;
          if(p.inv[charm] <= 0) {
            delete p.inv[charm];
          }
          p.resurrectionCharm = true;
          log(`Used Resurrection Charm - You will be reborn with all stats intact on next death!`);
          closeModal();
          updateInventoryDisplay(); // Refresh inventory
        }
      }
      if (btn.dataset.useAsura !== undefined) {
        const blood = btn.dataset.useAsura;
        if(p.inv[blood] > 0) {
          p.inv[blood]--;
          if(p.inv[blood] <= 0) {
            delete p.inv[blood];
          }
          // Store current stats for restoration later
          p.asuraBlood = {
            originalAtk: p.atk,
            originalDef: p.def,
            originalMaxHp: p.maxHp,
            originalLuck: p.luck,
            originalCraft: p.craft,
            boostSteps: 100,
            debuffSteps: 50,
            active: true
          };
          // Apply 100x boost to all stats
          p.atk = round1(p.atk * 100);
          p.def = round1(p.def * 100);
          p.maxHp = round1(p.maxHp * 100);
          p.hp = round1(p.hp * 100);
          p.luck = round1(p.luck * 100);
          p.craft = round1(p.craft * 100);
          log(`Used Asura Blood - All stats boosted by 100x for 100 steps!`);
          closeModal();
          updateInventoryDisplay(); // Refresh inventory
        }
      }
      if (btn.dataset.useBerserker !== undefined) {
        const potion = btn.dataset.useBerserker;
        if(p.inv[potion] > 0) {
          p.inv[potion]--;
          if(p.inv[potion] <= 0) {
            delete p.inv[potion];
          }
          applyPotionEffect({atk: 10, def: 10, steps: 40}, 'Berserker\'s Blend');
          updateRealTimeDisplays();
          closeModal();
          updateInventoryDisplay();
        }
      }
      if (btn.dataset.useBattle !== undefined) {
        const potion = btn.dataset.useBattle;
        if(p.inv[potion] > 0) {
          p.inv[potion]--;
          if(p.inv[potion] <= 0) {
            delete p.inv[potion];
          }
          applyPotionEffect({atk: 12, def: 8, luck: 5, steps: 30}, 'Battle Brew');
          updateRealTimeDisplays();
          closeModal();
          updateInventoryDisplay();
        }
      }
      if (btn.dataset.moveToEq !== undefined) {
        const itemName = btn.dataset.moveToEq;
        if(p.inv[itemName] > 0 && itemDefs[itemName]) {
          // Remove from inventory
          p.inv[itemName]--;
          if(p.inv[itemName] <= 0) {
            delete p.inv[itemName];
          }
          
          // Add to equipment
          const itemDef = itemDefs[itemName];
          const durability = typeof itemDef.maxD === 'function' ? itemDef.maxD() : itemDef.maxD;
          p.eq.push({
            name: itemName,
            durability: durability,
            level: itemDef.level || 1,
            boost: itemDef.boost
          });
          log(`Moved ${itemName.replace(/_/g, ' ')} to equipment`);
        }
      }
      updateUI();
    });
  }
  
  function showQuestPopup(n) {
    const q = n.quest;
    let questType = q.type === 'kill' ? 'Kill Quest' : 'Fetch Quest';
    
    let requirementText = '';
    if(q.type === 'kill') {
      requirementText = Object.entries(q.need).map(([monster, count]) => 
        `${monster.replace(/_/g, ' ')} x${count}`
      ).join(', ');
    } else {
      requirementText = Object.entries(q.need).map(e => e.join(' x ')).join(', ');
    }
    
    let rewardText = '';
    if(q.rewardGold) {
      rewardText = `${q.rewardGold} gold`;
    } else if(q.reward) {
      rewardText = q.reward;
    }
    
    let html = `
      <h2>Quest from ${n.profession}</h2>
      <div class="quest-details">
        <p><strong>Type:</strong> ${questType}</p>
        <p><strong>Required:</strong> ${requirementText}</p>
        <p><strong>Reward:</strong> ${rewardText}</p>
      </div>
      <div class="quest-options">
        <button class="quest-accept" data-accept="true">Accept</button>
        <button class="quest-decline" data-accept="false">Decline</button>
      </div>
    `;
    
    QM.innerHTML = html;
    QM.style.display = 'block';
    OV.style.display = 'block';
    
    QM.querySelectorAll('button').forEach(btn => {
      btn.onclick = (e) => {
        e.stopPropagation();
        if (btn.dataset.accept === 'true') {
          acceptQuest(n);
        }
        closeQuestPopup();
      };
    });
  }
  
  function showTownQuestPopup(quest) {
    let html = `
      <h2>Quest: ${quest.name}</h2>
      <div class="quest-details">
        <p><strong>Description:</strong> ${quest.desc}</p>
        <p><strong>Reward:</strong> ${quest.reward.gold} gold</p>
      </div>
      <div class="quest-options">
        <button class="quest-accept" data-accept="true">Accept</button>
        <button class="quest-decline" data-accept="false">Decline</button>
      </div>
    `;
    
    QM.innerHTML = html;
    QM.style.display = 'block';
    OV.style.display = 'block';
    
    QM.querySelectorAll('button').forEach(btn => {
      btn.onclick = (e) => {
        e.stopPropagation();
        if (btn.dataset.accept === 'true') {
          quests.push({
            name: quest.name,
            type: quest.type,
            desc: quest.desc,
            need: quest.need,
            progress: {},
            reward: quest.reward,
            state: 1
          });
          log("Accepted quest: " + quest.name);
        }
        closeQuestPopup();
      };
    });
  }
  
  function acceptQuest(n) {
    const q = n.quest;
    q.state = 1;
    
    let questName = (q.type === 'kill' ? 'K' : 'F') + n.profession;
    let questDesc = '';
    
    if(q.type === 'kill') {
      questDesc = 'Kill ' + Object.entries(q.need).map(([monster, count]) => 
        `${monster.replace(/_/g, ' ')} x${count}`
      ).join(', ');
    } else {
      questDesc = 'Bring ' + Object.entries(q.need).map(e => e.join('x')).join(', ');
    }
    
    if(q.rewardGold) {
      questDesc += ` (Reward: ${q.rewardGold}g)`;
    } else if(q.reward) {
      questDesc += ` (Reward: ${q.reward})`;
    }
    
    const quest = {
      name: questName,
      type: q.type,
      desc: questDesc,
      need: q.need,
      progress: {},
      reward: { item: q.reward, gold: q.rewardGold },
      state: 1
    };
    
    // Initialize quest progress counters to 0 for kill quests
    if (quest.type === 'kill') {
      Object.keys(quest.need).forEach(monster => {
        quest.progress[monster] = 0;
      });
    }
    
    quests.push(quest);
    log("Accepted quest from " + n.profession);
  }
  
  function closeQuestPopup() {
    QM.style.display = 'none';
    OV.style.display = 'none';
  }
  
  function materials(req, recipe = null){
    // Special handling for Apex Predator "any 4 of 7" requirement
    if(recipe && recipe.anyFourOf) {
      const availableItems = Object.keys(req).filter(item => (p.inv[item] || 0) >= req[item]);
      return availableItems.length >= 4;
    }
    
    for(let k in req){
      if((p.inv[k]||0)<req[k]) return false;
    }
    return true;
  }
  
  function equip(nm){
    let def=itemDefs[nm];
    let maxDurability = typeof def.maxD === 'function' ? def.maxD() : def.maxD;
    let d=roll(1,maxDurability);
    p.eq.push({name:nm,durability:d,level:def.level||1});
    log("Got "+nm+"("+d+")");
  }
  
  function equipItem(item) {
    // Validate item definition exists
    if(!itemDefs[item.name]) {
      log("Error: Unknown item " + item.name);
      return;
    }
    
    // Unequip current item first if any
    if(p.equipped){
      let boostToRemove = p.equipped.boost || itemDefs[p.equipped.name].boost;
      if(boostToRemove) {
        Object.entries(boostToRemove).forEach(([stat,value])=>{
          p[stat] = round1(p[stat] - value);
        });
        log("Unequipped " + p.equipped.name);
      }
    }
    
    // Equip new item
    p.equipped = item;
    let boostToUse = item.boost || itemDefs[item.name].boost;
    if(boostToUse) {
      Object.entries(boostToUse).forEach(([stat,value])=>{
        p[stat] = round1(p[stat] + value);
      });
    }
    log("Equipped " + item.name);
    updateRealTimeDisplays(); // Update all displays when equipment changes
  }
  
  function unequipItem() {
    if(p.equipped) {
      let boostToRemove = p.equipped.boost || itemDefs[p.equipped.name].boost;
      if(boostToRemove) {
        Object.entries(boostToRemove).forEach(([stat,value])=>{
          p[stat] = round1(p[stat] - value);
        });
      }
      log("Unequipped " + p.equipped.name);
      p.equipped = null;
      updateRealTimeDisplays(); // Update all displays when equipment changes
    }
  }
  
  // Modal
  function openModal(html,act){
    OV.style.display='block';
    MD.style.display='block';
    MD.innerHTML=html+"<br><button id='close' style='background:#f44336; color:white; border:none; padding:10px 20px; border-radius:6px; cursor:pointer; font-weight:bold; margin-top:15px; display:block; margin-left:auto; margin-right:auto;'>‚úï Close</button>";
    d('#close').onclick=()=>{
      closeModal();
      updateUI();
    };
    if(act) {
      MD.querySelectorAll('button[data-buy],button[data-buyg],button[data-sell],button[data-selleq],button[data-q],button[data-r],button[data-turn],button[data-equip],button[data-unequip],button[data-use-health],button[data-use-strength],button[data-use-rage],button[data-use-scroll],button[data-use-resurrection],button[data-use-asura],button[data-move-to-eq],button[data-combine],button[data-deposit],button[data-deposit-all],button[data-withdraw],button[data-withdraw-all],button[data-repair],button[data-iron-repair]').forEach(b=>{
        b.onclick=(e)=>{
          e.preventDefault();
          act(b);
        };
      });
    }
  }
  
  function openBanker(){
    let html = '<h2 style="color:#FFD700; text-align:center; margin-bottom:15px;">üí∞ Bank Services</h2>';
    
    // Show financial statement if player has gold stored
    if(p.bankGold > 0) {
      html += '<div style="background:#2E7D32; padding:15px; border-radius:8px; margin-bottom:20px; border:1px solid #4CAF50;">';
      html += '<h3 style="color:#FFD700; margin:0 0 10px 0; text-align:center;">üíº Financial Statement</h3>';
      html += `<div style="color:white; line-height:1.6;">`;
      html += `<div>üí∞ Gold in Bank: <span style="color:#FFD700; font-weight:bold;">${p.bankGold}</span></div>`;
      html += `<div>‚ò†Ô∏è Deaths Since Banking: <span style="color:#ff6666; font-weight:bold;">${p.bankDeaths}</span></div>`;
      if(p.bankDeaths > 0) {
        html += `<div style="margin-top:8px; padding:8px; background:#8B0000; border-radius:4px; border:1px solid #ff4444;">`;
        html += `‚ö†Ô∏è Outstanding Fees: <span style="color:#ffff00; font-weight:bold;">${p.bankDeaths * 10} gold</span>`;
        html += `</div>`;
      }
      html += `</div></div>`;
    }
    
    html += `<div style="text-align:center; margin-bottom:20px; padding:10px; background:#333; border-radius:6px; color:#FFD700;">`;
    html += `<strong>Your Current Gold: ${p.g}</strong>`;
    html += `</div>`;
    
    html += '<div style="display:grid; gap:12px;">';
    
    // Deposit section
    html += '<div style="background:#1a1a1a; padding:15px; border-radius:8px; border:1px solid #555;">';
    html += '<h3 style="color:#4CAF50; margin:0 0 10px 0;">üíµ Deposit Gold</h3>';
    html += '<div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">';
    html += '<input type="number" id="deposit-amount" placeholder="Amount" min="1" max="' + p.g + '" style="flex:1; padding:8px; border-radius:4px; border:1px solid #555; background:#333; color:white;">';
    html += '<button data-deposit style="background:#4CAF50; color:white; border:none; padding:8px 12px; border-radius:4px; cursor:pointer;">Deposit</button>';
    html += '</div>';
    html += '<button data-deposit-all style="background:#2E7D32; color:white; border:none; padding:8px 12px; border-radius:4px; cursor:pointer; width:100%;">Deposit All</button>';
    html += '</div>';
    
    // Withdrawal section (only if has gold in bank)
    if(p.bankGold > 0) {
      const availableGold = Math.max(0, p.bankGold - (p.bankDeaths * 10));
      html += '<div style="background:#1a1a1a; padding:15px; border-radius:8px; border:1px solid #555;">';
      html += '<h3 style="color:#FF9800; margin:0 0 10px 0;">üí∏ Withdraw Gold</h3>';
      if(p.bankDeaths > 0) {
        html += `<div style="color:#ffaa00; margin-bottom:10px; font-size:0.9em;">Note: ${p.bankDeaths * 10} gold will be deducted as death fees</div>`;
      }
      html += `<div style="color:#ccc; margin-bottom:10px;">Available: ${availableGold} gold</div>`;
      html += '<div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">';
      html += '<input type="number" id="withdraw-amount" placeholder="Amount" min="1" max="' + availableGold + '" style="flex:1; padding:8px; border-radius:4px; border:1px solid #555; background:#333; color:white;">';
      html += '<button data-withdraw style="background:#FF9800; color:white; border:none; padding:8px 12px; border-radius:4px; cursor:pointer;">Withdraw</button>';
      html += '</div>';
      html += '<button data-withdraw-all style="background:#F57C00; color:white; border:none; padding:8px 12px; border-radius:4px; cursor:pointer; width:100%;">Withdraw All</button>';
      html += '</div>';
    }
    
    html += '</div>';
    
    html += '<div style="margin-top:20px; padding:12px; background:#1a1a1a; border-radius:6px; border:1px solid #555; color:#ccc; font-size:0.9em;">';
    html += '<strong style="color:#FFD700;">Banking Services:</strong><br>';
    html += '‚Ä¢ Your banked gold is safe even if you die<br>';
    html += '‚Ä¢ 10 gold fee charged per death (only if you have banked gold)<br>';
    html += '‚Ä¢ Bank resets if you die without any gold stored<br>';
    html += '‚Ä¢ Account automatically closes if remaining gold after fees would be less than 10<br>';
    html += '‚Ä¢ Banking data persists through reborn (unless account was closed)';
    html += '</div>';
    
    openModal(html, btn => {
      if (btn.dataset.deposit !== undefined) {
        const amount = parseInt(document.getElementById('deposit-amount').value);
        if(amount > 0 && amount <= p.g) {
          p.g = Math.max(0, p.g - amount);
          p.bankGold = Math.max(0, (p.bankGold || 0) + amount);
          log(`Deposited ${amount} gold. Bank balance: ${p.bankGold}`);
          closeModal();
          openBanker(); // Refresh the interface
        }
      }
      if (btn.dataset.depositAll !== undefined) {
        if(p.g > 0) {
          const amount = p.g;
          p.bankGold = Math.max(0, (p.bankGold || 0) + amount);
          p.g = 0;
          log(`Deposited all ${amount} gold. Bank balance: ${p.bankGold}`);
          closeModal();
          openBanker(); // Refresh the interface
        }
      }
      if (btn.dataset.withdraw !== undefined) {
        const amount = parseInt(document.getElementById('withdraw-amount').value);
        const fees = p.bankDeaths * 10;
        const available = Math.max(0, p.bankGold - fees);
        if(amount > 0 && amount <= available) {
          p.g = Math.max(0, (p.g || 0) + amount);
          p.bankGold = Math.max(0, p.bankGold - amount);
          // Deduct fees
          if(fees > 0) {
            p.bankGold = Math.max(0, p.bankGold - fees);
            p.bankDeaths = 0;
            log(`Withdrew ${amount} gold. Death fees (${fees} gold) deducted. Bank balance: ${p.bankGold}`);
          } else {
            log(`Withdrew ${amount} gold. Bank balance: ${p.bankGold}`);
          }
          closeModal();
          openBanker(); // Refresh the interface
        }
      }
      if (btn.dataset.withdrawAll !== undefined) {
        const fees = p.bankDeaths * 10;
        const available = Math.max(0, p.bankGold - fees);
        if(available > 0) {
          p.g = Math.max(0, (p.g || 0) + available);
          p.bankGold = Math.max(0, p.bankGold - available);
          // Deduct fees
          if(fees > 0) {
            p.bankGold = Math.max(0, p.bankGold - fees);
            p.bankDeaths = 0;
            log(`Withdrew all ${available} gold. Death fees (${fees} gold) deducted. Bank balance: ${p.bankGold}`);
          } else {
            log(`Withdrew all ${available} gold. Bank balance: ${p.bankGold}`);
          }
          closeModal();
          openBanker(); // Refresh the interface
        }
      }
      updateUI();
    });
  }
  
  function openCombiner(){
    let html = '<h3>Equipment Combiner</h3>';
    html += '<p>I can combine 2 identical equipment pieces into a stronger version!</p>';
    html += '<p>Cost: Level 1‚Üí2: 100g, Level 2‚Üí3: 200g, Level 3‚Üí4: 300g, etc.</p>';
    html += '<p>Stats increase by 50%, durability adds up (max 100)</p>';
    html += '<p style="color:#f44336;">Note: Level 15 boss weapons cannot be combined!</p>';
    
    // Find combinable equipment (excluding Level 15 boss weapons)
    const excludedWeapons = ['Tidepiercer', 'Nova_Maul', 'Stormfang_Katana'];
    const equipmentCounts = {};
    p.eq.forEach(eq => {
      if (excludedWeapons.includes(eq.name)) return; // Skip Level 15 boss weapons
      const key = `${eq.name}_${eq.level || 1}`;
      if (!equipmentCounts[key]) equipmentCounts[key] = [];
      equipmentCounts[key].push(eq);
    });
    
    html += '<br><h4>Available Combinations:</h4>';
    let hasOptions = false;
    
    Object.entries(equipmentCounts).forEach(([key, items]) => {
      if(items.length >= 2) {
        hasOptions = true;
        const lastUnderscoreIndex = key.lastIndexOf('_');
        const name = key.substring(0, lastUnderscoreIndex);
        const level = key.substring(lastUnderscoreIndex + 1);
        const displayName = name;
        const cost = parseInt(level) * 100;
        const currentLevel = parseInt(level);
        const newLevel = currentLevel + 1;
        
        html += `<div style="margin: 10px 0; padding: 10px; background: #333; border-radius: 5px;">`;
        html += `<p>${displayName} Level ${currentLevel} ‚Üí Level ${newLevel}</p>`;
        html += `<p>Cost: ${cost}g (Have: ${items.length} pieces)</p>`;
        html += `<button data-combine="${name}_${level}" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Combine</button>`;
        html += `</div>`;
      }
    });
    
    if(!hasOptions) {
      html += '<p style="color: #999;">No equipment available for combining.</p>';
    }
    
    openModal(html, (btn) => {
      if(btn.dataset.combine) {
        const lastUnderscoreIndex = btn.dataset.combine.lastIndexOf('_');
        const name = btn.dataset.combine.substring(0, lastUnderscoreIndex);
        const level = btn.dataset.combine.substring(lastUnderscoreIndex + 1);
        combineEquipment(name, parseInt(level));
      }
    });
  }
  
  function combineEquipment(equipmentName, level) {
    const cost = level * 100;
    
    if(p.g < cost) {
      log("Not enough gold! Need " + cost + "g");
      return;
    }
    
    // Find two pieces of the same equipment and level
    const targetEquipment = p.eq.filter(eq => eq.name === equipmentName && (eq.level || 1) == level);
    
    if(targetEquipment.length < 2) {
      log("Need at least 2 pieces of the same equipment!");
      return;
    }
    
    // Remove the two pieces
    const piece1 = targetEquipment[0];
    const piece2 = targetEquipment[1];
    
    // Remove from equipment array
    const index1 = p.eq.indexOf(piece1);
    const index2 = p.eq.indexOf(piece2);
    p.eq.splice(Math.max(index1, index2), 1);
    p.eq.splice(Math.min(index1, index2), 1);
    
    // Create new combined piece
    const itemDef = itemDefs[equipmentName];
    const newLevel = level + 1;
    const newBoost = {};
    
    // Calculate new stats (50% increase from piece1's current stats)
    const baseBoost = piece1.boost || itemDef.boost;
    Object.entries(baseBoost).forEach(([stat, value]) => {
      newBoost[stat] = Math.floor(value * 1.5);
    });
    
    // Calculate new durability (add both durabilities, cap at 100)
    const newDurability = Math.min(100, piece1.durability + piece2.durability);
    
    const newItem = {
      name: equipmentName,
      level: newLevel,
      durability: newDurability,
      boost: newBoost
    };
    
    p.eq.push(newItem);
    
    p.g -= cost;
    log(`Combined ${equipmentName} into Level ${newLevel}!`);
    log(`New stats: ${JSON.stringify(newBoost)}, Durability: ${newDurability}`);
    
    closeModal();
    updateUI();
  }

  function openRepairer(){
    let html = '<h2 style="color:#FFD700; text-align:center; margin-bottom:15px;">üîß Equipment Repairer</h2>';
    html += '<p style="text-align:center; color:#ccc; margin-bottom:10px;">I only repair Level 2+ equipment! Choose your repair method:</p>';
    html += '<p style="text-align:center; color:#FFD700; margin-bottom:10px;">Option 1: Level 1 version + 100 gold (adds 20-60 durability)</p>';
    html += '<p style="text-align:center; color:#4CAF50; margin-bottom:20px;">Option 2: 10 iron ore + 200 gold (adds 10 durability)</p>';
    html += `<div style="text-align:center; margin-bottom:20px; padding:8px; background:#333; border-radius:6px; color:#FFD700;">`;
    html += `<strong>Your Gold: ${p.g} | Iron Ore: ${p.inv['Iron Ore'] || 0}</strong>`;
    html += `</div>`;
    
    // Find damaged equipment (durability < 100 and level 2+)
    const damagedEquipment = p.eq.filter(eq => eq.durability < 100 && (eq.level || 1) >= 2);
    
    if(damagedEquipment.length === 0) {
      html += '<p style="color:#4CAF50; text-align:center;">All your equipment is in perfect condition!</p>';
    } else {
      html += '<h3 style="color:#ff9999; margin-bottom:10px;">Damaged Equipment:</h3>';
      html += '<div style="display:grid; gap:8px; margin-bottom:20px;">';
      
      damagedEquipment.forEach((eq, index) => {
        // Check if player has a level 1 version of this equipment
        const level1Version = p.eq.find(item => item.name === eq.name && (item.level || 1) === 1 && item !== eq);
        const canLevel1Repair = level1Version && p.g >= 100;
        
        // Check iron ore repair option
        const ironOre = p.inv['Iron Ore'] || 0;
        const canIronRepair = ironOre >= 10 && p.g >= 200;
        
        const durabilityColor = eq.durability < 30 ? '#ff4444' : eq.durability < 70 ? '#ffaa00' : '#ffff00';
        
        html += `<div style="padding:12px; border-radius:6px; border:1px solid #444; background:#333; color:white; margin-bottom:10px;">`;
        html += `<div style="display:flex; flex-direction:column; align-items:flex-start; margin-bottom:10px;">`;
        html += `<span style="font-weight:bold;">${eq.name.replace(/_/g, ' ')} Level ${eq.level || 1}</span>`;
        html += `<span style="color:${durabilityColor}; font-size:0.9em;">Durability: ${eq.durability}/100</span>`;
        html += `</div>`;
        
        html += `<div style="display:flex; gap:10px; flex-wrap:wrap;">`;
        
        // Level 1 repair option
        if(canLevel1Repair) {
          html += `<button data-repair="${index}" style="background:#4CAF50; color:white; border:none; padding:8px 12px; border-radius:4px; cursor:pointer;">Level 1 Repair (100g)</button>`;
        } else {
          let reason = !level1Version ? 'Need Level 1 version' : 'Need 100 gold';
          html += `<button style="background:#666; color:#999; border:none; padding:8px 12px; border-radius:4px; cursor:not-allowed;">${reason}</button>`;
        }
        
        // Iron ore repair option
        if(canIronRepair) {
          html += `<button data-iron-repair="${index}" style="background:#FF9800; color:white; border:none; padding:8px 12px; border-radius:4px; cursor:pointer;">Iron Ore Repair (200g)</button>`;
        } else {
          html += `<button style="background:#666; color:#999; border:none; padding:8px 12px; border-radius:4px; cursor:not-allowed;">Need 10 Iron Ore & 200g</button>`;
        }
        
        html += `</div>`;
        html += `</div>`;
      });
      
      html += '</div>';
    }
    
    openModal(html, (btn) => {
      console.log('Button clicked:', btn.dataset);
      if(btn.dataset.repair !== undefined) {
        const equipmentIndex = parseInt(btn.dataset.repair);
        repairEquipment(damagedEquipment[equipmentIndex]);
      } else if(btn.dataset.ironRepair !== undefined) {
        const equipmentIndex = parseInt(btn.dataset.ironRepair);
        console.log('Iron repair clicked for equipment:', equipmentIndex);
        ironOreRepair(damagedEquipment[equipmentIndex]);
      }
    });
  }
  
  function repairEquipment(equipment) {
    if(p.g < 100) {
      log("Not enough gold! Need 100g for repair.");
      return;
    }
    
    // Find level 1 version of the same equipment
    const level1Index = p.eq.findIndex(item => 
      item.name === equipment.name && 
      (item.level || 1) === 1 && 
      item !== equipment
    );
    
    if(level1Index === -1) {
      log("Need a Level 1 version of this equipment to repair it!");
      return;
    }
    
    // Remove the level 1 version
    p.eq.splice(level1Index, 1);
    
    // Add random durability (20-60) to equipment, max 100
    const repairAmount = Math.floor(Math.random() * 41) + 20; // 20-60
    const newDurability = Math.min(100, equipment.durability + repairAmount);
    equipment.durability = newDurability;
    
    p.g -= 100;
    
    log(`Repaired ${equipment.name.replace(/_/g, ' ')} Level ${equipment.level || 1}!`);
    log(`Durability restored by ${repairAmount} (now ${newDurability}/100)`);
    
    closeModal();
    updateUI();
  }

  function ironOreRepair(equipment) {
    const ironOre = p.inv['Iron Ore'] || 0;
    
    if(p.g < 200) {
      log("Not enough gold! Need 200g for iron ore repair.");
      return;
    }
    
    if(ironOre < 10) {
      log("Not enough iron ore! Need at least 10 iron ore.");
      return;
    }
    
    // Use exactly 10 iron ore for 10 durability
    const ironOreAmount = 10;
    const durabilityAmount = 10;
    
    // Remove iron ore and gold
    p.inv['Iron Ore'] -= ironOreAmount;
    p.g -= 200;
    
    // Add 10 durability, max 100
    const newDurability = Math.min(100, equipment.durability + durabilityAmount);
    equipment.durability = newDurability;
    
    log(`Iron ore repair complete! Used ${ironOreAmount} iron ore and 200 gold.`);
    log(`${equipment.name.replace(/_/g, ' ')} Level ${equipment.level || 1} durability: ${newDurability}/100`);
    
    closeModal();
    updateUI();
  }

  function closeModal(){
    OV.style.display='none';
    MD.style.display='none';
    MD.innerHTML='';
    inventoryModalOpen = false;
    craftingModalOpen = false;
    isQuestPopupOpen = false; // Reset quest popup flag when modal is closed
  }
  
  // Welcome Modal
  function showWelcomeModal() {
    const welcomeModal = d('#welcome-modal');
    const overlay = d('#overlay');
    welcomeModal.style.display = 'block';
    overlay.style.display = 'block';
  }
  
  function closeWelcomeModal() {
    const welcomeModal = d('#welcome-modal');
    const overlay = d('#overlay');
    welcomeModal.style.display = 'none';
    overlay.style.display = 'none';
  }

  function openNpcQuestLog() {
    let content = '<h3>NPC Quest Log</h3>';
    
    if (randomNpcActiveQuests.length === 0) {
      content += '<p>No active NPC quests.</p>';
    } else {
      content += '<div class="quest-list">';
      randomNpcActiveQuests.forEach(quest => {
        let progressInfo = '';
        let canComplete = true;
        
        Object.entries(quest.need).forEach(([item, needed]) => {
          const have = quest.type === 'kill' ? (quest.progress[item] || 0) : (p.inv[item] || 0);
          const current = Math.min(have, needed);
          quest.progress[item] = current;
          const progressColor = current >= needed ? '#4CAF50' : '#FFA726';
          progressInfo += `<span style="color: ${progressColor};">${item.replace(/_/g, ' ')}: ${current}/${needed}</span><br>`;
          if (current < needed) canComplete = false;
        });
        
        const statusText = canComplete ? ' <span style="color: #4CAF50;">[Ready to turn in to NPC or Guild (G)]</span>' : ' <span style="color: #FFA726;">[In Progress]</span>';
        const rewardText = quest.isConsumable ? 
          (quest.reward === 'Scroll of Healing' ? 'Scroll of Healing' : 'Strength Potion') :
          quest.reward.replace(/_/g, ' ');
        
        content += `
          <div class="quest-item" style="margin-bottom: 15px; padding: 10px; border: 1px solid ${canComplete ? '#4CAF50' : '#444'}; border-radius: 5px; background: rgba(${canComplete ? '76, 175, 80' : '68, 68, 68'}, 0.1);">
            <h4 style="margin: 0 0 5px 0; color: #e8eaed;">${quest.name}${statusText}</h4>
            <p style="margin: 5px 0; color: #c0c4c7; font-style: italic;">${quest.desc}</p>
            <div style="margin: 5px 0;">
              <strong>Progress:</strong><br>
              ${progressInfo}
            </div>
            <div style="margin: 5px 0;">
              <strong>Reward:</strong> <span style="color: #4CAF50;">${rewardText}</span>
            </div>
            <div style="margin: 5px 0; font-size: 0.9em; color: #888;">
              Area: (${quest.areaX}, ${quest.areaY}) - Return to the NPC who gave you this quest to turn it in
            </div>
          </div>
        `;
      });
      content += '</div>';
    }
    
    openModal(content);
  }

  // Bind & init
  document.addEventListener('DOMContentLoaded',()=>{
    ['up','down','left','right'].forEach(dn=>d(`[data-dir="${dn}"]`).onclick=()=>move(dn));
    d('#btn-inv').onclick    = openInventory;
    d('#btn-craft').onclick  = openCraft;
    d('#btn-shop').onclick   = openGlobal;
    d('#btn-quests').onclick = openQuests;
    d('#btn-npc-quests').onclick = openNpcQuestLog;
    d('#btn-reborn').onclick = ()=>{
      // Check if player has resurrection charm active
      if(p.resurrectionCharm) {
        // Resurrection charm provides one-time reborn with all stats intact
        p.resurrectionCharm = false;
        p.hp = p.maxHp;
        p.x = 264; p.y = 264; // Return to town
        log("Resurrection Charm activated! Reborn with all stats intact!");
        updateUI();
        return;
      }
      
      // Disable the reborn button to prevent double clicks
      const rebornBtn = d('#btn-reborn');
      rebornBtn.disabled = true;
      rebornBtn.style.opacity = '0.5';
      rebornBtn.textContent = 'Reborning...';
      
      // Show loading message
      log("Reborning... Please wait.");
      
      // Use setTimeout to defer heavy operations to next tick
      setTimeout(() => {
        try {
          // Preserve banking data before reset
          const preservedBankGold = p.bankGold || 0;
          const preservedBankDeaths = p.bankDeaths || 0;
          
          // Clear save data
          localStorage.removeItem(SAVE);
          LEl.innerHTML='';
          
          // Clear quest arrays
          quests = [];
          randomNpcActiveQuests = [];
          
          // Reset quest popup state
          isQuestPopupOpen = false;
          
          // Reinitialize game
          init();
          
          // Restore banking data after reset
          p.bankGold = preservedBankGold;
          p.bankDeaths = preservedBankDeaths;
          
          log("Reborn! Your banked gold has been preserved.");
          updateUI();
          
        } catch (error) {
          log("Error during reborn process: " + error.message);
        } finally {
          // Re-enable the reborn button
          rebornBtn.disabled = false;
          rebornBtn.style.opacity = '1';
          rebornBtn.textContent = 'Reborn';
        }
      }, 100); // Small delay to allow UI to update
    };
    
    // Welcome modal functionality
    d('#start-game-btn').onclick = () => {
      closeWelcomeModal();
      log("Adventure begins!");
    };
    
    OV.onclick=() => {
      if(d('#welcome-modal').style.display === 'block') {
        closeWelcomeModal();
        log("Adventure begins!");
      } else if(QM.style.display === 'block') {
        closeQuestPopup();
      } else {
        closeModal();
      }
    };
    
    init();
    showWelcomeModal(); // Show welcome modal on page load
    log("Welcome to Dungeon Quest!");
    updateUI();
  });
})();
</script>
</body>
</html>
